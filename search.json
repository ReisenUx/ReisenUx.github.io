[{"title":"Git","date":"2022-03-30T08:28:29.456Z","url":"/2022/03/30/Git/","categories":[["undefined",""]],"content":" 472f0d2124ee617a2f29ff331422d5d3bd292059877923b2bde10f8b4beeb582b5677b97997720bb57b85e0be7567461086ac77154c3b73a123f9a7bd362615b985202fe042ae33378e199941510a256bd119c3f7bd94adfec7da650e928f3eb07c7e884e2c2926cf60d80d96d41147a7feee723b83d1f7b2b19a4cda3c6c4b1cbde4f18c0b820e742620d77c0e341839b114b65dce617bbd7ce6f44f6e393a0da648346fd65a5d49ec00b39e58d5d925ef0fc3a269a5edbe6d03c305189ee3261e43ee03b42068d6aaccc4d563c4d51d14088883f9decdf86ab07117e3a43f6ea70e45e9d9474f4e06b9fc82ed5b8eaed59df06dc7f6aceac3a4e8df60c4f9d703e6580959c1a6d43af49507aa95abe73bea0c92e45c405e2d09a9d10c8f963462176b3666e5b8a951c3974ffcc0342f1dd40638a276d6e76e40c55b15e9b2f86bbc05263e053f499936125e765237e88a244f987b56451e7940b1f1ed7efba10a68c0bce250725543dc7cc9f598065de90d61d18443a45657fa1977cd82bfb1caa82825d25afbc2fe631a5319f076d644b2e81a2d6f657a7fd53cf3f17cf25da278f6691f1e94fe8a209ed2593164eacaf7b6686afb47f16a790103621ac06c573d52559d0cf10c3e99a64166bac8c9bc9f975da9943f81742a5b11c3571b7b5533d5a8889ed852582db0df44515070948b3ce5648d4a4c923feed8f7892251d423a0435849a9a275ea6a3464647f17146ba716b8ff79776bcfa34bdf408adb13f4a529b350a339a3c829c460854a4bd9d3fb35b693088aea0588e701887321ff28b8d6f3a0da8ad8d4c8ef6d820742396239aee8e091bb41ad5dc0519a578aa35446985f9f6f0e17b400d7851b93cb57b10fff555695329ed7860d23e9906f52563721196e43e3a27ef2c7bc788f03361814670b35fdf7c793eb611f11e8588f916c80c40db5714a5b0065f27577eb4581abdc1f95bc0386ef017cbd7e681c7acdd38f639a6f9c4825fe5c7a5d41e732a0c6ac188780cd857ba0de35083641ba21c0586b791b5b3235385b76f42a5b44ac30aea7e4ce73b56da1ec5226d79f2a36f9bb3d555450f2ebc6b0c8d165e14dbf33010caef86244ec4826353fd9ac813b83e4ae3bec17883498dd06e00d125e93b9d0f7a8ff4c63020e785ca49f99a4ccae2e760df1b3fd276205e6c4274ea1af658522c0761f6caf5caaafc7a963f77c2935cebdbd4ed2579667e96de4a5b2790608c0cd085fd2168ea85b03e1d018b327f60c070b11365a2bd0c9e0716914e19ec6d77f5e27b15bb20ec57acc4c92a0d7c6277770688cc8a441289c50eeb50e7028569c4daaecc233b6ba1839a6fcc037fe5f479d4c53bec8302e603cdc003e417d2c8607dbf26ff26a74a2d67385a1c76f40794e849c27f6a514f49c9d862948cc11c1f5bff7e812681d7d8e58f047518173306ed11eaff69c5ea412362d899d676f6b81e82480c11aef8e533b74fc0a1dc73cea66864eebec698f4c9f2a5d64f91c8142ff1a4a4ecc47143e9014e7953c2488aaac0c5b3ac6498abb41c653c0e4f187aeb03a0e20c4ca22177fbd9ec425b456ce1b89244b979d7285d474b210b9afe79e4b4c3815b23787d0758323aef6d8fecd8baa7cf8c02977c85c5228e636e051e189f904ec1dd47b7f86f8b4abca5859808e90d2a7f7cddc0b8 Hey, password is required here. "},{"title":"cppRest","date":"2022-03-28T05:19:53.000Z","url":"/2022/03/28/cppRest/","categories":[["undefined",""]],"content":"Cpp 其余问题1、C++的多态性C++的多态性，一言以蔽之即：在基类的函数前加上virtual关键字，在派生类中重写该函数运行时将会根据所指对象的实际类型来调用相应的函数如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。 举例： C++多态性 例子中，Base为基类，其中的函数为虚函数。子类1继承并重写了基类的函数，子类2继承基类但并没有重写基类的函数，从结果分析，子类体现了多态性。 多态性和底层原理？ 虚表 虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。 虚表指针 在含有虚函数的类实例化对象时，对象地址的前四个字节存储指向虚表的指针。 上图展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程： 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里面保存了虚函数的入口地址。 编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。 所谓合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只”看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面。 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态进行调用，从而实现多态性。2、为什么析构函数一般写成虚函数由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数。而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。 如果析构函数不被声明称虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数从而导致派生类对象析构不完全，造成内存泄漏. 所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的情况发生，要将基类的析构函数声明为虚函数。 析构函数不是虚函数 将基类的析构函数声明为虚函数： 析构函数是虚函数 但存在一种特例，在CRTP【编译时绑定】模板中，不应该将析构函数声明为虚函数理论上所有的父类函数都不应该声明为虚函数，因为这种继承方式，不需要虚函数表。 3、构造函数能否声明为虚函数或者纯虚函数，析构函数？ 析构函数： 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才会精准调用派生类的析构函数（从该级向上调用虚函数），才能准确销毁数据 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类可以根据自身需求重新改写基类中的纯虚函数。 构造函数： 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而非子类虚函数因为此时子类尚未构造好。 虚函数对应一个vtable（虚函数表），类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。【只有在构造函数之后，才有虚函数表，只有虚函数表，才能调用虚函数】 4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间首先整理虚函数表的特征： 虚函数表是全局共享的元素，即全局只有一个，在编译时就构造完成。 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段。 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中。 根据以上特征，虚函数表类似于类中静态成员变量。静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示： 虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段中（rodata）这与MS的编译器将虚函数表存放在常量段存在一些差别 由于虚表指针vptr和虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。 一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区。 C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数位于代码段（.text），也就是C++内存模型中的代码区。 5、模板函数和模板类的特例化 引入原因：编写单一的模板，能适应多种类型的需求，使每种类型都具有相同的功能但对于某种特定的类型，如果要实现其特有的功能，单一模板就无法做到，此时需要模板特例化 定义：对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上 模板函数特例化 必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一对空尖括号 表明将原模板的所有模板参数提供实参 举例： 特例化模板函数 本质特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如：此处如果是compare(3, 5)，则调用普通的模板，若为compare(“hi”, “haha”)则调用特例化版本（因为const char*相对于T，更匹配实参类型） 注意二者函数体的语句不同，实现不同功能。 注意模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。 类模板特例化 原理类似函数模板， 不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。 对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如： 特例化类模板 类模板的部分实例化不必为所有模板参数提供实参，可以指定一部分而非所有模板参数一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参（特例化时类名一定要和原来的模板相同，只是参数类型不同，按照最佳匹配原则，哪个最匹配，就调用相应的模板） 特例化类中的部分成员可以特例化类中的部分成员函数而非整个类，举例： 特例化部分成员 6、构造函数、析构函数、虚函数可否声明为内联函数首先，将这些函数声明为内联函数，在语法上没有错误。因为inline和register一样，只是个建议，编译器并不一定内联。 register关键字：这个关键字请求编译器尽可能将变量存在CPU内部寄存器中，而不是通过内存寻址，可以提高效率。 举例： 构造函数和析构函数声明为内联函数是没有意义的《Effective C++》中阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等）导致构造函数&#x2F;析构函数并不像看上去的那么精简。 其次，class中的函数默认是inline型的，编译器也只是有选择地inline将构造函数和析构函数声明为内联函数是没什么意义的。 将虚函数声明为inline，要分情况讨论。有的人认为虚函数被声明为inline，但是编译器并没有对其内联，理由是：inline是编译期决定的，虚函数是运行期决定的即在不知道将要调用哪个函数的情况下，如何将函数内联呢？ 上述观点看似正确，实则不然如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数？即对象调用虚函数（此时不具有多态性）时，就内联展开。 综上： 当是指向派生类指针（具有多态性）调用声明为inline的虚函数时，不会内联展开； 当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下；【不用指针时】 7、C++模板是什么、底层如何实现？ 编译器并不是把函数模板处理成能够处理任意类的函数编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替代后的代码进行编译。 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，则编译器无法实例化该模板，最终导致链接错误， 8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？ 从存储空间角度 虚函数需要一个指向vtable虚函数表的指针，但该指针事实上是存储在对象的内存空间的。 假设构造函数是虚函数，就必须要用vtable来调用，但对象还没有实例化，也就是说内存空间还没有，如何找到vtable？ 所以构造函数不能是虚函数。 从使用角度 虚函数主要用于在信息不全情况下，能使重载的函数得到相应的调用。【指针指向不明确】 构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。 所以构造函数没有必要是虚函数，虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的成员函数。 而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 构造函数不需要是虚函数，也不同意是虚函数 由于创建一个对象时我们总是要明白指定对象的类型，虽然我们可能通过基类指针或引用去访问它但析构函数不一定 我们往往通过基类的指针去销毁对象。 此时假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。 从实现上看 vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数 从实际意义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调用父类的构造函数） 并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。 当一个构造函数被调用时，它要做的首要的事情其中一个就是初始化vptr 因此，它仅仅能够知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。 当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码 —— 既不是基类，也不是它的派生类（由于类不知道谁继承他） 所以它使用的vptr必须是对应这个类的vtable。【构造函数值对应自己】 并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命周期内，vptr将保存被初始化为指向这个vtable， 但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置vptr指向它的vtable…等。直到最后的构造函数结束。 vptr的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还一个理由。 可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置vptr指向它自己的vtable。 假设函数调用使用虚函数机制，它将仅仅产生通过它自己的table调用，而不是最后的vtable（全部构造函数被调用后才有最后的vtable） 因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了在不完全了解细节的情况下也能正确处理对象。 另外，virtual函数是在不同类型的对象产生不同的动作，而现在对象还没有产生，如何使用virtual函数实现想要的动作？ 直白的讲：C++中基类采用的virtual虚析构函数是为了防止内存泄漏 具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。 假设基类中采用的是非析构函数，当删除基类指针指向的派生类对象时，就不会产生动态绑定，因而只会调用基类的析构函数，而不是派生类析构函数。 这种情况下，派生类中申请的空间就会因为得不到释放而产生内存泄漏 所以，为了防止这种情况发生，C++中基类的析构函数应采用virtual虚析构函数。9、析构函数的作用，如何起作用？ 构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里有值了 规则：只要你一实例化对象，系统自动回调一个构造函数；尽管不写，编译器也自动调用一次 析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数面前加~ 析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。 每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。 10、构造函数和析构函数可以调用虚函数吗，为什么？ 在C++中，不提倡在构造函数和析构函数中调用虚函数； 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数和析构函数中调用虚函数，则运行的是构造函数或析构函数自身类型定义的版本。 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全，因此C++不会进行动态联编 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义 11、构造函数、构造函数的执行顺序？构造函数和拷贝构造的内部都干了啥？ 构造函数顺序 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而非在成员初始化表中的顺序 成员类对象构造函数，如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序，而非在成员初始化表中的顺序 派生类构造函数 析构函数顺序 调用派生类的析构函数 调用成员类对象的析构函数 调用基类的析构函数 12、虚析构函数的作用、父类的析构函数是否要设置为虚函数？ C++中基类采用virtual虚析构函数是为了防止内存泄漏 具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。 假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。 那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。 所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。 纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。 因此，缺乏任何一个基类析构函数的定义，就会导致链接失败 最好不要把虚析构函数定义为纯虚析构函数。 13、构造函数析构函数可否抛出异常？ C++只会析构已经完成的对象，对象只有在其析构函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。 因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。 用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不在要在析构函数中手动释放资源。 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束。 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。 14、构造函数一般不定义为虚函数的原因 创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型。 虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚析构函数了 虚函数的作用在于通过父类的指针或者引用调用它时能变成调用相应子类的成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类或引用去调用，因此就规定构造函数不能是虚函数。 析构函数一般都要声明为虚函数，不再赘述。 15、类什么时候会析构？ 对象生命周期结束，被销毁时 delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用 16、构造函数或者析构函数中可以调用虚函数吗？简要结论： 从语法上讲，没有问题 从效果上将，往往不能达到需要的目的。 《Effective C++》的解释：派生类对象构造期间进入基类的构造函数时对象类型变成了基类类型，而非派生类类型；进入基类析构函数时，对象也是基类类型。 举个例子： 语句1，理论上应该体现多态性，执行类A中的构造和析构函数从实验结果来看，语句1并没有体现，执行流程是先构造基类，所以先调用基类的构造函数，构造完成再执行A自己的构造函数析构时也是调用基类的析构函数，也就是说构造和析构中调用虚函数并不能达到目的，应该避免。【没有实现动态绑定，只是和指针相关类对应的虚函数】 如果析构函数改为虚函数，则可以多一个A::Function17、构造函数的几种关键字 defaultdefault关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错 如果没有语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题 deteledelete关键字可以删除构造函数、赋值运算符函数等，这样在使用时会得到提示 在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误因此使用delete关键字可以更加人性化的删除一些默认方法。 0将虚函数定义为纯虚函数，纯虚函数无需定义，&#x3D;0只能出现在类内部虚函数的声明语句处当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。 18、构造函数、拷贝构造函数和赋值操作符的区别 构造函数对象不存在，没用别的对象初始化，在创建一个对象时调用构造函数 拷贝构造函数对象不存在，但是使用别的已经存在的对象来进行初始化 赋值运算符对象存在，用别的对象给它赋值，这属于重载“&#x3D;”号运算符的范畴，“&#x3D;”两侧的对象都是已经存在的。 举例： 19、拷贝构造函数和赋值运算符重载的区别？ 拷贝构造函数是函数，赋值运算符是运算符重载。 拷贝构造函数会生成新的类对象，赋值运算符不生成新的对象 拷贝构造函数是直接构造一个新的类对象，所以在初始化之前不需要检查源对象和新建对象是否相同赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数）但并不是所有出现”&#x3D;”的地方都是使用赋值运算符，如下： 注意：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。20、什么是虚拟继承由于C++支持多继承，除了Public、Protected、Private三种继承方式外，还支持虚拟（virtual）继承举例： 上述代码所体现的关系是：B和C虚拟继承A，D又公有继承B和C，这种方式是一种菱形继承或钻石继承，可以用下图来表示 虚拟继承情况下，无论基类被继承多少次，只会存在一个实体。虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针又称为bptr，如上图所示。 如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。 补充：虚继承中，B和C不再保存A中的内容，保存了一份偏移地址，将A的数据保存在一个公共位置处，降低数据冗余性。 21、什么情况会自动生成默认构造函数？ 带有默认构造函数的类成员对象如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器为该类合成出一个默认构造函数。 不过这个合成操作只有在构造函数真正被需要的时候才会发生。 如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行。 带有默认构造函数的基类如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数 带有一个虚函数的类【生成vptr】 带有一个虚基类的类【生成bptr】 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。其他所有的非静态数据成员都不会被初始化。【仅初始化类】 22、抽象基类为什么不能创建对象？抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层。 抽象类的定义：称带有纯虚函数的类为抽象类 抽象类的作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根派生类将具体实现在其基类中作为接口的操作。 所以派生类实际上刻画了一组子类的操作接口通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。 抽象类是不能定义对象的，一个纯虚函数不需要（但是可以）被定义。 纯虚函数定义：纯虚函数是一种特殊的虚函数，它的一般格式如下： 在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。纯虚函数可以让类现有一个操作名称，但没有操作内容，让派生类在继承时具体地给出定义。 凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的纯虚函数，否则，派生类变成了抽象类，也不能实例化对象。 纯虚函数引入原因： 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 在很多情况下，基类本身生成对象是不合情理的。例如：动物作为一个基类可以派生出猫狗等子类，但动物本身生成对象明显不合理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function() &#x3D; 0） 若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 例如：绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等如果要求面积总和的话，那可以使用一个shape *的数组，只要一次调用派生类的area()函数了。 如果不用接口就没法定义成数组，因为既可以是circle，也可以是square，而且以后还可能加上rectangle等等。 相似概念 多态性指相同对象收到不同消息或不同对象收到相同消息时产生的不同实现动作C++支持两种多态性：编译时多态性、运行时多态性。 编译时多态性：通过重载函数、模板实现。 运行时多态性：通过虚函数实现。 虚函数虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 抽象类包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。 23、模板类和模板函数的区别是什么？函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。 即函数模板允许隐式调用和显式调用而类模板只允许显式调用。 在使用时类模板必须加，而函数模板不必加。24、多继承的优点，作为一个开发者怎么看待多继承 C++允许一个派生类指定多个基类，这样的继承结构被称为多继承。 多重继承的优点很明显，就是对象可以调用多个基类中的接口 如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性。 加上全局符确定调用哪一份拷贝，比如pa.Author::eat()调用属于Author的拷贝 使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝 25、模板和实现可不可以不写在一个文件里？为什么？因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现 在这种情况下编译器是不知道实现模板类或函数的cpp文件所在，所以只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。 但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 《C++编程思想》第15章（300页）说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间。它一直处于等待状态直到被一个模板实例告知。在编译器和链接器的某一处，有一个机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。 即，不能不写在一个文件里，因为由template处理的任何东西都意味着编译器在当时不分配存储空间 26、将字符串”hello world”从开始到打印到屏幕上的全过程？ 用户告诉操作系统执行HelloWorld程序（通过键盘输入等） 操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。 操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。 操作系统：为helloworld程序设置cpu上下文环境，并跳转到程序开始处。 执行helloworld程序的第一条指令，发生缺页异常。 操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序 helloworld程序执行puts函数（系统调用），在显示器上写一字符串 操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以操作系统将要写的字符串送给该进程。 操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作然后将字符串转换成像素，将像素写入设备的存储映像区 视频硬件将像素转换成显示器可接收和一组控制数据信号 显示器解释信号，激发液晶屏 屏幕上看到了HelloWorld 27、为什么拷贝构造函数必须传引用不能传值 拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例 参数传递过程到底发生了什么？将地址传递和值传递统一起来，归根结底还是传递的是“值”（地址也是值，只不过通过它可以找到目标值） 值传递： 对于内置数据类型的传递时，直接赋值拷贝给形参（注意形参是函数内局部变量）； 对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参（局部对象）； 如void foo(class_type obj_local){}，如果要调用foo(obj); 首先class_type obj_local(obj)，这样就定义了局部变量obj_local供函数内部使用。 引用传递： 无论对内置类型还是类类型，传递引用和指针最终都是传递的地址值 而地址总是指针类型（属于简单类型），显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用（对于类类型） 因此，如果拷贝构造函数使用值传递会产生无限递归调用，内存溢出。 拷贝构造函数用来初始化一个非引用类类型对象如果用值方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归 28、静态函数能定义为虚函数吗？常函数呢？ static成员不属于任何类对象或类实例，所以即使给此函数加上virtual也是没有任何意义的。 静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。 虚函数依靠 vptr 和 vtable 来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员。并且vptr指向保存虚函数地址的vtable，对于静态成员函数，它没有this指针，所以无法访问 vptr。 这就是为何static函数不能为virtual虚函数的调用关系： this-&gt;vptr-&gt;vtable-&gt;virtual function 29、虚函数的代价？ 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类所占空间。 带有虚函数的每个类的每一个对象，都会有一个指向虚表的指针，会增加对象的空间大小； 不能再是内联函数，因为内联函数在编译阶段进行替代，而虚函数需要动态等待在运行阶段才能确定到底是采用哪种函数，虚函数不能是内联函数。 30、说一说移动构造函数？ 有时候我们会遇到这样一些情况，我们用对象a初始化对象b之后，对象a就不再使用了，但对象a的空间还在（在析构之前）既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，为什么不能直接使用对象a的空间？ 这样就避免了新的空间分配，大大降低了构造成本，这就是移动构造函数设计的初衷。 拷贝构造函数中，对于指针，我们一定要使用深拷贝；移动构造函数中，对于指针，我们使用浅拷贝 C++引入了移动构造函数，专门处理这种，用对象a处理对象b之后就将a析构的情况。 与拷贝类似，移动也使用一个对象的值去设置另一个对象的值。但是，与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）： 源对象将丢失其内容，其内容被目的对象占有。移动操作发生的时候，是当移动值的对象是未命名对象的时候。 这里未命名的对象就是那些临时变量，甚至都不会有名称。 典型的未命名对象就是函数的返回值或类型转换的对象。 使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其他使用，因为，它的值可以被移动到目的对象。 做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化时，调用移动构造函数。 类似的，使用未命名的变量值赋值给一个对象时，调用移动赋值函数。 举例： 31、什么情况下会合成构造函数？ 如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用 没有任何构造函数的类派生自一个带有默认构造函数的基类那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用。 带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化。【vptr】 带有一个虚基类的类 还有一点需要注意的是： 并不是任何没有构造函数的类都会合成一个构造函数 编译器合成出来的构造函数并不会显示设定类内的每一个成员变量 32、什么时候需要合成拷贝构造函数？三种情况会以一个对象的内容作为另一个对象的初值： 对一个对象做显式的初始化操作 X xx &#x3D; x; 当对象被当做参数交给某个函数时;（传值） 当函数传回一个类对象时; 注意： 如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数 如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数 33、构造函数的执行顺序？ 在派生类构造函数中，所有虚基类及上一层基类的构造函数调用 对象vptr被初始化 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做 执行程序员所提供的代码 34、一个类中全部构造函数的扩展过程是什么？ 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序 如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用 如果class有虚表，那么它必须被设定初值 所有上一层基类的构造函数必须被调用 所有虚基类的构造函数必须被调用 35、哪些函数不能是虚函数？ 构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化 内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定编译阶段和运行阶段冲突，所以内联函数不能是虚函数。 静态函数，静态函数不属于对象而属于类整体静态函数没有this指针，因此静态函数设置为虚函数没有任何意义 友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。 普通函数，普通函数不属于类的成员函数，不具有继承特性因此普通函数没有虚函数 36、什么是纯虚函数，与虚函数区别 虚函数和纯虚函数区别？ 虚函数是为了实现动态联编产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数） 虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。【返回类型，参数等要相同】当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数 在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同. 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化 纯虚函数首先是虚函数，其次没有函数体，取而代之的是用”&#x3D;0”。 既然是虚函数，它的指针就会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而须有函数体的虚函数则是函数的具体地址。 一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。 抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象【否则也是接口】 举例： "},{"title":"cpp11","date":"2022-03-27T05:01:31.000Z","url":"/2022/03/27/cpp11/","categories":[["undefined",""]],"content":"C++ 11新标准1. C++ 11有哪些新特性？ nullptr 替代 NULL 引入了auto 和 decltype 这两个关键字实现了类型推导 基于范围的 for 循环 for(auto &amp;i : res){} 类和结构体中的初始化列表 Lambda表达式（匿名函数） std::forward_list（单向链表） 右值引用和move语义 … 2、auto、decltype和decltype(auto)的用法 autoC++ 11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来哪些只对应某种特定类型的说明符（例如int）不同 auto让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说auto定义的变量必须有初始值。 举例： decltype有时候我们还会遇到这种情况：我们希望从表达式中推断出要定义变量的类型，却不想用表达式的值去初始化变量。 还有可能是函数的返回值为某表达式的值类型。此时auto无能为力，所以C++11引入了第二种类型说明符decltype它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值 例如： decltype(auto)decltype(auto) 是 C++14 新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将”&#x3D;”左侧的表达式替换掉auto，在根据decltype的语法规则来确定类型。 举例： C++中NULL和nullptr的区别算是为了与C语言进行兼容而定义的一个问题 NULL来自C语言，一般由宏定义实现，而nullptr则是C++11的新增关键字。在C语言中，NULL被定义为(void*) 0，而在C++语言中，NULL则被定义为整数0。 编译器一般对其实际定义如下： 在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况： 那么在传入NULL参数时，会把NULL当做整数0来看，但如果想调用参数是指针的函数，如何解决？ nullptr在C++中被引入解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。 nullptr的一种实现方式如下： 以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化，从而解决了（void）指针带来的参数类型不明问题 另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆 但nullptr仍存在一些问题，例如： 在这种情况下存在对不同指针类型的函数重载，次数如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显式指明指针参数类型。 4、智能指针的原理、常用的智能指针及实现 原理智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源。 常用的智能指针 shared_ptr 实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部引用计数加1 每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动释放动态分配的资源。 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共多少个类对象共享一个指针 每次创建类的新对象时，初始化指针并将引用计数置为1 当对象作为另一个对象的副本而创建时，拷贝构造函数拷贝指针增加与之相应的引用计数 当一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（若引用计数减为0，则删除对象，并增加右操作数所指对象的引用计数。 调用析构函数时，构造函数减少引用计数（如果引用计数减为0，则删除基础对象） unique_ptr unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。 转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空； 所以unique_ptr不支持普通的拷贝的赋值操作，不能用在STL标准容器中； 局部变量的返回值除外（因为编译器知道返回的对象将要被销毁） 如果拷贝一个unique_ptr，那么拷贝结束后，两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。 weak_ptr weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。 需要使用weak_ptr打破环形引用。 weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针 它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，只引用，不计数。 如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。 所以weak_ptr不保证它所指向的内存一定是有效的 在使用之前使用函数lock()检查weak_ptr是否为空指针。 auto_ptr 主要是为了解决“有异常抛出时发生内存泄漏”的问题。因为发生异常，无法正常释放内存。 【构造函数构造A&#x2F;B资源时候有一个失败，则其析构函数不会触发】 auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题； 而unique_ptr则无语义拷贝，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。 auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。 STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。 智能指针shared_ptr代码实现： 5、关于lambda函数的全部知识 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象。 每当定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称之为闭包类型（closure type）那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。 所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉器封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，称之为lambda捕捉块。 lambda表达式的语法定义如下： lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体。 6、智能指针的作用 C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄漏（忘记释放）、二次释放、程序发生异常时内存泄漏等问题使用智能指针可以更好地管理内存。 智能指针在C++11版本后提供，包含在头文件&lt; memory&gt;中，shared_ptr、unique_ptr、weak_ptr。shared_ptr多个指针指向相同的对象，shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数就会加1；每析构一次，内部的引用计数就会减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。 初始化智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。 例如：std::stared_ptr p4 &#x3D; new int(1);写法是错误的 拷贝和赋值拷贝使得对象的引用计数+1，赋值使得原对象引用计数-1，当计数为0时，自动释放内存。后来指向的对象引用计数+1，指向后来的对象。 unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比于原始指针，unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。 unique_ptr指针本身的生命周期： 从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象存在，则将其所指对象销毁（默认用delete操作符，用户可指定其他操作） unique指针与其所指对象关系： 在智能指针生命周期内，可以改变智能指针所指对象， 如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权 智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果减为0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（若引用计数减为0，则删除基础对象） weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象进行该对象的内存管理的是那个强引用的shared_ptrweak_ptr只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是为了配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它置可以从一个shared_ptr或另外一个weak_ptr对象构造它的构造和析构不会引起计数的增加或减少。 7、说说了解的auto_ptr作用 auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏。 auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身拥有的指针空间释放，所以不会有内存泄漏； auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的喜爱那个必须要用auto_ptr的构造函数创建对象； 由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一指针； auto_ptr内部实现，析构函数中删除对象用的是delete而非delete[]，所以auto_ptr不能管理数组； auto_ptr支持所拥有的指针类型之间的隐式类型转换； 可以通过*和-&gt;运算符对auto_ptr所有用的指针进行操作 T* get()，获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。 8、智能指针的循环引用循环引用是指使用多个智能指针shared_ptr，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。 举例： 从上面shared_ptr的实现中我们知道了只有当引用计数–之后等于0，析构时才会释放对象，而上述情况造成了一个僵局那就是析构对象时限析构sp2，可是由于sp2的空间sp1还在使用中，所以sp2.use_count–后为1，不释放，sp1也同理，由于sp1的空间sp2还在使用中，所以sp1.use_count–之后为1，也不释放。 sp1等着sp2先释放，sp2等着sp1先释放，二者互不谦让，导致最终都没能释放，内存泄漏。 在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针weak_ptr，不增加引用计数，只要出了作用域自动析构。9、手写实现智能指针需要实现哪些函数？ 智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还要提供自动垃圾回收机制。他会自动记录SmartPointer&lt; T*&gt; 对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象 除了指针对象以外，还需要一个引用计数的指针设定对象的值，并将引用计数记为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。 通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1 一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数 10、智能指针出现循环引用如何解决？弱指针weak_ptr专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不会影响对象的引用计数器。 循环引用即：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。"},{"title":"cppMemory","date":"2022-03-26T10:42:58.000Z","url":"/2022/03/26/cppMemory/","categories":[["undefined",""]],"content":"C++内存管理1、类的对象存储空间？ 非静态成员数据类型大小之和 编译器加入的额外成员变量（如指向虚函数表的指针）。 为了边缘对齐优化增加的padding空类（无非静态数据成员）的对象的size为1，当作为基类时，size为0。 2、简要说明C++的内存分区C++中的内存分区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区和代码区。如下图所示： 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限 堆：就是那些由new分配的内存块，他们的释放编译器不去管，由应用程序控制（程序员控制），一般一个new要对应一个delete。 如果程序员没有释放掉，那么程序结束后，操作系统会自动回收。 自由存储区：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。 注意，自由存储区和堆比较像，但不等价。【自由存储区是一个逻辑概念】 全局&#x2F;静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化和未初始化的。 在C++中没有这个区分了，他们共同占用同一块内存区，在该区定义的变量如果没有初始化，则会被自动初始化，例如int类型自动初始化为0 常量存储区：是一块比较特殊的存储区，里面存放的是常量，不允许修改 代码区：存放函数体的二进制代码3、什么是内存池，如何实现？内存池（Memory Pool）是一种内存分配方式通常我们习惯直接用new、malloc等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。 简述《STL源码剖析》中内存池实现机制： allocate包装malloc、deallocate包装free 一般是一次20*2个的申请，先用一半，再留一半【原因未知】，说是C++委员会认为20是个比较好的数字，不大也不小。 首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数）假设40个32B的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32B） 客户端之后有内存需求，想申请（20*64B）的空间，这时内存池只有（20 *32B）就先将（10 *64B）个区块返回，1个区块交出，另外9个维护状态，此时内存池空空如也。 接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量。同样一般提供程序使用，另外一般留给内存池。申请内存的时候永远是先看内存池有无剩余，有的话就用，然后挂载到0-15号某一条链表上，要不然就重新申请。 如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常。 allocator 就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。 内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()说白了就是和直接使用new运算符的效果是一样的，所以没做任何特殊处理 其实最开始GC2.9之前new 和 operator new 的区别：new是个运算符，编辑器会调用 operator new(0) operator new()里面有调用malloc的操作，同样operator delete()里面有调用 free的操作。 GC 2.9 下的alloc函数一个比较好的分配器实现规则如下：维护一条0-15号的一共16条链表，其中0号表示8B，1号表示16B，2号表示24B……15号表示16 * 8 &#x3D; 128B。 如果在申请内存时，申请内存的大小并不是8的倍数（例如2&#x2F;4&#x2F;7&#x2F;9&#x2F;18这样不是8的倍数），那就找到刚好能满足内存大小的链表。比如想申请12个内存大小，就按照16来处理，也就是找1号链表。想申请20，距离最近的就是24，则找2号链表。 在GC 4.9及其以后也还有alloc函数，只不过变成了_pool_alloc这个名字了，名字改了，也不再是默认的了 需要自己手动指定也可以他自己指定，比如： 这样来使用它，相当于兜兜转转回到了以前的malloc和free的包装形式了。4、C++的管理内存？在C++中，内存分为5个区，分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由应用程序【程序员】去控制一般一个new就要对应一个delete。如果程序员没有手动释放，那么程序结束后，操作系统会自动回收。 全局&#x2F;静态存储区，内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。 它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。 代码区，存放程序的二进制代码。 5、C++中类的数据成员和成员函数内存分布情况C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。 类分为成员变量和成员函数，先讨论成员变量： 一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的时候这些成员变量也就被定义了）例如： 从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为，所有的函数都是要存放在代码区的，不管是全局函数还是成员函数。 要是成员函数占用类的对象空间，那么每定义一次类对象，就有成员函数占用一段空间。 再来补充一下静态成员函数的存放问题：静态成员函数与一般成员函数的唯一区别：没有this指针，因此不能访问类的非静态数据成员。 因为：所有函数都存放在代码区，静态函数也不例外，所有有人一看到static这个单词就主观的认为在全局数据区是不对的。6、关于this指针知道什么？ this指针是类的指针，指向对象的首地址。 this指针只能在成员函数中使用，在全局函数、静态函数中都不能用this指针。 this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。 this指针的用处一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针）编译器会自动将对象本身的地址作为一个隐含参数传递给函数。 也就是说，即使没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 this指针的使用一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用return *this; 另外一种情况就是当形参数域成员变量名相同时用于区分，例如 this-&gt;n &#x3D; n（不能写成n&#x3D;n，普通的n是形参） 类的this指针有以下特点 this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，传入参数为当前对象地址，成员函数第一个参数为：T* const this 例如： 其中，func的原型在编译器看来应该是：int func(A* const this, int p); 由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去，如： 看起来和静态函数没区别。但区别还是有的，编译器通常会对this指针做一些优化，因此this指针的传递效率比较高例如VC通常是通过ecx（技术寄存器）传递this参数的。 7、几个this指针的易混问题 this指针是什么时候创建的？this在成员函数的开始执行前构造，在成员函数的执行结束后清除。 但是如果class或struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct来使用。 采用TYPE xx 的方式定义的话，在栈里分配内存，此时this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。 之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面。 this指针存放在何处？堆、栈、全局变量，还是其他？this指针会因为编译器不同而有不同的放置位置。可能是栈，可能是寄存器，甚至全局变量。 在汇编级别里，一个值只会以三种形式出现：立即数、寄存器值和内存变量值。不是放在寄存器内就是放在内存中，它们并不是和高级语言变量对应的。 this指针是如何传递类中参数的？绑定？还是函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？大多数编译器通过ecx（寄数寄存器）传递this指针。事实上，这是一个潜规则，一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。 在 call 之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参数来传递的【隐含参数】。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，没有为函数分配空间。自从类的函数定义完成后，它就在那，不会移动。 this指针是如何访问类中的变量的？如果不是类，而是结构体，那么如何通过结构指针来访问结构中的变量？ 在C++中，类和结构体只有一个区别：类的成员默认是private，结构体是public this是类的指针，如果换成结构体，那this就是结构的指针了。 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？this指针只有在成员函数中才有定义。因此，获得一个对象后，也不能通过对象使用this指针。所以，无法知道一个对象的this指针的位置（只有在成员函数中才有this指针的位置） 当然，在成员函数里，可以知道this指针位置（可以通过&amp;this）获得，也可以直接使用。 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？普通的类函数（不论是成员函数还是静态函数）都不会创建一个函数表来保存指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译器就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是直接调用函数。 正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同函数可以互不干扰。8、内存泄漏的后果？如何监测？解决方法？ 内存泄漏内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用内存的情况。内存情况并非内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制。 后果只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种情况： 性能下降到内存逐渐用完，导致另一个程序失败。 如何排除使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误； 调试运行DEBUG版程序，运用以下技术： CRT（C run-time libraries）、 运行时函数调用堆栈、 内存泄漏时提示的内存分配序号（集成开发环境OUTPUT窗口），综合分析内存泄漏的原因，排除内存泄漏 解决办法智能指针 检查、定位内存泄漏检查方法： 在main函数最后一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出： 输出这样的格式：{453} normal block at 0x02432CA8, 868 bytes long 被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。 定位代码位置： 在main函数第一行加上_CrtSetBreakAlloc(453); 就是在申请453这块内存位置中断。 然后调试程序，程序中断了，查看调用堆栈。 加上头文件#include &lt; crtdbg.h&gt; 9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？在类的对象空间中，只有数据成员和虚函数指针表，并不包含代码内容，类的成员函数单独放在代码段中。 在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象正在调用它。当delete this时，类对象的内存空间被释放。 在delete this之后的其他任何函数调用，只要不涉及this指针的内容，都能正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。 10、为什么是不可预期的问题？delete this之后释放了类对象的内存空间，那么这段内存应该已经归还给系统，不再属于这个进程。照这个逻辑来看，应该是发生了指针错误，无访问权限之类的令系统崩溃的问题才对？ 这个问题牵扯到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时没被系统收回。此时这段内存是可以访问的，可以进行算术运算，但是其中值无法确定。 当获取数据成员，可能得到的是一串很长的未初始化的随机数；当访问虚函数表，其中指针无效可能性非常高，造成系统崩溃。 11、如果在类的析构函数中调用delete this，会发生什么？会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后释放内存” 显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。12、空类的大小？ C++空类大小不为0，不同编译器设置不一样，vs设置为1； C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定。 C++中要求对于类的每个实例都必须有独一无二的地址，那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。 13、以下几种情况下，几个类的大小？ 空类大小为1，在C++中空类会占一个字节，这是为了让对象的实例能相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓空白基类最优化。 空类的实例大小就是类的大小，所以sizeof(a) &#x3D; 1字节，如果a是指针，则sizeof(a)就是指针的大小，即4字节。 因为有虚函数的类对象中都有一个虚函数表指针__vptr，其大小是4字节 静态成员存放在静态存储区，不占用类的大小，普通函数也不占用类的大小。 静态成员a不占用类的大小，所以类的大小就是b变量的大小，即4字节 14、this指针调用成员变量时，堆栈会发生什么变化？当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址作为隐含参数传递给地址，这个隐含参数就是this指针 即使并没有写this指针，编译器在连接时也会加上this，对各个成员的访问都是通过this的。 例如建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时可以通过查看this指针来查看具体是哪个对象在调用。this指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。 15、类对象的大小受哪些因素影响？ 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小。 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的。 虚函数的话，会在类对象插入vptr指针，加上指针大小 当该类是某类的派生类，那么派生类继承的基类数据成员部分也会存在在派生类的空间中，也会对派生类进行扩展。 "},{"title":"STL","date":"2022-03-24T11:28:35.000Z","url":"/2022/03/24/STL/","categories":[["undefined",""]],"content":"STL1、什么是STL？ C++ STL广义上分为三类：算法、容器、迭代器。 算法包括：排序，复制等常用算法，以及不同容器特定的算法。 容器即：数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list、vector等关联式容器就是set、map等 迭代器即：在不暴露容器内部的情况下对容器的遍历 2、解释一下trivial destructor“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的这种析构函数在《STL源码解析》中称为“无关痛痒”的析构函数。 反之，用户自定义了析构函数，则称之为”non-trivial destructor”，这种析构函数如果申请了新的空间一定要显式地释放，否则会造成内存泄漏 对于trivial destrutcor，如果每次都进行调用，显然对效率是一种伤害，如何判断？ 《STL源码解析》中给出的说明： 首先利用value_type()获取所指对象的类型，再利用__type_traits判断该类型的析构函数是否是trivial，若是(__true_type)，则什么也不做，若为(__false_type)，则去调用destroy()函数 也就是说，在实际的应用中，STL库提供了相关的判断方法__type_traits。除了trivial destructor，还有trivial construct、trivial copy construct等如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效地完成相关操作，提升效率。 3、使用智能指针管理内存资源，RAII是怎么回事？ RAII 的全称是”Resource Acquisition is Initialization”，即“资源获取即初始化”也就是说在构造函数中申请分配资源，在析构函数中释放资源。 因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。 智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏 毫不夸张地说，有了智能指针，代码中几乎不需要再出现delete了。 4、迭代器：++it、it++哪个好？为什么？ 前置返回一个引用，后置返回一个对象 迭代器 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低。【前置返回的是当前对象的引用，后置返回的是对象】 5、C++的左值引用和右值引用C++11正式通过引入右值引用来优化性能 具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价地转移到另外一个对象中去。通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的，有名字的就是左值反之，不可以取地址的，没有名字的就是右值（纯右值或将亡值）。 int a &#x3D; b + c;其中：a就是左值，有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，&amp;(b+c)这样的操作也不会通过编译。 C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue, Pure Rvalue）和将亡值（xvalue, eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值。将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用） 比如返回右值引用T&amp;&amp; 的函数返回值、std::move的返回值，或者转换为T&amp;&amp; 的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不在被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命周期。 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型。事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。 而其原因可以理解为是引用类型本身自己并不拥有对所绑定变量的内存，只是该对象的别名. 左值引用是具名变量值的别名，右值引用则是不具名（匿名）变量的别名。 左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。 常量左值引用可以接受非常量左值、常量左值、右值对其进行初始化。 不过常量左值所引用的右值在“余生”中只能是只读的。相对的，非常量左值接受非常量左值对齐进行初始化。 右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要使用std::move()将左值强制转换为右值。 左值和右值 左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。 但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值。 右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。 无法获取地址，但不表示其不可改变，当定义了右值的右值引用时，就可以改变右值。 左值引用和右值引用 左值引用：传统的C++中引用被称为左值引用 右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置。 右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用可以获取地址，该地址表示临时对象的存储位置。 右值引用特点： 特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量就会一直存活。 特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。 特点3：T&amp;&amp; t在发生自动类型判断的时候，它是左值还是右值取决于它的初始化。 举个例子： 右值引用例子 6、STL中hashtable的实现？STL中的hashtable使用的是拉链法解决hash冲突问题，如下图所示。 hashtable中的bucket所维护的list既不适list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list,而bucket聚合体本身使用vector进行存储。hashtable的迭代器值提供前进操作，不提供后退操作。 在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193, …, 429496729]在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度） 其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在hashtable位置。 7、简述traits技法traits技法利用“内嵌类型”的编程技巧和编译器的template参数推导功能增强C++未能提供的关于类型认证方面的能力。 常用的有iterator_traits和type_traits iterator_traits被称为特性萃取机，能够方便的让外界获取一下5中类型： value_type：迭代器所指对象的类型 difference_type：两个迭代器之间的距离 pointer：迭代器所指向的类型 reference：迭代器所引用的类型 iterator_category：此处不解释 type_traits关注的是类型的特性例如这个类型是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符）和non-trivial dtop（析构函数）如果答案是否定的，可以采取直接操作内存的方式提高效率，一般来说，type_traits支持一下5种类型的判断： 由于编译器只很对class object形式的参数进行参数推导，因此上式返回的结果不应该是一个bool值，而是一个空的结构体： 这两个结构体没有任何成员，不会带来其他的负担，又能满足要求，可谓一举两得。 当然，如果我们自行定义了一个Shape类型，也可以针对这个Shape设计type_traits的特化版本 8、STL的两级空间配置器 首先明白为什么需要二级空间配置器？我们知道动态开辟内存时候，要在堆上申请，但如果我们需要频繁的在堆开辟释放内存，就会在堆上造成很多外部碎片，浪费了内存空间； 每次都要进行malloc、free函数等操作，使空间就会增加一些附加信息，降低了空间利用率。 随着外部碎片增多，内存分配器在找不到合适内存情况下就需要合并空间块，浪费了时间，大大降低了效率。 于是就设置了二级空间配置器，当开辟内存&lt;&#x3D; 128Bytes时，即视为开辟小块内存，则调用二级空间配置器。 关于STL中一级空间配置器和二级空间配置器的选择上，一般默认选择为二级空间配置器。如果大于128字节再转去一级配置器。 一级配置器一级空间配置器中重要的函数就是allocate、deallocate、reallocate。一级空间配置器是以malloc(), free(), realloc()等C函数执行实际的内存配置。大致过程是： 直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数。 如果用户自定义了内存分配分配的处理函数就调用，没有就返回异常。 如果自定义了处理函数就进行处理，完事再继续分配试试。 二级配置器 维护16条链表，分别是0-15号链表，最小8字节，以8字节主键递增，最大128字节。传入一个字节参数，表示需要多大的内存，会自动校对到第几号链表（如需要13Bytes空间，则分配16Bytes大小）在找到第n个链表后查看链表是否为空，如果非空则直接从对应的free_list拔出，将已经拨出的指针向后移动一位。 对应free_list为空，先看其内存池是不是为空，如果内存池不为空 先检验它剩余空间是否够20个节点大小（及所需内存大小（提升后）*20），若足够则直接从内存池中拿出20个节点大小空间将其中一个分配给用户使用，另外19个当做自由链表中的区块挂在相应的free_list下，下次再有相同大小内存需求时，可以直接拔出 如果剩余空间不够20个节点大小，则看它是否能满足1个节点大小，如果够则直接拿出一个分配给用户然后从剩余空间中分配尽可能多的节点挂在相应的free_list中。 如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list）然后再给内存池申请内存，转到3 内存池为空，申请内存，此时二级空间配置器会使用malloc()从heap上申请内存（一次所申请的内存大小为 2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。 malloc没有成功，在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了此时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔出一个节点使用。如果这也没有找到，说明free_list中都没有自由区块，那就要调用一级适配器。 释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间适配器，否则就直接将内存块挂上自由链表的合适位置。 STL二级空间配置器虽然解决了外部碎片与提高了效率，但同时增加了一些缺点： 因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，此时若需要1个字节，会给8个字节，即浪费7个字节。所以有引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片。 二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用在程序执行过程中，它将申请的内存一块一块挂载到自由链表上，即不会还给操作系统。并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统。因此带来的问题有： 不断开辟小块内存，最后整个堆上的空间都被挂到自由链表上，若想开辟大块空间就会失败 若自由链表上挂着很多内存块没有被使用，当前进程占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，引发问题。 一级分配器GC4.9 之后就没有第一级了，只有第二级 二级分配器—— default_alloc_template 剖析有个自动调整的函数：传入一个字节参数，表示需要多大的内存，会自动帮你校对到第几号链表（0-15号，最小8B，最大128B） allocate函数：如果要分配的内存大于128B，就转用第一级分配器，否则也就是小于128B。首先判断在第几号链表，定位到了，先判断链表是否为空，若空需要充值（调节到8的倍数，默认一次申请20个区块，只用其中一个）去内存值去拿或重新分配。 9、vector与list的区别和应用？如何找某vector或者list的倒数第二个元素 vector数据结构： vector 和数组类似，拥有一段连续的内存空间，并且起始地址不变。 因此能高效的进行随机存取，时间复杂度为O(1) 但因为内存空间连续，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为O(n) 另外，当数组内存空间不够时，会重新申请一块内存空间并进行内存拷贝。 连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易。 与数组最大的区别就是vector不需要程序员自己考虑容量问题，库里面本身已经实现了容量的动态增长，数组需要程序员手动写入扩容函数进行扩容。 list数据结构： list是由双向链表实现的，因此内存空间是不连续的。 只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为O(n) 但由于链表的特点，能高效地进行插入和删除。 非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。 每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。 因此list可以高效率地对数据元素任意位置进行访问和插入删除等操作。 由于涉及对额外指针的维护，所以开销比较大。 区别： vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。 list的访问需要遍历整个链表，它的随机访问效率低，但对数据的插入和删除操作都很方便，改变指针指向即可。 从遍历上来说，list是单向的，vector是双向的 vector中的迭代器在使用之后就失效了，但list的迭代器使用之后还可以继续使用。 int mySize &#x3D; vec.size();vec.at(mySize - 2); list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历不过需要访问list的最后几个元素时，可以用反向迭代器来操作。 10、STL中vector删除其中元素，迭代器如何变化？为什么是两倍扩容？释放空间？size()函数返回的是已用空间大小，capacity()返回的是总空间大小因此：capacity() - size()则是剩余可用空间大小。当size() &#x3D;&#x3D; capacity()，说明vector目前的空间已经被用完，如果再添加新元素，会引起vector空间动态增长。 由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的。 这样便提升了效率，当且仅当n &gt; capacity()时，调用reserve(n)才会改变vector容量。 resize()成员函数改变元素的数目，至于空间的变化要看具体情况去分析，例如： 空的vector对象，size()和capacity()都为0 当空间大小不足时，新分配的空间大小为原空间大小的2倍。 使用reserve()预先分配一块内存后，在空间未满情况下，不会引起重新分配，从而提升了效率 当reserve()分配的空间比原空间小的时候，是不会引起重新分配的。 resize()函数值改变容器的元素数目，不改变元素容器大小。 用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用”[]”来访问，则可能越界而resize(size_type new_size)会真正使容器具有new_size个对象。 不同编译器，vector有不同扩容大小，vs下1.5倍，GCC下2倍。 空间和时间的权衡。简单来说，空间分配的多，平摊时间复杂度低，但浪费空间也多。 使用k &#x3D; 2增长因子的问题在于，每次扩展的新尺寸必须刚好大于之前分配的总和，即：之前分配的内存空间不可能被使用。这样对内存不友好，因此最好将增长因子k设置为1-2之间。 对比可以发现采用成倍方式扩容，可以保证常数时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此采用成倍方式扩容。11、Vector如何释放空间？由于vector的内存占用空间只增不减，比如首先分配了10000B，然后erase掉后面9999B，只留下1B，但内存占用仍然为10000B。 所有内存空间实在vector析构时候才能被系统回收。empty()用来检测容器是否为空，clear()可以清空所有元素。但是即使是clear()，vector所占用的内存空间仍然如故，无法保证内存的回收。 如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来释放内存。 12、容器内部删除一个元素 顺序容器（序列式容器，比如vector、deque）erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效（list除外）所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器。 it &#x3D; c.earse(it); 关联容器（关联式容器，比如map&#x2F;set&#x2F;multimap&#x2F;multiset等）erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；c.earse(it++); 13、STL迭代器如何实现 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历。其中最重要的是”*”运算符和”-&gt;”运算符，以及”++”、”–”等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。 最常用的迭代器相应类型有物种：value type、difference type、pointer、reference、iterator catagory； 14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？为什么使用红黑树？ 他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn)时间内完成，因此可以完成高效插入删除； 在这里定义一个模板参数，如果它是key则它是set，如果它是map，则它是map；底层是红黑树，实现map的红黑树结点数据类型是key+value，实现set的节点数据类型是value； 因为map和set要求自动排序，红黑树能实现这一功能，而且时间复杂度比较低。 15、如何在共享内存上使用STL标准库？ 想象一下把STL容器，例如map, vector, list等等，放入共享内存中IPC（进程间通讯）一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了许多。 没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下他们有自己的内存管理方案。 当一个元素被插入到一个STL列表（list）中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器缺自己在堆上进行分配。 一个最笨拙的方法就是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本不可能完成。 假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器？一个方法就是进程A把容器放在共享内存的确定地址上（fixed offsets）则进程B可以从该已知地址上获取容器。另外一个改进办法就是，进程A现在共享没存某块确定地址上防止一个map容器，然后进程A再创建其他容器，然后取名字和地址放到map容器内。 进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器地址。 16、map插入方式有几种？ insert函数插入pair数据 用insert函数插入value_type数据 在insert函数中使用make_pair()函数 用数组方式插入数据 17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容 unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序 存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的而map中的元素是按照BST进行存储，进行中序遍历就可以得到有序遍历。 所以使用时候map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator&#x3D;&#x3D;。但是很多系统内置的数据类型都自带这些。 如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。 如果需要内部元素自动排序，使用map，不需要排序则使用unordered_map unordered_map的底层实现是hash_table hash_map底层使用的是hash_table，而hash_table使用的拉链法进行冲突避免，所有hash_map使用拉链法进行冲突解决。 什么时候扩容：当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于某个阈值——即当前数组长度乘以加载因子值时，就要自动扩容。 扩容（resize）就是重新计算容量，向HashMap对象里不停地添加元素，而HashMap对象内部的数组无法装载更多的元素时对象就需要扩大数组的长度，以便能装入更多的元素。 18、vector越界访问下标，map越界访问下标？vector删除元素时候会不会释放空间？ 通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE实现方式不一样，确保不可越界访问地址。 map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；若不存在这个key，就将一个具有该key和value的key-value插入map erase()函数，只能删除内存，不能改变容量大小；erase成员函数，它删除了itVect迭代器指向的元素，并且要返回被删除的itVect之后的迭代器，迭代器相当于一个智能指针； clear()函数，只能清空内容，不能改变容量大小，如果想要在删除内容的同时释放内存，可以选择deque容器。【deque相当于一个分块数组】 19、map中[]和find的区别？ map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入该map【找不到就插入】 map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，则返回尾迭代器【end()】 20、STL中list与queue之间的区别 list不再能够像vector一样以普通指针作为迭代器，因为其结点不保证在存储空间中连续存在；【本质使用双向链表实现】 list插入操作和删除操作都不会造成原有的list迭代器失效 list不仅是一个双向链表，而且是一个环状双向链表，所以只需要一个指针 list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效； deque是一种双向开口的连续线性工作，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；可以在头尾两端分别做元素的插入和删除操作； deque和vector最大的差异一在于deque允许常数时间内对起头部进行元素的插入和移除操作二在于deque没有所谓容量概念，因为它是动态地分段连续空间组合而成【分块数组】 随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。 21、STL中的allocator、deallocator 第一级配置器直接使用malloc()、free()和relloc()第二级配置器视情况采用不同的策略：当配置区块超过128B时，视之为足够大，便调用第一级配置器； 当配置器区块小于128B时，为了降低额外负担，使用复杂的内存池整理方式，而不再使用以及配置器 第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128B的小额区块。 空间配置函数allocate()，首先判断区块大小，大于128B就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间； 空间释放函数deallocate()，该函数首先判断区块大小，大于128B时，直接调用一级配置器，小于128B时就找到对应的free-list然后释放内存。 22、STL中hash_map扩容发生什么？ hash_table表格内的元素称为桶（bucket），而由桶所链接的元素称为结点（node）其中存入桶元素的容器为STL本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。 向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作。如果目前正巧是list的尾端，就跳到下一个bucket身上，即下一个list的头部结点。 23、常见容器性质总结？ vector 底层数据结构为数组，支持快速随机访问。 list 底层数据结构为双向链表，支持快速增删 deque底层数据结构为一个中央控制器和多个缓冲区，详见《STL源码剖析》P146，支持首位（中间不行）快速增删，也支持随机访问。deque是一个双端队列（double-ended queue），也是在堆中保存内容的，其保存形式如下： [堆1 ]-&gt;[堆2 ]-&gt;[堆3 ]-&gt;…每个堆保存好几个元素，然后堆和堆之间有指针指向，看起来像是list和vector的结合体 stack底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时 queue底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器，不叫容器，因为是对容器的再封装） priority_queue的底层数据结构一般是：vector为底层容器，堆heap为处理规则来管理底层容器实现 set 底层数据结构为红黑树，有序，不重复。 multiset底层数据结构为红黑树，有序，不重复。 map 底层数据结构为红黑树，有序，不重复。 multimap底层数据结构为红黑树，有序，可重复。 unordered_set底层数据结构为hash表，无序，不重复 unordered_multiset底层数据结构为hash表，无序，不重复 unordered_map底层数据结构为hash表，无序，不重复 unordered_multimap底层数据结构为hahs表，无序，不重复 24、vector的增加删除都是怎么做的？为什么是1.5或者2倍？ 新增元素：vector通过一个连续的数组，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来数据复制过来，释放之前元素，插入新增元素。 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器都失效了 初始时刻vector的capacity为0，塞入一个元素之后capacity增加为1； 不同编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容 对比可以发现采用成倍方式扩容，可以保证常数时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此使用成倍方式扩容。 考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2倍方式、以1.5倍方式。 以2倍方式扩容，导致下次申请的内存必然大于之前分配内存额总和，导致之前分配的内存不能再被使用，所以最好倍增因子设置为(1, 2)之间 向量容器vector的成员函数pop_back()可以删除最后一个元素 而函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。 还可以采用通用算法remove()来删除vector容器中的元素 不同的是：采用remove一般情况下不会改变容器的大小，pop_back()和erase()等成员函数会改变容器的大小。 25、STL每种容器对应的迭代器 容器 迭代器 vector、deque 随机访问迭代器 stack、queue、priority_queue 无 list、(multi)set&#x2F;map 双向迭代器 unordered_(multi)set&#x2F;map、forward_list 前向迭代器 26、STL中迭代器失效的情况有哪些？以vector为例： 插入元素： 尾后插入：size &lt; capacity 时，首迭代器不失效、尾迭代器失效（未重新分配空间）size &#x3D;&#x3D; capacity 时，所有迭代器均失效。需要重新分配空间 中间插入：size &lt; capacity 时，首迭代器不失效、但插入元素后面的所有迭代器失效size &#x3D;&#x3D; capacity 时，所有迭代器均失效。 删除元素： 尾后删除：只有尾迭代器失效。 中间删除：删除位置之后所有迭代器失效。 deque和vector情况类似【随机访问迭代器】 list 双向链表，每一个节点内存不连续，删除节点仅当前迭代器失效，erase返回下一个有效迭代器 map&#x2F;set等关联容器底层是红黑树，删除节点不会影响其他结点的迭代器，使用递增方法获取下一个迭代器：mmp.erase(it++) unordered(hash) 迭代器意义不大，rehash之后，迭代器也是全部失效 27、STL中vector的实现vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一区别在于对空间运用的灵活性【动态空间】 众所周知，array占用的是静态空间，一旦配置了就不可改变大小，如果遇到空间不足的情况还要自行创建更大空间，并手动拷贝数据，再将原空间释放。 vector则使用灵活的动态空间配置，维护一块连续的线性空间，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。 其在扩充空间的过程仍然需要经历：重新配置空间，移动数据，释放原空间等操作。 动态扩容规则：以原大小的两倍配置另外一块较大的空间（或者旧长度 + 新增元素个数），源码： vector扩容倍数与平台有关，在Win + VS下是1.5倍，Linux + GCC下是2倍。 测试代码： 运行上述代码，一开始配置了一块长度为2的空间，接下来插入一个数据，长度变为原来的两倍，为4，此时占用长度为3，再插入两个数据，此时长度为8。可以清晰看到空间变化过程。 需要注意：频繁地对vector调用push_back()对性能有影响因为每插入一个元素，如果空间够用还能直接插入，若不够则要重新配置空间，移动数据，释放原空间等操作，对程序性能有一定影响 28、STL中slist的实现list是双向链表，而slist(single linked list)是单向链表，它们的主要区别在于：list的迭代器是双向的Bidirectional iteratorslist的迭代器属于单向的Forward iterator。虽然slist的很多功能不如list灵活，但是其消耗的空间更小，操作更快。 根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或移除元素十分不明智，但在slist开头却可取slist特别提供了insert_after()和erase_after()供灵活应用。 考虑到效率问题，slist只提供push_front()操作，元素插入到slist之后，存储的次序和输入的次序相反。 slist单向迭代器如下所示 slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下： 举个例子： 由于slist是单向链表，因此向后插入比向前插入更加方便，所以有insert_after, erase_after使用当然也有push_front()可供快速插入。 需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++11中出现，与slist的区别在于没有size()方法。29、STL中list的实现相比于vector的连续线性空间，list显得复杂许多但是好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用十分精准，对任何位置元素的插入和删除都是常数时间。 list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的”++”、”–”操作对于的是指针的操作，list提供的迭代器是双向迭代器：Bidirectional iterators。 list节点的结构见如下源码： 从源码中可看出list显然是一个双向链表。list和vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。 此外list也是一个环形链表，因此只需要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白结点，因此是一种”前闭后开”的区间结构。 list的空间管理默认采用alloc作为空间配置器，为了方便地以结点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个结点空间。 由于list的双向特性，其支持在头部（front）和尾部（back）两个方向进行push和pop操作当然还支持erase, splice, sort, merge, reverse, sort等操作。 30、STL中deque的实现vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间虽然vector也可以在头尾进行元素操作，但是头部操作的效率十分低下（主要涉及整体移动） deque和vector的最大差异：一是deque运行在常数时间内对头部进行元素操作二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来 deque虽然也提供随机访问的迭代器，但其迭代器不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性。 deque的数据结构如下： deque内部有一个指针指向map，map是一小块连续空间其中每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大连续空间，称为缓冲区缓冲区就是deque实际存放数据的区域，默认大小为512B。整体结构如上。 deque的迭代器数据结构如下： 从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素 deque迭代器的”++”、”–”操作远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，此时会配置新的map（两倍于当前+2的数量）来容纳更多node，也即更多缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。 31、STL中stack和queue的实现。 stackstack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下： stack这种单向开口的数据结构很容易由双向开口的deque和list形成，只需要根据stack的性质对应移除某些接口即可实现，stack源码如下： 从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而Sequenc默认是deque数据结构。stack这种“修改某种接口，形成另一种风貌”的行为，称为adapter（适配器）。经常将其归类为container adapter而非container stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。【相当于修改默认参数】由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。 queuequeue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口分别位于最底段和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下： 类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，queue的源码如下： 从queue的数据结构可以看出，其所有操作都也都是围绕Sequence完成，Sequence默认也是deque数据结构。queue也是一类container adapter。 同样，queue也可以使用list作为底层容器，不具有遍历功能，因此没有迭代器。32、STL中heap的实现heap（堆）并不是STL的容器组件，是priority_queue（优先队列）的底层实现机制因为binary max head（大根堆）总是最大值位于堆的根部，优先级最高。 binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶结点之外，都是填满的但是叶结点从左到右不会出现空隙，如下图即一个完全二叉树： 完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个结点位于index处，其左节点必定位于index*2处，右节点位于 index *2+1处，父节点位于 i&#x2F;2（向下取整）处。 这种以数组表示tree的方式称为隐式表述法。 因此我们可以使用一个array和一组heap算法来实现max heap（每个结点的值大于等于其子结点的值）和min heap（每个结点的值小于等于其子节点的值） 由于array不能动态改变空间大小，用vector代替array是不错的选择。 heap算法有哪些？常见插入、弹出、排序、构造算法，下述： push_heap算法由于CBT的性质，新插入的元素一定是位于树的最底层作为叶子结点，并填补由左至右第一个空格。事实上，在刚执行插入操作时，新元素位于底层vector的end()处，之后是一个称为percolate up（上溯）的过程，举例如下： 新元素50在插入对中后，先放在vector的end()存着，然后执行上溯过程，调整其根节点的位置，以便满足max_heap的性质这个过程跟大根堆调整过程一样。 pop_heap算法heap的pop操作实际弹出的是根节点，但在heap内部执行pop_head时，只是将其移动到vector的最后位置然后再为这个被挤掉的元素找到一个合适的安放位置，使整棵树满足CBT的条件。 这个被挤掉的元素首先会和根节点的两个子节点比较，并与较大的子节点更换位置，如此一直往下，直到其大于左右两个子节点或者下放到叶结点为止。这个过程称为percolate down（下溯）。举例如下： 根节点68被pop之后，移到了vector的最底部，将原本在该位置的24挤出。24被迫从根节点开始与其子节点进行比较，直到找到合适的位置安身，需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用pop_back()。 sort算法因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap的范围减1，不断执行pop_heap直到树为空，即可以得到一个递增序列。 make_heap算法将一段数据转化为heap，一个一个数据插入，调用上面说的两种percolate算法即可。代码实测： 33、STL中的priority_queue的实现priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示： 默认情况下，priority_queue使用一个max_heap实现，底层容器使用的一般是vector堆heap为处理规则来管理底层容器实现【vector用heap算法】。priority_queue这种实现机制导致其不被归为容器，而是一种容器适配器，关键源码如下： priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，没有遍历功能，也不提供迭代器 举例： 34、STL中set的实现？STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。 set的特性是，所有元素都会根据元素的值自动排序（默认升序）set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值 set不允许迭代器修改元素的值，其迭代器是一种 constance iterators 标准的STL set一RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是调用RB-tree的操作行为，因此补充红黑树特性： 每个结点不是红色就是黑色 根节点、叶子结点为黑色 如果结点为红色，则其子节点必为黑色 任一结点到（NULL）结点即树的尾端的任何路径，所包含的黑结点数量必然相同具体翻阅《算法导论》 举例： 关联式容器尽量使用自身提供的find函数查找指定的元素，效率更高【红黑树符合BST特征】因为STL提供的find()函数是一种顺序搜索算法。 35、STL中map的实现map的特性是所有元素会根据键值进行自动排序。map中所有元素都是pair，拥有键值（key）和实值（value）两个部分，并且不允许元素有相同的key 一旦map的key确定了，则无法更改，但是可以修改该key对应的value因此 map迭代器既不是 constant iterator，也不是mutable iterator 标准STL map的底层机制是RB-tree（红黑树），另一种以 hash_table 为底层机制实现的称为 hash_map。map的架构如下图所示： map在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_equal()（multiple使用） 距离如下： 需要注意的是subscript（下标操作）既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）例如： 无论如何，subscript操作符都会先根据键值找出实值，源码如下： 代码运行过程是：首先根据键值和实值做出一个元素，该元素实值未知，因此产生一个实值类型相同的临时对象替代： 再将这个对象插入到map中，并返回一个pair： pair第一个元素是迭代器，指向当前插入的新元素如果插入成功返回true，此时对应左值运用，根据键值插入实值。如果插入失败（重复插入）返回false，此时返回的是已经存在的元素，则可以取到它的实值。 由于该实值是以引用方式传递，因此作为左值或右值都可以。36、set和map的区别，multimap和multiset的区别set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上。而且它的compare_function用的是identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value实际上一样。其实保存的是两份元素，而非一份元素。 map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的compare_function()，保存的确实是两份元素 他们两个的insert都是采用红黑树的insert_unique()，即独一无二的插入。 multimap和map的唯一区别在于：multimap调用的是红黑树的insert_equal()，可以重复插入map调用的是红黑树的insert_unique()，即独一无二的插入 multiset和set也一样，底层实现都是一样的，但插入的时候调用的方法不一样。37、红黑树概念面试时手写红黑树几乎不可能，但红黑树基本概念还是要掌握。 是二叉排序树（继承BST的特点）： 若左子树不为空，则左子树上所有结点的值小于等于根节点的值 若右子树不为空，则右子树上所有结点的值大于（等于）根节点的值。 左、右子树也是二叉排序树。 红黑树满足以下几个要求： 树中结点只有红色和黑色。 根节点和叶子结点（NULL）均为黑色结点。 红色节点的叶子结点必须为黑色结点（黑色结点子节点可以为黑色） 从根到NULL的任何路径上黑色结点数目相同。 查找时间一定可以控制在O(logn) 38、STL中unordered_map和map的区别和应用场景map支持键的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为O(logn)，但是空间占用比较大，因为每个节点要保持父节点，孩子节点以及颜色信息。 unordered_map是C++11新添加的容器，底层机制是哈希表，通过哈希函数计算元素位置，其查询时间复杂度为O(1)维护时间与Bucket桶所维护的list长度有关，但是建立hash表耗时较大。 从两者的底层机制和特点可以看出：map适用于有序数据的应用场景unordered_map适用于高效查询的应用场景。 hash_table中解决冲突有哪些办法？前三个： 线性探测法：使用hash函数计算出的位置如果已经有元素占用了，则依次（线性）向后寻找，找到表尾则返回表头，知道找到一个空位 拉链法：每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存储在list中 再散列：发生冲突时使用另一种hash函数再计算一个地址，直到不冲突 二次探测使用hash函数计算出的位置如果已经有元素占用了，按照1^2,2^2,3^2的步长依次查找如果步长是随机数序列，则称之为伪随机探测。 公共溢出区一旦hash函数计算的结果相同，就放入公共溢出区 "},{"title":"cpp","date":"2022-03-02T12:40:57.000Z","url":"/2022/03/02/cpp/","categories":[["undefined",""]],"content":"一、基础语法1、在main执行之前和之后执行的代码可能是什么？ main函数执行之前，主要就是初始化系统相关资源： 设置栈指针 初始化静态static变量和global全局变量，即.data段的内容 将未初始化部分的全局变量赋初值：数值型short,int,long赋为0，bool为false，pointer为nullptr，即.bss段内容 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码 将main函数的参数argc,argv等传递给main函数，然后运行main函数 attribute((constructor)) main函数执行之后 全局对象的析构函数会在main函数之后执行 可以用atexit注册一个函数，它会在main之后执行 attribute((destructor)) 2、结构体内存对齐问题 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。【首地址】 未特殊说明时，按照结构体中size最大的成员对齐。（若有double，则8字节对齐） c++11以后引入两个关键字alignof和alignas，其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式但是alignas在某些情况下是不能使用的 alignas能使用的例子 alignas将内存对齐调整为4字节∴sizeof(Info2)的值变为了8 alignas不能使用的例子 若alignas小于自然对齐的最小单位，则会被忽略 单字节对齐方式 用上述方式来看，使用单字节对齐方式，使用alignas是无效的，应该使用#pragma pack(push, 1)或者__attribute__((packed)) 确定结构体每个元素大小【`alignas`处理不了的情况】 3、指针和引用的区别 指针是一个变量，存储的是一个地址，引用跟原来的变量本质上是同一个东西，是原变量的别名。 sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用可以。 指针可以有多级，引用只能有一级 指针可以为空，引用不能为NULL并且在定义时必须初始化 指针在初始化后可以改变指向，而引用在初始化之后不可再改变 （变量可以被引用为多次，但引用只能作为一个变量引用） 指针是具体变量，需要占用存储空间；引用本质是一个指针，同样会占4字节内存； 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等到用到时再指向具体变量。 测试指针和引用1 测试指针和引用2 在编译器看来，int a &#x3D; 10; int &amp;b &#x3D; a; 等价于：int * const b &#x3D; &amp;a; 而 b &#x3D; 20; 等价于 *b &#x3D; 20;自动转换为指针和自动解引用。 4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用？ 需要返回函数内部局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针。否则会内存泄漏，然而返回局部变量的引用是没有意义的。 对栈空间大小比较敏感（比如递归）的时候使用引用，使用引用传递不需要创建临时变量，开销要更小。 类对象作为参数传递时使用引用，这是C++类对象传递的标准方式。 5、堆和栈的区别 申请方式不同： 栈由系统自动分配 堆是程序员进行申请和释放的 申请大小限制不同： 栈顶和栈底是预先设计好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整 申请效率不同。 栈由系统分配，速度快，不会有碎片。 堆由程序员分配，速度慢，且会有碎片。 空间大小不同： 栈空间默认是4M 堆区一般是1-4G 堆 栈 管理方式 堆中资源由程序员控制，容易mem. leak 栈资源由编译器自动管理，无需手工控制 内存管理机制 系统有一个记录空间内存地址的链表，当系统收到程序申请时，遍历链表，寻找第一个空间大于申请空间的堆结点【首次适应算法】，删除空闲结点链表中的该节点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余部分重新放入空闲链表中） 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（链表和队列、不连续和连续空间区别） 空间大小 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit系统理论上是4G），所以堆的空间比较灵活，比较大 栈是一块连续的内存区域，大小是操作系统预定好的，Windows下栈大小是2M（也有1M，在编译时确定，VC中可设置） 碎片空间 对于堆，频繁的new&#x2F;delete会造成大量碎片，使程序效率降低 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进入一一对应，不会产生碎片。【栈和队列的区别】 生长方向 堆向上，向高地址方向增长。 栈向下，向低地址方向增长。 分配方式 堆都是动态分配（没有静态分配的堆） 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 分配效率 堆由C&#x2F;C++函数库提供，机制很复杂，所以堆的效率比栈低很多 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。 6、栈快一点还是堆快一点 答：栈快一些操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，而且有专门的指令执行，所以栈的效率较高也比较快。堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存时需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 7、区别以下指针类型 int *p[10]表示指针数组，强调数组概念，是一个数组遍历，数组大小为10，数组内每个元素都是指向int类型的指针变量。 int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，该数组大小是10。 int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是 int * 类型的。 int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。 小总结：带括号的(*p)强调的是指针。 8、new&#x2F;delete 和 malloc&#x2F;free的异同相同点： 都可以用于内存的动态申请和释放不同点： new&#x2F;delete是 C++ 运算符，malloc&#x2F;free是C&#x2F;C++语言标准库函数 new&#x2F;delete不需要库文件支持，malloc&#x2F;free需要库文件支持 new 自动计算要分配的空间大小，malloc需要手工计算 new 是类型安全的，malloc不是。例如： new 调用名为 operator new 的标注库函数分配足够空间并调用相关对象的构造函数；delete 对指针所指对象运行适当析构函数，然后通过调用名为 operator delete 的标准库函数释放该对象所用内存。malloc&#x2F;free 没有相关调用 new 是封装了 malloc，直接free不会报错，但这只是释放内存，并不会析构对象。 9、new和delete是如何实现的 new的实现过程：首先调用名为operator new的标准库函数，分配足够大的空间为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的对象的指针； delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。 小总结：new 和 delete 顺序是反过来的：分配内存-&gt;构造函数-&gt;提供指针-&gt;析构函数-&gt;释放内存 10、malloc 和 new 的区别？ malloc&#x2F;free 是标准库函数，支持覆盖；new&#x2F;delete是运算符，不重载； malloc&#x2F;free 仅仅分配&#x2F;回收内存空间，不具备调用构造函数和析构函数的功能。用malloc分配空间存储类的对象存在风险；new&#x2F;delete 除了分配回收功能外，还会调用构造和析构函数 malloc&#x2F;free 返回的是 void 类型指针（必须进行类型转换），new&#x2F;delete返回的是具体类型指针。 11、既然有了malloc&#x2F;free，c++中为什么还需要new&#x2F;delete？ malloc&#x2F;free 和 new&#x2F;delete都是用来申请内存和回收内存的。 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能吧构造和析构函数的功能强加给malloc&#x2F;free，所以new&#x2F;delete是必不可少的。 12、被free回收的内存是立即返还给操作系统吗？不是，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样避免了频繁的系统调用，从而占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。 13、宏定义和函数有何区别？ 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值. 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。 宏定义不用在最后加分号。 14、宏定义和typedef的区别？ 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。 宏定义不检查类型；typedef会检查数据类型。【因此typedef安全】 宏不是语句，不需要在最后加分号；typedef是语句，要加分号标识结束。 注意对指针的操作，typedef char* p_char 和 #define p_char char* 差别巨大【例如同时定义多个变量】 15、变量声明和定义区别？ 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。 相同变量可以在多处声明（外部变量 extern），但只能在一处定义。 用extern声明外部变量全局变量（外部变量）是在函数的外部定义的，其作用域为从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为本文件中的各个函数所引用。编译时将全局变量分配在静态存储区。如果用extern声明全局变量，即扩展全局变量的作用域。 16、stelen和sizeof的区别？ sizeof是运算符，不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数 sizeof参数可以是任何数据的类型或数据（sizeof参数不退化）；strlen的参数只能是字符指针且末尾是’\\0’的字符串。 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。【例如获得的是指针的大小，不是数组的大小】 补充：一个指针占多少字节？上例中，sizeof(str)的值为8，是在64位编译环境下的，指针的占用大小为8字节；在32位环境下，指针占用大小为4字节。一个指针占内存的大小跟编译环境有关，而与机器位数无关。 17、常量指针和指针常量的区别？ 指针常量是一个指针，读成常量的指针pointer to const，指向一个只读变量，也就是后面所指明的 int const 和 const int，都是一个常量可以写作 int const *p 或 const int *p。【这个 * 修饰的是变量p，const修饰int】 常量指针const pointer是一个不能改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（存放在指针中的地址）就不能再改变了即不能中途改变指向，如int *const p。【这个 * 修饰的是int类型，const修饰指针】 小补充：volatile 可以允许用指针修改 const 18、a和&amp;a有什么区别？假设数组 int a[10]; int(*p)[10] &#x3D; &amp;a;其中： a是数组名，是数组首元素地址，+1表示地址加上一个int类型的大小如果a的值是0x00000001，加1操作后变为0x00000005；*(a+1) &#x3D; a[1] &amp;a是数组的指针，其类型为 int(*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数据的偏移（10个int型变量）值为数组a尾元素后一个元素的地址 若(int *)p，此时输出 *p 时，其值为a[0]的值，因为被转为 int * 类型，解引用时按照int类型大小来读取。 19、C++和Python区别包括但不限于： Python是一种脚本语言，是解释性语言；C++是编译语言，是需要编译后在特定平台运行的。Python可以很方便的跨平台，但效率没有C++搞。 Python使用缩进来区分不同代码块；C++使用花括号来区分。 C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等。 Python的库函数比C++多，调用起来更方便。 20、C++和C语言的区别 C++中new&#x2F;delete是对内存分配的运算符，取代了C中的malloc&#x2F;free（库函数） 标准C++中的字符串取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型） C++中用来做控制台输入输出的iostream库取代了标准C中的stdio函数库。 C++中的try&#x2F;catch&#x2F;throw异常处理机制取代了标准C中的setjmp()&#x2F;longjmp()函数。 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来【函数重载】在C语言中不允许。 C++语言中，允许变量定义语句在程序的任何地方，只要是在使用它之前就可以；C语言中，必须要在函数的开头部分。【C和C++都不允许重复定义变量】 C++中，除了值和指针之外，新增了引用。引用型变量相当于别名。 C++相对于C增加了一些关键字，bool&#x2F;using&#x2F;dynamic_cast&#x2F;namespace等。 21、C++与Java的区别 语言特性 Java语言给开发人员提供了更为简洁的语法；完全面对对象，由于JVM可以安装到任何操作系统上，所以说可移植性强。 Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组。同时将容易造成麻烦的指针从语言中去掉，这有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。 C++也可以在其他操作系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行）例如可能【Windows下大端存储，Unix下小端存储】Java一般生成字节码，在JVM运行得到结果 Java用接口（Interface）技术取代C++程序中的抽象类。接口与抽象类有相同的功能，但是省却了在实现和维护上的复杂性 垃圾回收 C++用析构函数回收垃圾，写C&#x2F;C++程序时一定要注意内存的申请和释放。 Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题。 应用场景 Java 在桌面程序上不如 C++ 实用，C++可以直接编译成exe文件，指针是C++的优势，可以直接对内存的操作，但同时具有危险性。（操作内存十分危险，一旦指针位置出现错误，或者误删内存单元的重要数据，后果不堪设想） Java在Web应用上具有C++无可比拟的优势，具有丰富多样的框架。 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在。 22、C++中struct和class的区别 相同点 两者都拥有成员函数、公有和私有部分 任何可以使用class完成的工作，同样可以使用struct完成 不同点 两者中如果不对成员不指定公私有，struct默认是公有的，class默认是私有的。 class默认是private继承，struct默认是public继承 C++和C的struct的区别 C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义（C++中的struct能继承，能实现多态） C++中struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容） struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct才能做结构类型名（除了typedef struct class{};）【Struct Node】C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外，结构体struct在C++中被当做类的一种特例。 23、define宏定义和const的区别 编译阶段define是在编译的预处理阶段起作用【预处理，主要做其中的文本处理】const是在编译、运行的时候起作用 安全性define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含全部内容const常量有数据类型，编译器可以对其进行类型安全检查。 内存占用 define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放出常量表。 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。 24、C++中const和static的作用 static 不考虑类的情况 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块使用。 默认初始化为0。包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区。 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用。 考虑类的情况 static成员变量：只与类管理，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标识为static；可以被非static成员函数任意访问 static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问。 const 不考虑类的情况 const 常量在定义时必须初始化，之后无法更改 const形参可以接收const和非const类型的实参，例如：void fun(const int&amp; i){}【实参可以是const也可以不是】 考虑类的情况 const成员变量：不能在类定义的外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化 const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable数据的值 补充：mutable声明的变量可以在const成员函数中被修改 25、C++的顶层const和底层const概念区分 顶层const：指的是const修饰的变量本身是一个常量，无法修改，值得是指针，就是 星号* 的右边 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 星号* 的左边例子 区分作用 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const int const a 和 const int a均表示定义常量类型a。 const int *a、int const a，其中a为指向int型变量的指针，const在左侧，表示a指向不可变常量，（const (*a) ），对引用加const int *const a，依旧是指针类型，表示a为指向整形数据的常指针。看成（const(a)，对指针const） 26、数组名和指针（这里为指向数组首元素的指针）区别？ 二者均可通过增减偏移量来访问数组中的元素 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增，自减等操作。 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作。但sizeof运算符不能再得到原数组的大小了 27、final和override关键字override当在父类中使用了虚函数的时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以： 如果不使用override，将foo()写成f00()时，编译器并不会报错，因为他不知道你想要重写虚函数。因此多了一个f00()函数。因此 —— override关键字：指定了子类的这个虚函数是重写父类的，如果名字打错编译是不会通过的。 final当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字。final关键字被继承或重写，编译器会报错。 28、拷贝初始化和直接初始化 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同： 直接初始化直接调用与实参匹配的构造函数； 拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将哪个临时对象拷贝到正在创建的对象。举例： 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（1和3等价）但两种情况要辨别，如果不考虑编译器的话，本质上是不同的。 当拷贝构造函数为 private 时：语句3和4在编译时会产生错误 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错。 补充 explicit：修饰构造函数时，即可避免构造函数隐式类型转换 29、初始化和赋值的区别 对于简单类型来说，初始化和赋值没什么区别 对于类和复杂数据类型来说，可以举例如下： 30、extern”C”的用法为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern”C”后，相当于告诉这个编译器这部分代码是C写的，要用C语言编译，而不是CPP； 使用extern”C”的情形： C++代码中调用C语言代码 在C++中的头文件中使用 在多人协同开发时，可能有人擅长C语言，有人CPP 举例： 综上：在C语言的头文件中，对其外部函数只能指定位extern类型C语言中不支持extern”C”声明，在.c文件中包含了extern”C”时会出现编译语法错误。所以，extern”C”全部都放在与 CPP 程序相关文件或头文件中。 总结： C++ 调用 C 函数 C调用C++函数 31、野指针和悬空指针都是指向无效内存区域（这里的无效指的是“不安全不可控”）的指针，访问行为将会导致未定义行为。 野指针：没有被初始化过的指针 因此，为了防止出错，对于指针初始化时都是赋值为nullptr，这样在使用编译器就会直接报错，产生非法内存访问。 悬空指针：指针最初指向的内存已经被释放了的一种指针 此时，p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置：p = p2 = nullptr。否则，继续使用会导致编译器直接报错。【因此避免悬空指针比较麻烦】C++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。 小总结：产生原因及解决办法野指针：指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。悬空指针：指针free或delete后没有及时置空 &#x3D;&gt; 释放操作后立即置空。 32、C和C++的类型安全什么是类型安全？类型安全很大程度上可以等价为内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该编程语言是否提供保障类型安全的机制；“类型安全”也被用来形容某个程序，判别的标准在于该程序是否隐含类型错误。 类型安全的编程语言和程序之间没有必然联系。看程序员的操作水平，相对安全的Language也可以写出不安全的程序，但没有绝对类型安全语言。 C的类型安全：C 只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换为另一种结构体的指针时，编译器会报告错误，除非显式类型转换。然而，C中相当操作是不安全的，如下: C不安全例子1 printf格式输出 上述代码中，使用%d控制整型数字的输出，没有问题，但是改为%f时，输出错误【参考IEEE的浮点格式】如果改成%s，运行直接报segmentation fault错误 C不安全例子2 malloc函数的返回值 malloc 是 C 中进行内存分配的函数，它的返回类型是void即空类型指针，常常有：char pStr &#x3D; (char*) malloc(100 * sizeof(char));这里明显做了显式类型转换。 类型匹配尚且没有问题，但是一旦出现int* pInt &#x3D; (int*) malloc(100 * sizeof(char))就很可能出现一些问题，这样的转换C并不会提示错误。 C++的类型安全如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全： 操作符new返回的指针类型严格与对象匹配，而不是void* C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换 一些#define 宏可以被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全 C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast设计更多具体的类型检查 使用void*进行类型转换 不同类型指针之间转换 上述两个例子之所以引起类型不安全问题，是因为使用不得当。例子1：只用了空类型指针void*；例子2：在两个指针类型之间进行强制转换。 若想保证程序的类型安全性，应尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。 33、C++中的重载、重写（覆盖）和隐藏的区别 重载（Overload） 重载是指在同一范围定义中的同名函数存在重载关系。 特点：函数名相同、参数类型和数目不同。 注意：仅仅依靠返回值区分不同的函数是不可取的。 重载和成员函数是否是虚函数无关。 重载例子 重写（覆盖）（Override） 重写指的是在派生类中覆盖基类中的同名函数。 重写就是重写函数体，要求基类函数必须是虚函数并且： 与基类的虚函数有相同的参数个数 与基类的虚函数有相同的参数类型 与基类的虚函数有相同的返回值类型 重写例子 【64位下虚函数表是8B】 重载和重写的区别： * 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系 * 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求 * 重写关系中，调用方法根据对象类型决定； 重载根据调用时实参表与形参表的对应关系来选择函数体。 隐藏（hide) 隐藏指的是有些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况： 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。例子： 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中，例子： 补充 34、C++有哪几种构造函数C++中的构造函数可以分为4类： 默认构造函数 初始化构造函数（有参数和参数列表） 拷贝构造函数 移动构造函数（move和右值引用） 委托构造函数 转换构造函数例子： 构造函数分类 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作 复制构造函数用于复制本类的对象 转换构造函数用于将其他类型的变量，隐式转换为本类对象 35、浅拷贝和深拷贝的区别 浅拷贝浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误 深拷贝深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放了内存也不会影响到深拷贝的值。在自己实现拷贝赋值的时候，如果有指针变量的话还是要自己实现深拷贝的。 浅拷贝和深拷贝 从执行结果可以看出：浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。 36、内联函数和宏定义的区别 在使用时，宏只做了简单字符串替换（编译前）。内联函数可以进行参数类型检查（编译时），且具有返回值。 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率；而且进行参数类型检查，具有返回值，可以实现重载 宏定义时要注意书写（参数要括起来），否则容易出现歧义，内联函数不会出现歧义 内联函数有类型检测、语法判断等，宏定义没有 内联函数适用场景： 适用宏定义的地方都可以使用内联函数 作为类成员接口来读写类的私有成员或者保护成员可以提高效率 37、public&#x2F;protected&#x2F;private访问和public&#x2F;protected&#x2F;private继承权限的区别 public 的变量和函数在类的内部和外部都可以使用 protected 的变量和函数只能在类的内部和其派生类中访问【protected是针对继承而言的】 private 修饰的元素只能在类内访问 访问权限派生类可以继承基类中除了构造&#x2F;析构、赋值运算符重载函数之外的成员但这些成员的访问属性在派生过程中也是可以调整的，访问权限如下：【注意外部访问不是真正的外部访问，而是在通过派生类的对象对基类成员的访问】 派生类对基类成员的访问形象有如下两种： 内部访问：由派生类中新增的成员函数对继承来的成员的访问 外部访问：在派生类外部，通过派生类对象对继承来的成员的访问 继承权限 public继承公有继承的特点是： 基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态 基类的私有成员仍然是私有的，不能被这个派生类的子类所访问 protected继承保护继承的特点是： 基类的公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问。 基类的私有成员仍然是私有的，访问规则如下： private继承私有继承的特点是： 基类的公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问， 基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表： 总结： 访问权限 访问权限 外部 派生类 内部 public √ √ √ protected × √ √ private × × √ 继承权限 派生类继承自基类的成员权限有四种状态：public、protected、private、不可见 派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限 派生类对基类成员的访问权限是取以上两点中的更小的访问范围（除了private继承方式遇到private成员是不可见）例如： public 继承 + private 成员 &#x3D;&gt; private private 继承 + protected 成员 &#x3D;&gt; private private 继承 + private 成员 &#x3D;&gt; 不可见 38、如何用代码判断大小端存储 大端存储：字数据的高字节存储在低地址中 小端存储：字数据的低字节存储在低地址中 例如：32bit数字0x12345678 小端模式中的存储方式为： 内存地址 0x4000 0x4001 0x4002 0x4003 存放内容 0x78 0x56 0x34 0x12 大端模式中的存储方式为： 内存地址 0x4000 0x4001 0x4002 0x4003 存放内容 0x12 0x34 0x56 0x78 大端模式更贴近于人类的阅读习惯小端模式更有利于计算机读取数据 如何在代码中判断大小端存储？ 判断大小端存储 —— 强制类型转换 强制类型转换 判断大小端存储 —— 使用union联合体 使用union联合体 39、volatile、mutable和explicit关键字的用法 volatilevolatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器位置的因素更改例如：操作系统、硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。 当要求使用volatile声明的变量的值的时候，系统总是重新从它所在的内存读取数据即使它前面的指令刚刚从该处读取过数据。 volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。 注意：使用volatile定义常量的话，使用指针可以修改常量值。 volatile指针volatile 指针和 const修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念。 修饰由指针指向的对象、数据是const或volatile的： const char* cpch;volatile char* vpch; 指针自身的值 —— 一个代表地址的整数变量，是const或volatile的 char* const pchc;char* volatile pchv; 注意： 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰 C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile和const一样会从类传递到它的成员。 多线程下的volatile 有些变量是用volatile关键字声明的。 当两个线程都要用到某一个变量且该变量的值会被改变时，应该使用volatile声明。 该关键字的作用是防止优化编译器将变量从内存装入CPU寄存器中。 如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，导致程序错误执行。 volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用寄存器中现有的值。 mutable（可变的，易变的） 和constant是反义词。 C++中，mutable也是为了突破const的限制而设置的。 被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。 如果在类的成员函数不会不会改变对象的状态，则成员函数一般会声明为const。 有些时候，我们要在const函数里修改一些和状态无关的数据成员，则该函数就应该被mutable修饰，并且放在函数后面关键字位置。 样例 explicitexplicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换。只能以显式的方式类型转换，例如： explicit 关键字只能用于类内部的构造函数声明上 explicit 关键字作用于单个参数的构造函数 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换 40、什么情况下会调用拷贝构造函数 用类的一个实例化对象去初始化另一个对象的时候 函数的参数是类的对象时（非引用传递） 函数的返回值是函数体内局部对象的类的对象时，此时虽然发生（Named return Value 优化）NRV优化。由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数。 其中：第三种情况在Linux g++下不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数 总结：NRV优化情况下，Linux g++环境不管是返回值还是返回引用都不会发生拷贝构造函数。 Windows VS2019在值返回情况下发生拷贝构造函数，引用返回方式则不会发生拷贝构造函数。 VS2019下进行实验 一个实例对象去初始化另一个实例对象，调用拷贝构造函数 调用函数时，先根据传入实参产生临时对象，用拷贝构造函数初始化该临时对象，与形参对应 执行return，产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量再析构临时对象。 41、C++有几种类型new有 plain new&#x2F;nothrow new以及placement new plain new 普通的new，即常用的new，定义如下： 因此 plain new 在空间分配失败的情况下，抛出异常std::bad_alloc而非nullptr，因此不能通过判断nullptr来判断是否分配成功 例子 nothrow new nothrow new 在空间分配失败的情况下不抛出异常，而是返回nullptr，定义如下： 例子 placement new这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new 不用担心内存分配失败，因为根本不分配内存，所做的唯一事情就是调用对象的构造函数。定义如下： 使用placement new注意： placement new 的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或其数组 placement new 构造起来的对象数组，要显式地调用他们的析构函数来销毁（析构函数并不释放内存）不能使用delete，因为placement new 构造起来的对象或数组大小并不一定等于原来分配的内存大小。使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。 例子 42、C++的异常处理方法 43、static的用法和作用？ 隐藏（static函数，static变量均可） 当同时编译多个文件时，所有未加static前缀的全局变量和函数都有全局可见性 保持变量内容持久（static变量的记忆功能和全局生存期） 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一一次初始化。 静态存储区：全局变量和static变量【static控制变量可见范围，总之还是隐藏】 默认初始化为0（static变量） 静态数据区的两种变量都有这样的特性 C++中类成员声明 static 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值。 模块内static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问。 在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内； 在类中的static成员变量属于整个类所拥有，对类的虽有对象只有一份拷贝。 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。 static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化。 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。 static成员函数不能被virtual修饰，static成员不属于任何对象或实例，因此加上virtual没有任何实际意义同时，virtual虚函数是要通过this指针调用虚函数表：this-&gt;vptr-&gt;ctable-&gt;virtual function 44、指针和const的用法 当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。 int *const p2中const修饰 p2 的值【 修饰int】，所以理解为 p2 的值不可改变，即 p2 只能指向固定的一个变量地址，可以通过p2读写这个变量的值。顶层指针表示指针本身是一个常量。 int const *p1或者const int *p1两种情况中const修饰 *p1，所以理解为 p1的值不可以改变，即不可以给p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。 底层指针表示指针所指向的变量是一个常量。 45、形参和实参的区别？ 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效，函数调用结束返回主调函数后不能使用该形参变量。 实参可以是常量、变量、表达式、函数等，无论实参是那种类型的变量，在进行函数调用时，都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”错误 函数调用中发生的数据传送是单向的 —— 只能把实参的值送给形参，不能把形参的值反向传给实参。在函数调用过程中，形参值发生改变，形参中的值不会变化。 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置。形参将实参的内容复制一份，在该函数运行结束时形参被释放，实参内容不会改变。 46、值传递、指针传递、引用传递的区别和效率 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或大结构体对象，将耗费一定的时间和空间（拷贝构造）。 指针传递：同样有一个形参想函数所属的栈拷贝数据的过程。但拷贝的数据固定是一个n字节的地址（传值，不过传地址值）。 引用传递：同样有上述数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名（传地址）。 效率上讲，指针传递和引用传递比值传递效率高。一般主张引用传递，代码逻辑上更加紧凑、清晰。 47、静态变量什么时候初始化 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序直线，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化结点也有不同。 在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被回收。 在C++中，初始化时在执行相关代码才会进行初始化，主要是C++引入对象后，要进行初始化不许执行相应构造&#x2F;析构函数，在其中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以C++中可以使用变量对静态局部变量进行初始化的。 48、const关键字的作用有哪些？ 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对其进行初始化，因为以后没机会改变他了（实际上有） 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定位const 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数。 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值” const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员。 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不能访问const对象的任意数据成员。 一个没有明确声明为const的成员函数被看做是将要修改对象中数据成员的函数,而且编译器不允许它为一个const对象所调用，因此const对象只能调用const成员函数。 const类型变量可以通过类型转换符const_cast将const类型转换为非const类型 const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化。 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进参数的，函数内只能改变临时变量，但无法改变实参。这个时候无论加不加const都不会对实参产生任何影响。但是在引用或者指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量这个时候const才是实实在在保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。 49、什么是类的继承？ 类与类之间的关系 has-A 包含关系，用以描述一个类由多个部件类构成，实现has-A 关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类 use-A 使用关系，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现 is-A 继承关系，关系具有传递性； 继承的相关概念 所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或派生类 被继承的类称为父类或基类 继承的特点 子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用 继承中的访问控制 public、protected、private 继承中的构造和析构函数 继承中的兼容性原则 50、从汇编层去解释一下引用 汇编层解释引用 x 的地址是 ebp-4，b 的地址是ebp-8，因为栈内的变量内存是从高往低进行分配的，所以 b 的地址比 x 的低。lea eax, [ebp-4 ] 这条语句将 x 的地址 ebp-4 放入eax寄存器mov dword ptr [ebp-8 ], eax 这条语句将eax的值放入 b 的地址 ebp-8中上面两条汇编的作用：将x的地址存入变量b中，这与将某个变量的地址存入指针变量是一样的 总结：引用是通过指针来实现的 51、深拷贝和浅拷贝？ —— 参考条目35 52、new和malloc区别？ —— 参考条目10 补充：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现） 然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。 delete先调用析构函数，然后调用operator delete函数释放内存，（通常底层使用free实现） 即 分配内存 —— 构造函数 —— 析构函数 —— 释放内存 malloc&#x2F;free是库函数，只能动态地申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 53、delete p、delete []p、allocator都有什么作用？ 动态数组管理 new 一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数 new 动态数组返回的并不是数据类型，而是一个元素类型的指针 delete[] 时，数组中的元组按照逆序的顺序进行销毁 new 在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样delete也是降对象析构和内存释放组合在一起 allocator将申请内存和对象构造函数分开来，allocator申请一部分内存，不进行初始化对象，只有需要时才进行初始化操作。 54、new和delete的实现原理，delete是如何知道释放内存大小的？ new简单类型直接调用operator new分配内存；new复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数； new[]简单类型计算好大小后调用operator new；new[]复杂结构，先调用operator new[] 分配内存，然后在p的前4个字节输入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小 new 表达式调用一个名为operator new(operator new[]) 函数，分配一块足够大的、原始的、未命名的内存空间； 编译器运行相应的构造函数以构造这些对象，并为其传入初始值； 对象被分配了空间并构造完成，返回一个指向该对象的指针。 delete 简单数据类型默认只是调用 free函数；delete 复杂数据类型先调用析构函数在调用 operator delete 针对简单类型，delete 和 delete[] 等同。假设指针p指向new[]分配的内存，因为要4字节存储数组大小，实际分配的内存地址为 [p-4 ]，系统记录的也是这个地址。delete[] 实际释放的是p-4指向的内存，delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃 需要在new[] 一个对象数组时，需要保存数组的维度，C++的做法是在分配数组空间时多分配了4个字节的大小，专门保存数组的大小在delete[] 时就可以取出这个保存的数，就知道需要调用析构函数多少次了。 55、malloc申请的存储空间能用delete释放吗？不能 malloc&#x2F;free主要是为了兼容C，new&#x2F;delete是完全可以取代malloc&#x2F;free的 malloc&#x2F;free的操作对象都是必须明确大小的，而且不能用在动态类上。new和delete会自动进行类型检查和大小 malloc&#x2F;free不能执行构造函数和析构函数，所以动态对象不能用该方法创建&#x2F;销毁 理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写，而且不能保证每个运行程序都正常。 56、malloc和free的实现原理？ 在标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk&#x2F;mmap&#x2F;munmap这些系统调用实现的 brk是将数据段(.data)的最高地址指针_edata往高地址推，mmap是在进程的虚拟地址空间中(堆和栈中间，成为文件映射区域的地方)找一块空闲的虚拟内存。这两种方式都是分配虚拟内存，没有分配物理内存。在一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系； malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128k（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。 malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后寻找第一个空间大于所申请空间的堆结点，然后将该节点从空闲结点链表中删除，并将该节点的空间分配给程序 57、malloc、realloc、calloc的区别 malloc函数 calloc函数 省去了人为空间计算，malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的； realloc函数 给动态分配的空间分配额外的空间，用于扩充容量。 58、类成员初始化方式？构造函数执行顺序？为什么用成员初始化列表快一些？ 赋值初始化，通过在函数体内进行赋值初始化初始化列表，在冒号后使用初始化列表进行初始化。 两种方式主要区别： 对于在函数体中初始化，是在所有数据成员被分配内存空间后进行的。 初始化列表是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式（此表达式必须是括号赋值表达式）则分配内存空间后在进入函数体之前给数据成员赋值，也就是初始化这个数据成员时，函数体还未执行 一个派生类构造函数的执行顺序如下： 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）【菱形继承的大基类】 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数） 类类型的成员对象的构造函数（按照初始化顺序） 派生类自己的构造函数 方法一是在构造函数当中做赋值的操作方法二是做纯粹的初始化的操作。众所周知：C++的赋值操作是会产生临时对象的，临时对象的出现会降低程序的效率 59、有哪些情况必须用到成员列表初始化？作用是什么？ 必须使用成员初始化的四种情况 当初始化一个引用成员时； 当初始化一个常量成员时； 当调用一个基类的构造函数，而它有一组参数时； 当调用一个成员类的构造函数，而它拥有一组参数时； 成员初始化列表做了什么？ 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前； list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的。 60、C++中新增了string，它与C语言中的char *有什么区别吗？如何实现的？ string 继承自 basic_string，其实是对char *进行了封装，封装的string包含了char *数组，容量，长度等等属性。 string 可以进行自动扩展，在每次扩展的时候另外申请一块原空间大小2倍的空间，然后将源字符串拷贝过去，并加上新增内容。61、什么是内存泄漏、如何检测和避免 内存泄漏一般常说的内存泄漏是指堆内存的泄漏堆内存是程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期间决定）内存块，使用后必须显式释放的内存。应用程序一般使用malloc&#x2F;realloc&#x2F;new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free&#x2F;delete释放该内存块否则，这块内存就不能被再使用，则称之为该内存泄漏 避免内存泄漏的几种方式 计数法： 使用new和malloc时，该数+1，delete&#x2F;free时，该数-1，程序执行完打印这个计数，如果不为0则存在内存泄漏 一定要将基类的析构函数声明为虚函数 对象数组的释放一定要用 delete [] 有new就有delete，有malloc就有free，保证他们成对出现 检测工具 Linux下可以使用Valgrind工具 Windows下可以使用CRT库 62、对象复用的了解、零拷贝的了解 对象复用和零拷贝 对象复用对象复用本质就是一种设计模式：Flyweight享元模式通过将对象存储到“对象池”中实现对对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。 零拷贝零拷贝就是一种避免CPU将数据从一块存储拷贝到另一块存储的技术零拷贝技术可以减少数据拷贝和共享总线操作的次数在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术（和push_back()一样可以将一个元素插入容器尾部）区别在于：push_back()需要调用拷贝构造函数和转移构造函数；emplace_back()插入的元素原地构造，不需要拷贝和转移 零拷贝 63、介绍面向对象的三大特性，并举例说明三大特性：封装、继承、多态 封装 数据和代码捆绑在一起，避免外界干扰和不确定性访问。 封装，也就是把客观事物封装成抽象的类，并且类可以吧自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。 继承 让某种类型对象获得另一个类型对象的属性和方法 它可以实现现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展 常见的继承有三种方式： 实现继承：指使用基类的属性和方法而无需额外编码 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++不常用） 例如：车定义为抽象类，可以派生出轿车、卡车等有自己的属性和方法，但有一些共同点可以在车类中共同编码 多态 同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为 （重载实现编译时多态，虚函数实现运行时多态） 多态性是允许你将父对象设置成为和一个或更多他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同方式运作。 总之：允许将子类类型的指针赋值给父类类型的指针 实现多态的方式有两种：覆盖（override），重载（overload） 覆盖：是指子类重新定义父类的虚函数的做法 重载：是指允许存在多个同名函数，而这些函数又属于重载关系。 64、成员初始化列表的概念，为什么用它会快一点 —— 参考条目58如果在函数体内进行赋值，相当于一次默认构造+一次赋值，初始化列表中只一次赋值操作【如果成员中含有类的话，那初始化列表是快一些，省去了构造函数时间】 65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast reinterpret_cast reinterpret_cast&lt; type_id&gt; (expression) type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。 它可以用于类型之间的强制转换 const_cast const_cast&lt; type_id&gt;(expression) 该运算符用来修改类型的const或volatile属性。 除了const或volatile修饰以外，type-id和expression的类型是一样的 具体用法如下： 常量指针被转化为非常量的指针，并且仍然指向原来的对象 常量引用被转换为非常量的引用，并且仍然指向原来的对象 const_cast一般用于修改底指针。如const char *p形式 static_cast static_cast&lt; type_id&gt;(expression) 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。 主要以下几种用法: 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的【父类是子类的子集】 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的 用于基本数据类型之间的转换，如把int转换为char，把int转换为enum。这种安全性也要开发人员来保证。 把空指针转换成目标类型的空指针 把任何类型的表达式转换成void类型 注意：static_cast不能转换掉expression的const&#x2F;volatile或者__unaligned属性。 dynamic_cast dynamic_cast&lt; type_id&gt;(expression) 有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全（和static_cast相反？） 该运算符把expression转换成type_id类型的对象，type_id必须是类的指针、类的引用或者void* 如果type_id是类指针类型，那么expression也必须是一个指针 如果type_id是一个引用，那么expression也必须是一个引用 dynamic_cast 运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。 如果下行转换是安全的（也就是说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象） dynamic_cast 主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换 在类层次间进行上行转换时，dynamic_cast和static_cast效果是一样的 在进行下行转换时，dynamic_cast具有类型检查功能，比static_cast更安全【下行转换不安全时直接nullptr】 例子 总结：下行转换时，dynamic_cast是安全的，如果下行转换不安全的话会返回空指针，这样在进行操作时可以预先判断使用static_cast下行转换时存在不安全情况也可以转换成功，但是直接使用该对象可能会产生错误 同时，reinterpret_cast不能丢掉原数据类型的const，同时，无论参数是什么，只要type-id是合法类型就可转换 66、C++函数调用的压栈过程 以例子进行讲解 例子讲解压栈过程 当函数从入口函数main函数开始执行时，编译器会将操作系统运行状态、main函数返回地址、main参数、main()内定义变量依次进行压栈； 当main()开始调用func()时，编译器此时会将main()的运行状态压栈再将func()函数的返回地址，func()函数参数从右到左，func()定义变量依次压栈； 当func()调用f()的时候，编译器此时会将func()函数的运行状态压栈再将返回地址、f()函数的参数从右到左，f()定义变量依次压栈； 从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串将栈中的变量依次弹出，最后主函数返回。 文字化表述函数的调用过程： 从栈空间分配存储空间 从实参的存储空间复制值到形参栈空间 进行运算 形参在函数未调用之前都是没有分配存储空间的，在函数调用结束后，形参弹出栈空间，清除形参空间。 数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但内存空间依然存在，不能也不会被销毁。 当函数有多个返回值时，不能用普通return方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。67、写C++代码时有一类错误是coredump，常见，如何调试？coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。 使用gdb命令对core文件进行调试 以下例子在Linux上编写一段代码并导致segment fault并产生core文件 例子 编辑器内键入： 编译 运行 使用gdb调试coredump 68、移动构造函数 用对象a初始化对象b，a不再使用，但a的空间依然存在既然拷贝构造函数是使用a内容复制给b，为什么不直接用a的空间？这样甚至可以避免新空间的分配，降低了构造成本。 拷贝构造函数中，对于指针，一定要深拷贝移动构造函数中，对于指针，可以使用浅拷贝。 若使用浅拷贝，第一个对象释放指针时，将其置为nullptr，可以避免悬空指针 移动构造函数参数和拷贝构造函数参数不同：拷贝构造函数的参数是一个左值引用，移动构造函数的参数是一个右值引用即：移动构造函数参数是一个右值或者将亡值引用。即：只用一个右值，或者将亡值初始化另一个对象的时候才调用移动构造函数std::move()的作用是将左值变成一个右值 补充，一般函数返回值都是右值，如果返回左值需要返回一个引用 69、C++中将临时变量做返回值的处理过程首先：临时变量在函数调用过程中是被压到程序进程栈中的，函数退出时，临时变量出栈，即临时变量被销毁， 其占用内存空间没有清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说没有意义 C中规定：16bit程序中，返回值保存在ax寄存器中 32bit程序中，返回值保存在eax寄存器中 64bit程序中，高32bit保存在edx中，低32bit保存在eax中 即：函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系 退出函数时时，临时变量可能被销毁，但返回值放到寄存器中，与临时变量生命周期没有关系 如果需要返回值，一般使用赋值语句即可70、如何获得结构成员相对于结构开头的字节偏移量使用&lt; stddef.h&gt;头文件中的offsetof宏 示例 当然可以使用 #pragma pack(4)指定4字节对齐方式 71、静态类型和动态类型，静态绑定和动态绑定 静态类型：对象在声明时采用的类型，在编译器即已经确定 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期； 由以上定义看出，非虚函数一般是静态绑定，而虚函数都是动态绑定（如此可以实现多态性） 例子 如果将A类中的virtual注释去掉，则结果是： 在上面的例子中： 如果基类A中的func不是virtual函数，那么不论pa&#x2F;pb&#x2F;pc指向哪个子类指针，对func的调用都是在定义pa&#x2F;pb&#x2F;pc时的静态类型决定【编译期】 同样空指针也能直接调用no-virtual函数而不报错【一定要做空指针检查】，因此静态绑定不能实现多态； 如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是有性能损失的，但能实现多态特性。 注意，上述代码是针对指针分析的，对引用的情况也同样适用 静态绑定和动态绑定的区别： 静态绑定发生在编译期，动态绑定发生在运行期； 对象的动态类型可以更改，静态类型无法更改； 要想实现多态，必须使用动态绑定； 在继承体系中只有虚函数使用的是动态绑定，其他的全都是静态绑定； 建议： 不要重新定义继承而来的非虚函数，这样导致函数调用由对象声明时的静态类型确定了，而与对象本身脱离了关系，没有多态，从而有隐患 在动态绑定也即在virtual函数中，要注意默认参数的使用。 当缺省参数和virtual函数一起使用时一定要谨慎，不然出了问题很难排查。 缺省参数 72、引用是否能实现动态绑定，为什么可以实现？可以引用在创建时必须初始化，在访问虚函数时，编译器会根据其绑定的对象类型要调用哪个函数，注意只能调用虚函数。 即：虚函数才有动态绑定，采用虚函数情况下，使用的是动态绑定对象的虚函数73、全局变量和局部变量有什么区别 声明周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在 使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。 操作系统和编译器通过内存分配的位置可以区分二者全局数据分配在全局数据段并且在程序开始运行时被加载局部变量则分配在堆栈里 74、指针加减计算要注意什么？指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及指针加减运算需要十分小心。操作不当会导致指向未知区域，从而内存风险 例子 首先变量a和b都是以16进制的形式初始化，将它们转换成十进制分别是1280和1312则差值为32，即a和b所指地址之间间隔32位但是由于int类型占4位，所以c的值为32&#x2F;4 &#x3D; 8【int类型4位】 a自增16进制0x20后，其实际地址为1280+2*16 *4 &#x3D; 1408（因为一个int是4位，要乘4）则他们的差值变成了1312-1280&#x3D;-96，即-96&#x2F;4 &#x3D; -24 遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成十进制计算，计算结果要除以类型长度 75、如何判断两个浮点数相等？要误差小于某个特定的值，不能直接用&#x3D;&#x3D;76、方法调用的原理（栈、汇编） 机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储，为单个过程分配的那部分叫做帧栈；帧栈可以认为是程序栈的一段，有两个端点，一个标识起始地址，一个标识结束地址两个指针结束地址指针esp，开始地址指针ebp； 有一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回过程；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向着地址递减的方向延伸，因此如果我们将栈指针减去一定的值，相当于分配了一定空间的内存。如果加上一定的值，相当于压缩栈帧长度，即内存释放。 过程实现 备份原来栈指针，调整当前栈帧指针到栈指针位置； 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。 恢复被调用者寄存器当中的值，这一过程其实是栈帧中将备份的值再恢复到寄存器，不过这些值可能已经不在栈顶 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域有回到了原始的位置。 弹出返回地址，跳出当前过程，继续执行调用者代码。 过程调用和返回指令 call指令 leave指令 ret指令 77、C++中的指针参与传递和引用参数传递有什么区别？底层原理 指针参数传递本质上是值传递，传递的是一个地址值。 值传递是一个副本，只是对局部变量进行操作，不会改变原变量的值 引用传递过程中，被调函数的形参也作为局部变量在栈中开辟内存，但存放的是主调函数放进来的实参变量的地址。 被调函数对形参（本体）的任何操作都被处理为间接寻址，即还是要修改到实参变量。 引用传递和指针传递是不同的 对引用传递的修改，间接寻址，修改到原实参的值 对指针传递参数本身的修改，只是改变这个地址的值（除非该地址指向的区域） 编译角度上来说，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名和变量对应的地址 指针变量在符号表上对应的地址值为指针变量的地址值 —— 指针的指针，因此可以修改指针 引用在符号表上对应的地址值为引用对象的地址值 —— 引用对象的地址值，因此不可以修改这个条目【因为符号表不能修改】 符号表生成后就不可以修改，因此指针可以改变指向对象（指针变量中值可以改），引用对象不能修改。 78、类如何实现只能静态分配和只能动态分配 静态分配：把new和delete运算符重载为private属性动态分配：把构造、析构函数设为protected属性，再用子类动态创建 建立类的对象有两种方式： 静态建立：静态建立一个类对象，就是由编译器为对象在占空间中分配内存 动态建立：A *p &#x3D; new A(); 动态建立一个类对象，就是用new运算符为对象在堆空间中分配内存步骤：第一，执行operator new()函数，在堆中搜索一块内存并分配；第二，调用类构造函数构造对象 使用new运算符，对象才会被建立在堆上只要限制new运算符就可以实现类对象只能建立在栈上，即将new运算符设置为私有 79、如果想将某个类用作基类，为什么该类必须定义而非声明？派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么所以必须定义而非声明。 80、继承机制中对象之间如何转换？指针和引用之间如何转换？ 向上类型转换 将派生类指针或引用转换为基类的指针或引用被称为向上类型转换 向上类型转换会自动进行，而且向上类型转换是安全的 向下类型转换 将基类指针或引用转换为派生类指针或引用被称为向下类型转换 向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类 向下类型转换必须加动态类型识别技术RTTI，用dynamic_cast向下类型转换 81、C++中的组合，和继承相比缺点？ 继承 继承是 is A 的关系，Student 继承 Person，即Student is a Person。 继承的优点： 是子类可以重写父类的方法来方便地实现对父类扩展 继承的缺点： 父类的内部细节对子类是可见的 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为 如果对父类的方法做了修改的话（如增加了一个参数），则子类的方法必须做出相应的修改。所以子类和父类是一种高耦合，违背了OOP 组合 组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。 组合的优点： 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象不可见 当前对象和包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。 当前对象可以在运行时动态的绑定所包含的对象，可以通过set方法可以给所包含对象赋值 组合的缺点： 容易产生过多的对象 为了能组合多个对象，必须仔细对接口进行定义 82、函数指针 什么是函数指针？ 函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的 函数的名称则不是其类型的一部分 一个具体函数的名字，如果后面不跟调用符号（括号），则该名字就是函数的指针（大部分情况下是如此，但不严格） 函数指针的声明方法。 int (*pf)(const int&amp;, const int&amp;);pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&amp; 参数的函数。 int pf(const int&amp;, const int&amp;);声明了一个函数pf，返回类型为int，带有两个const int&amp;参数。 为什么有函数指针函数与数据项相似，函数也有地址。【参考汇编 call 指令】希望同一个函数通过使用相同的形参在不同的时间产生不同的效果。 一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传给其他的函数。 两种方法赋值：指针名 &#x3D; 函数名;指针名 &#x3D; &amp;函数名; 83、内存对齐及原因。 内存对齐 分配内存的顺序是按照声明的顺序。 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍则空出内存，直到偏移量是整数倍 最后整个结构体的大小必须是里面变量类型最大值的整数倍。 添加#pragma pack(n)后： 偏移量要是n和当前变量大小中较小值的整数倍 整体大小要是n和最大变量大小中较小值的整数倍 n值必须为1,2,4,8……，为其他值时要按照默认的分配规则。 84、结构体变量比较是否相等 重载 “&#x3D;&#x3D;” 操作符 重载 元素的话一个个比 指针直接比较，如果保存的是同一个实例地址，则(p1 &#x3D;&#x3D; p2)为真。 85、函数调用过程栈的变化，返回值和参数变量哪个先入栈？ 调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中，即：从右往左依次把被调函数所需要的参数压入栈。 调用者函数使用call指令调用被调函数，并把call指令的下一条指令的地址当成返回地址压入栈中（压栈操作隐含在call中） 在被调函数中，被调函数会先保存调用者函数的栈底地址（push ebp），然后再保存调用者函数的栈顶地址【上个函数返回地址，当前函数返回地址】即：当前被调函数的栈底地址（mov ebp, esp） 在被调函数中，从ebp的位置处开始存放被调函数的局部变量和临时变量，并且这些变量的地址按照定义时的顺序依次减小即：这些变量的地址是按照栈的延伸方向排列的，先定义的变量先入栈，后定义的变量后入栈。 86、define、const、typedef、inline的使用方法？他们之间的区别？ const和#define的区别 const定义的常量是变量带类型#define定义的是常数不带类型 const在编译、链接过程中起作用#define只在预处理阶段起作用，简单的文本替换 const有数据类型，是要进行类型检查，可以避免一些低级错误#define只是简单的字符串替换没有类型检查 const占用数据段空间#define占用代码段空间 const不能冲定义#define可以通过undef取消某个符号的定义，进行重定义 #define独特功能，比如可以用来防止文件重复引用 #define和别名typedef的区别 执行时间不同：#define是宏定义，发生在预处理阶段，不进行类型检查typedef在编译阶段有效，有类型检查的功能 功能差异：#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等typedef用来定义类型的别名，定义与平台无关的数据类型，与struct结合使用等 作用域不同：#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用typedef有自己的作用域。 define和inline的区别 #define是关键字inline是函数 宏定义在预处理阶段进行文本替换inline函数在编译阶段进行替换 宏定义没有类型检查inline函数有类型检查 87、printf的实现原理C&#x2F;C++中对函数参数的扫描是从后向前的 压栈传参，栈是从高地址向低地址生长的，控制生长的是堆栈指针，最后压入的参数总能被函数找到，因为就在堆栈指针上方。 printf第一个被找到的参数就是字符指针，就是被双引号括起来的一部分，函数通过判断字符串里的参数的个数来判断参数的个数即数据类型从而算出堆栈指针的偏移量 88、为什么模板类一般都是放在一个h文件中 模板定义很特殊由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。 所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在也不会去查找（当遇到未决符号时会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但模板仅在需要的时候才实例化出来。 所以编译器只看到模板声明，不能实例化该模板，只创建一个有外部连接的符号并期待连接器能将符号地址决议出来。 当实现该模板的.cpp文件中没有用到模板的实例时，编译器不去优化，因此整个工程.obj找不到一行模板实例的二进制代码，连接器也做不到。 89、C++中类成员的访问权限和继承权限问题 —— 参见条目37 90、cout 和 printf 有什么区别？cout &lt;&lt; 是一个函数，cout &lt;&lt; 后可以跟不同的类型是因为cout &lt;&lt; 已存在针对各种数据类型的重载，所以会自动识别数据类型输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。 cout 是有缓冲输出 flush立即强迫缓冲输出，printf是无缓冲输出，有输出时立即输出。91、重载运算符 只能重载已有的运算符，无权发明新的运算符；对于重载运算符，优先级和结合律与内置类型一致才可以；不能改变操作符运算数个数。 两种重载方式： 成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数 下标运算符、箭头运算符，必须是成员运算符 引入运算符重载，是为了实现类的多态性。 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符的对象的数量少一个至少含有一个类类型的参数 从参数个数推断到底定义的是哪种运算符当运算符既是一元运算符又是二元运算符（+,-,*,&amp;） 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本； 箭头运算符必须是类的成员，解引用通常也是类的成员重载的箭头运算符必须返回类的指针 92、当程序中有函数重载时，函数的匹配原则和顺序是什么？ 名字查找 确定候选函数 寻找最佳匹配 93、定义和声明的区别 —— 参见条目15有变量、函数的声明和定义94、全局变量和static变量的区别 全局变量（外部变量）的说明之前再冠以static就构成了静态全局变量 全局变量本身就是静态存储方式、静态全局变量也是静态存储方式。 上述两种在存储方式上并无不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态全局变量在各源文件有效。 静态全局变量限定了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。 静态全局变量的作用限于一个源文件内有效，在同一源程序的其他源文件中不能使用它 由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数共用，因此可以避免在其他源文件内引起错误 static全局变量域普通的全局变量的区别是：static全局变量只初始化一次，防止在其他文件单元被引用。 static函数和普通函数区别？ static函数与普通的函数作用域不同，只在本文件中。 只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。 对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。 static函数与普通函数最主要的区别就是static函数在内存中只有一份 普通函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆） 95、静态成员与普通成员的区别？ 生命周期 静态成员变量从类被加载开始到类被卸载，一直存在 普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束 共享方式 静态成员变量是全类共享 普通成员变量是每个对象单独想用的 定义位置 静态成员变量存储在静态全局区 普通成员变量存储在栈或堆中 初始化位置 静态成员变量在类外初始化 普通成员变量在类中初始化 默认实参 静态成员变量作为默认实参 96、ifdef和endif代表什么？ 一般情况下，源程序中所有行都参与编译，但有时希望对其中一部分内容只在满足一定条件才可编译，即条件编译有时当满足某条件时对一组语句进行编译，而当条件不满足则编译另一组语句。 条件编译命令最常见的形式： 例子 其作用：当标识符已经被定义过（一般是用#define命令定义），则对程序段1进行编译，否则编译程序段2其中#else部分也可以没有 在一个大的软件工程里，可能会有多个文件同时包含一个头文件，当这些头文件编译链接成一个可执行文件上时，会出现大量重定义错误头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件冲定义。 97、隐式转换，如何消除隐式转换 C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能不知道进行了哪些转换。 C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，可以直接将一个子类的对象使用父类的类型进行返回。例如：数值和布尔类型、整数和浮点类型的转换。某些方面来说，隐式类型转换带来了不小便捷，C++是一门强类型语言，类型的检查是非常严格的。 基本数据类型基本数据类型的转换以取值范围作为转换基础（保证精度不丢失）。隐式转换发生在从小到大的转换中例如：char-&gt;int、int-&gt;long。自定义对象中，子类对象可以隐式转换为父类对象。 C++中提供了explicit关键字，在构造函数声明时加上explicit关键字，能禁止隐式转换 如果构造函数只接受一个参数，则实际上定义了转换为此类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效需要多个实参的构造函数不能执行隐式转换，所以无需将这些构造函数指定为explicit。 98、C++如何处理多个异常的？ C++中的异常情况： 语法错误（编译错误）如：变量未定义、括号不匹配、关键字拼写错误等在编译时就能发现的错误，可被编译器及时发现，而且也可及时知道出错的位置及原因，方便改正。 运行时错误如：数组下标越界、系统内存不足等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃【解决这种错误可以使用异常处理机制】 C++异常处理机制： 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理，而是抛出异常，让函数的调用者直接或间接地处理这个问题。 C++的异常处理机制由3个模块组成： try（检查）、throw（抛出）、catch（捕获） 抛出异常的语句格式为：throw表达式; 如果try块中程序段发现了异常则抛出异常。 异常处理机制 99、如何在不使用额外空间的情况下，交换两个数？ 算术x &#x3D; x + y;y &#x3D; x - y;x &#x3D; x - y; 异或x &#x3D; x ^ y; &#x2F;&#x2F; 只能对int, chary &#x3D; x ^ y;x &#x3D; x ^ y;&#x2F;&#x2F; x ^&#x3D; y ^&#x3D; x; 100、strcpy和memcpy的区别？ 复制的内容不同。 strcpy只能复制字符串 memcpy可以复制任意内容，例如字符数组、整形、结构体、类等。 复制的方法不同。 strcpy不需要指定长度，因为有’\\0’结束，因此容易溢出， memcpy则是根据第三个参数决定复制的长度。 用途不同。 通常在复制字符串时用strcpy 复制其他类型数据一般用memcpy 101、程序在执行int main(int argc, char *argc[])时的内存结构？参数的含义是程序在命令行下运行的时候，需要输入argc个参数，每个参数以char类型输入，依次存在数组里面数组是argv[]，所有的参数在指针char *指向的内存中，数组中的元素个数为argc个第一个参数为程序的名称。 102、volatile关键字的作用 —— 参见条目39volatile用处： 中断服务程序中修改的供其他程序检测的变量要加volatile【都要从内存中取而非寄存器】 多任务环境下各任务间共享的标志应该加volatile 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义。 103、如果有一个空类，它会默认添加哪些函数？ 104、C++中标准库是什么 C++标准库可以分为两部分： 标准函数库：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自C语言。 面向对象类库：这个库是类及其相关函数的集合。 输入&#x2F;输出（I&#x2F;O）、字符串和字符处理、数学、时间、日期、本地化、动态分配、其他、宽字符函数。 标准的C++ I&#x2F;O类、String类、数值类、STL容器类、STL算法、STL函数对象、STL迭代器、STL分配器、本地化库、异常处理库、杂项支持库 105、const char* 和 string之间的关系？ string 是C++标准库里面其中一个，封装了对字符串的操作实际操作过程我们可以用 const char*给string类初始化。 三者转换关系如下所示 例子 106、什么情况用指针参数，什么时候用引用参数？ 使用引用参数原因 程序员能修改调用函数中的数据对象 通过传递引用而不是整个数据对象，可以提高程序运行速度 一般的原则：对于使用引用的值而不做修改的函数： 如果数据对象很小，如内置数据类型或小型结构，则值传递 如果数据对象是数组，则使用指针，并且指针声明为指向const的指针 如果数据对象是较大的结构，则使用const指针或引用，以提高程序效率【可以节省构造所需时间和空间】 如果数据对象是类对象，则使用const引用【传递类对象参数的标准方式是按照引用传递】 对于修改函数中数据的函数： 如果数据是内置数据类型，则使用指针 如果数据对象是数组，则只能使用指针 如果数据对象是结构，则使用引用或指针 如果数据对象是类对象，则使用引用 107、静态绑定和动态绑定？ —— 参照条目71 108、如何设计一个计算仅单个子类的对象个数 为类设计一个static静态变量count作为计数器 类定义结束后初始化count【注意是定义结束后，static类成员独立与类对象存在】 在构造函数中count+1 设计拷贝构造函数，在进行拷贝构造函数中进行count+1 设计复制构造函数，在进行复制函数中对count+1操作 在析构函数中对count进行-1 109、如何快速定位错误出现的地方？ 如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位 对于复杂的模板错误，最好使用生成输出窗口。多数情况下触发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析。 110、初始化成员列表什么时候用？调用过程 —— 参照条目59引用、常量、基类、成员类，按照类中定义顺序执行111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处？对比值传参，引用传参的好处： 在函数内部可以对此参数进行修改 提高函数调用和运行的效率（因为没有传值和生成副本的时间和空间消耗） 如果函数的实参实质就是形参，不过这个形参的作用域只在函数体内部，也即实参和形参是两个不同的东西，形参代替实参，则值传递。 函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。 即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。 函数一旦结束，形参声明也宣告终结，做出的修改一样没对任何变量产生影响。 限制： 不能返回局部变量的引用，因为函数返回以后局部变量就会被销毁。 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），有面临其他尴尬局面如：被函数返回的引用只是作为一个临时变量出现，而没有赋予一个实际的变量，则引用指向的空间（new分配）就无法释放，memory leak 可以返回类成员的引用，但最好是const。因为如果其他对象可以获得该属性的非常量引用，则对该属性单纯赋值会破坏业务规则完整性。 112、说一说strcpy、sprintf和memcpy这三个函数的不同之处 操作对象不同 strcpy的两个操作对象均为字符串 sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串 memcpy的两个对象就是两个任意可操作的内存地址，并不限于任何数据类型 执行效率不同 memcpy 最高；strcpy 次之；sprintf 效率最低 实现功能不同 strcpy主要实现字符串变量间的拷贝 sprintf主要实现其他数据类型格式到字符串的转化 memcpy主要是内存块间的拷贝 113、将引用作为函数参数好处？ 传递引用给函数和传递指针的效果是一样的【都对实参进行修改】 使用引用传递的参数，在内存中并没有实参的副本，而是直接对实参操作【如果传递的数据较大时，用引用效率更高】 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是在被调函数中同样要给形参分配存储单元且需要重复使用”*”运算符进行运算，容易导致程序错误且阅读性较差。同时，指针不如引用清晰 114、指针和数组的区别？ 指针在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof(数组名);数组大小：sizeof(数组名)&#x2F;sizeof(数组元素数据类型); 用运算符sizeof可以计算出数组的容量（字节数)sizeof(p)，p为指针得到的是一个指针变量的字节数，而不是p所指的内存容量。 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。 在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去的是数组的首地址而不是整个数组，能提高效率。 在使用下标的时候，两者的用法相同，都是源地址加下标地址，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址不是固定的。 115、如何组织一个类被实例化？有哪些办法？ 将类定义为抽象基类或将构造函数声明为private 不允许类外部创建类对象，只能在类内部创建类对象 116、如何禁止程序自动生成拷贝构造函数？ 为了组织编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动重写这两个函数某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们要将它们设置为private，防止被调用。 类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生连接错误 真对上述两种情况，我们可以定义一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private，那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此派生类将阻止编译器执行相关的操作。 117、Debug和release的区别？ 调试版本，包含调试信息，因此容量比release大得多，并且不能进行任何优化（优化使调试复杂化，因为源代码和生成的指令间关系更复杂），便于调试。Debug模式下生成两个文件，除了.exe和.dll文件之外，还有一个.pdb文件，该文件记录了代码中断点等调试信息。 发布版本，不对源代码进行任何调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）Release模式下生成一个文件.exe或.dll文件 实际上，Debug和Release并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或带跟踪语句的发布版本。 118、main函数的返回值有什么值得考究之处？ 程序运行过程入口点main函数，main()函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。 main(int args, char **argv)参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到。119、模板类？写一个比较大小模板类 该模板有个比较隐晦的bug，即a、b只有在能进行转型的时候才能进行比较，否则a &gt; b这一步是会报错的。 这个时候往往需要对于 &gt; 号进行重载，代码量++；120、strcpy函数和strncpy函数的区别？哪个函数更安全？ 函数原型 strcpy函数：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出（buffer Overflow）的错误情况，在编写程序的时候特别留意，或用strncpy()；strncpy函数：用来复制源字符串的前n个字符，src和dest所指的内存区域不能重叠，且dest必须有足够的空间存放n个字符。 如果目标长 &gt; 指定长 &gt; 源长，则将源长全部拷贝到目标长，自动加上’\\0’如果指定长 &lt; 源长，则将源长中按指定长度拷贝到目标字符串，不包括’\\0’；如果指定长 &gt; 目标长，运行时错误。【源长：源字符串；指定长：指定的n；目标长：目的字符串】 121、static_cast比C语言中的转换强在哪里？ 更加安全 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可以清楚地辨别代码中每个显式的强制类型转换；可读性更好，能体现程序员的意图。 122、成员函数里memset(this, 0, sizeof(*this))会发生什么？ 有时候类里面定义了很多int, char, struct等C语言里的那些类型的变量，习惯在构造函数中都初始化为0，可以使用该语句全部置为0.对于这种情况可以很好的工作，但也有例外情况 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数表的调用都将出现异常 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，这样做就破坏了list对象的内存 123、回调函数？作用？ 当发生某种事件时，系统或其他函数将会自动调用程序员定义的一段函数。 回调函数就相当于一个中断处理函数，由系统在符合设定的条件时自动调用。为此，应当做三件事： 声明 定义 设置触发条件，即在函数中把回调函数名称转化为地址作为一个参数，以便系统调用。 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们称之为回调函数。 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需要知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值int）的被调用函数。 124、一致性哈希一致性哈希 一致性哈希是一种哈希算法，就是在移除或增加一个结点时，能使尽可能小的改变已存在key的映射关系。 尽可能少地改变已有的映射关系，一般是沿着顺时针进行操作，回答之前可以想想，真实情况如何处理 一致性哈希将整个哈希值空间组织成一个虚拟的圆环，假设哈希的值空间为 0~2^32-1，整个哈希环如图所示 一致性哈希的基本思想就是使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中，上右图显示了4个数据object1-4在环上的分布图 结点和数据映射 假设有一批服务器，可以根据IP或者主机名作为关键字进行哈希，根据结果映射到哈希环中，3台服务器分别是nodeA-C 现在有一批数据Object1-4需要存在服务器上，则可以使用相同的哈希算法对数据进行哈希，其结果必然也在环上，也可以沿着顺时针方向寻找，找到一个节点（服务器）就将数据存在该结点上，这样数据和结点就产生了一对一的关联，如下图所示： 移除结点 如果一台服务器出现问题，如上图的nodeB，则受影响的是其逆时针方向至下一个结点之间的数据，只需将这些数据映射到它顺时针方向的第一个结点上即可。如下左图： 添加结点 如果新增一台服务器nodeD，受影响的是其逆时针方向至下一个结点之间的数据，将这些数据映射到nodeD上即可，如上右图 虚拟结点 假设仅有两台服务器：nodeA和nodeC，nodeA映射了1条数据，nodeC映射了3条，这样数据分布是不平衡的。 引入虚拟结点，假设结点复制个数为2，则nodeA变成：nodeA1 和 nodeA2，nodeC变成：nodeC1 和 nodeC2，映射情况如下： 这样数据分布均衡，平衡性提高125、C++从代码到可执行程序经历了什么？ 预编译 主要处理源代码文件中的以”#”开头的预编译指令。处理规则如下： 删除所有的#define 展开所有宏定义 处理所有的条件预编译指令，如”#if”、”#endif”、”#ifdef”、”#elif”、”#else” 处理”#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中可能包含其他文件。 删除所有的注释，”&#x2F;&#x2F;“和”&#x2F;**&#x2F;“ 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once是为了防止有文件被重复引用 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时显示行号 编译 把预编译之后生成的xxx.i 或 xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。 语法分析：语法分析对由扫描器产生的记号进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为结点的树。 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断， 其分析的语义是静态语义 —— 在编译器能分清的语义，相对应的动态语义是在运行期才能确定的语义。 优化：源代码级别的一个优化过程。 目标代码生成：由代码生成器将中间代码转化成目标机器代码，生成一系列的代码序列 —— 汇编语言表示。 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。 汇编 将汇编代码转变成机器可以执行的指令（机器码文件）。 汇编器的编译过程相对于编译器来说更简单，没有复杂的语法和语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来， 汇编过程由汇编器完成。经汇编之后，产生目标文件（与可执行文件格式几乎一样）xxx.o（Windows下）、xxx.obj（Linux下） 链接 将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接可以分为静态链接和动态链接： 静态链接 函数和数据被编译进一个二进制文件。 在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制只写函数和数据并把它们和应用程序的其他模块组合起来创建最终可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本， 所以如果多个程序对同一个目标文件都有依赖性，会出现同一个目标文件都在内存存在多个副本 更新困难：每当库函数的代码修改，这时就要重新进行编译链接形成可执行程序。 运行速度快：静态链接的优点就是在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 动态链接 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序 而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享一个副本。 更新方便：更新时只需要替换掉原来的目标文件，而无需将所有程序重新链接一遍。 当程序下一次运行时，新版本的目标文件会被自动加载到内存并链接起来，程序就完成了升级的目标。 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 126、友元函数？因为编译器必须能读取到这个结构的声明以理解这个数据类型的大小、行为等方面的所有规则。 而谁能访问private部分在任何关系中都很重要。 补充：友元函数不一定要在类内声明，普通友元函数可以在类外声明 只有友元工厂必须用到类内声明友元函数。 127、友元函数和友元类的基本情况友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的陨星效率，但友元机制本身也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。 友元函数 友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。 友元函数举例 一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。 友元类友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员） 但是另一个类里面也要相应地进行声明 友元类例子 使用友元类时注意： 友元关系不能被继承。 友元关系是单向的，不具有交互性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明 友元关系不具有传递性，若类B是类A的友元，类C是类B的友元，则类C不一定是类A的友元，要看类中是否有对应声明 128、使用C语言实现C++的继承 C语言实现C++继承 129、动态编译和静态编译 静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不依赖动态链接库 动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。优点： 缩小了执行文件本身的体积 加快了编译速度，节省系统资源。缺点： 哪怕很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库 如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。 130、hello.c程序的编译过程 例子程序 在Unix系统上，编译器将源文件转换为目标文件。 过程如下： 预处理阶段：处理以#开头的预处理命令； 编译阶段：翻译成汇编文件 汇编阶段：将汇编文件翻译成可重定位目标文件； 链接阶段：将可重定位目标文件和printf.o等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。 静态链接： 静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件为输出。连接器主要完成以下两个任务： 符号解析：每个符号对应一个函数、全局变量或一个静态变量，符号解析的目的是将每个符号引用于一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得他们指向这个内存位置。 目标文件： 可执行目标文件： 可以直接在内存中执行； 可重定位目标文件：可与其他可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载到内存并链接； 动态连接： 静态库有以下两个问题：1. 当静态库更新时那么整个程序都要重新进行链接2. 对于printf这种标准函数库，如果每个程序都要有代码，则会极大浪费资源 共享库就是为了解决静态库的这两个问题设计的，在Linux系统中通常会用.so后缀来表示，Windows系统上它们被称为DLL。 共享库具有以下特点：1. 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；2. 在内存中，一个共享库的.text节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。 131、源代码 -&gt; 预处理 -&gt; 编译 -&gt; 优化 -&gt; 汇编 -&gt; 链接 -&gt; 可执行文件 预处理读取C源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的C++文件。 编译阶段编译程序所要作的工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则后，将其翻译成等价的中间代码表示或汇编代码.s文件。 汇编过程汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码.o文件 链接阶段链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义链接起来。使得所有的这些目标文件称为一个能够被操作系统装入执行的统一整体。 132、经典的锁 读写锁 多个读者可以同时进行读 写者必须互斥（只允许一个写者写，不能读者写者同时进行） 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者） 互斥锁 一次只能一个线程拥有互斥锁，其他线程只有等待 互斥锁是在抢所失败的情况下主动放弃CPU进入睡眠状态，直到锁的状态改变时再唤醒，操作系统负责线程调度 为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文切换。 互斥锁实际的效率还是可以让人接受的，加锁时间大概100ns左右，实际上互斥锁的一种可能实现是自旋一段时间，当自旋的时间超过阈值后将线程投入睡眠， 因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。 条件变量 互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。 条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。 当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。 一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。 总的来说互斥锁是线程间互斥机制，条件变量是同步机制。 自旋锁 如果进线程无法取得锁，进线程不会立即放弃CPU时间片，而是一直循环尝试获取锁，知道获取为止。 如果别的线程长时间占有锁，则自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率较高。 133、delete和delete[]的区别？ delete只会调用一次析构函数 delete[]会调用数组中每个元素的析构函数 134、为什么不能把所有的函数写成内联？内联函数以代码复杂为代价，省去函数调用的开销提高执行效率。 一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大意义；另一方面，每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不适合内联函数： 函数体内代码较长，将导致内存消耗代价 函数体内有循环，函数执行时间要比函数调用开销大 135、为什么C++没有垃圾回收机制？首先，实现一个垃圾回收器会带来额外的空间和时间开销。需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲时间进行free 垃圾回收会使得C++不适合进行很多很底层的操作"},{"title":"courseraWED","date":"2022-03-01T09:52:50.000Z","url":"/2022/03/01/courseraWED/","categories":[["undefined",""]],"content":"一、Introductionsizex -&gt; neuron -&gt; pricey - What does the simplest neural network do?It inputs the size, computes the linear function, take max of zero【最小值为0】, and then outputs the estimated price. This middle layer densely connected to the input layer, the network itself decides what the middle neuron refers to.What you need to do is trying to take an input a X and map it some output Y. - ReLU function —— A kind of activation functionRectified Linear Unit 【线性修正单元】The function is a straight line which taking a max of zero.Rectify just means taking a max of zero. - Supervised learning Real Estate&#x2F;Online Advertising: Standard NN Image application: Convolutional Neural Network【abbreviated: CNN】 Sequence Data(One-dimensional)【Audio&#x2F;language】: Recurrent Neural Network【abbreviated: RNN】 Complex Application【autonomous driving】: Custom&#x2F;Hybrid【混合】 - Unstructured&#x2F;Structured Data Structured data: Each of the features have the well defined meaning.【Just like database】 Unstructured data: Like audio&#x2F;images&#x2F;text - Scale drives deep learning progress Size of the NN. A NN with a lot of hidden units&#x2F;parameters&#x2F;connections Large amount of the 【labeled】 data. m, denote the size of training sets. NOTICE: If using smaller training sets, the relative ordering of the algorithms is not well defined so. Switching the sigmoid function to the ReLU function has made the algorithm called gradient descent work much faster.The impact of the algorithmic innovation was it really help compution. 二、Basics of Neural Network Programming- Binary Classification Notations(x, y) —— x:Rnx — y:{0, 1}m【Training example】 —— {(x(1), y(1)) …… (x(m), y(m))}mtrain &#x3D; m —— mtest &#x3D; #test_examplesX —— Rnxm（matrix）—— X.shape &#x3D; (nx * m)Y —— R1m —— Y.shape &#x3D; (1, m) - Logistic Regression Given x, want y_hat = P(y=1|x)x &#x3D; RnxParameters: w &#x3D; Rnx, b &#x3D; ROutput【Just a try】: y_hat &#x3D; Sigmoid(wT * x + b)【The result may not in the range of 0 to 1】 - Logistic Regression Lost Function Notice the Optimization Problem that is convex【Prevent Local Optimum And Try to converge(close) to the Global Optimum】 Loss Function: A single training example. —— Measure how well the network is doing.Cost Function: Entire training example. —— Cost of the parameters.【minimize it】 - Gradient DescentWant to find (w, b) that minimize J(w, b)【The cost function】 The formula of Gradient Descent is as follow: - Computation GraphThe computation graph organizes a computation with blue arrow left to right computation. We should handle the red arrow right to left computation of the derivatives. Cross Entropy: -(ylog(a) + (1-y)log(1-a)) where y is the ground_truth and a is the output of the network - logistic regressionThe goal is to modify the parameter w,b and to reduce the loss L(a, y)Using Computation Graph, and from output to the parameters, calculate the derivative of the loss function【Cross Entropy】 logistic regression on m examplesNotice the right part means the gradient descent, w1 :&#x3D; w1 - α * dw1, where α is the learning rate and dw1 is the derivative In order to getting rid of for loops, it’s perferable to use vectorization - vectorizationFor example, in Python with numpynp.dot(w, b)【dot即点乘】 Using vectorization can significantly speed up the code rather than using for loop. Avoid using explicit for loops - More examples of vectorization - Regression of logistic recap：the forward propagation step is to compute the predictions. the backward propagation step is using the result of prediction to modify the parameters. A vectorization implementation of the forward propagation for all M training examples at the same time. Actually, we can use vectorization to calculate the backward propagation to compute the gradients. - Vectorizing Logistic Regression - Broadcasting in Pythoncal &#x3D; A.sum(axis &#x3D; 0) 【0 means sum vertically, where horizontal axis is 1】percentage &#x3D; 100 * A &#x2F; cal.reshape(1, 4)【(3, 4) &#x2F; (1, 4)】 - Tips in Python rank 1 array —— Don’t usea &#x3D; np.random.randn(5)a.shape &#x3D; (5, ) Using reshape can transfer the rank_1 array to the vector column&#x2F;row vectora &#x3D; np.random.randn(5, 1) —— a.shape &#x3D; (5, 1) —— column vectora &#x3D; np.random.randn(1, 5) —— a.shape &#x3D; (1, 5) —— row vector assertionassert(a.shape &#x3D;&#x3D; (5, 1)) - Cost on m ExamplesUsing the principle of maximum likelihood estimation The log function is strict monotonically increasing functionSo maximum log(p) give the similar result that optimizing p. - Neural network represents - Vectorizing across multiple examplesThe horizontal, the matrix A goes over different training examplesVertically, the different indices in the matrix.【Different input features or Different hidden units】 - Activation functionstanh function is always do better than sigmoid function The result of tanh function is in the range of [-1, 1] Though the output is in the range of [0, 1], so sigmoid function is better for the output layer. The general setback of tanh&#x2F;sigmoid function is that when z is either very large or very small, the gradient of the derivative or the slope of this function becomes small.In this way, the result will slow down the gradient descent. A popular function is ReLU, Rectified Linear Unit. ReLU = max(0, z)The derivative of ReLU is 1 so long as z is positive, the slope is 0 when z is negative The odds you get exactly z equals to 0 is very small.【The derivative in the point of zero is not defined】 Also we can try Leaky ReLU —— Leaky ReLU = max(0.01z, z) - Why using the activation functionIf using linear activation functions or identity activation functionsthen the neural network is just outputting a linear function of the input If we do not use the activation function, what we do is just computing a linear activation function.In that case…Why not delete all the hidden layers? The linear hidden units is so long as not use them, they are less or more useless. The only place we can use linear function is the output layer【house pricing prediction】【Why not ReLU?】 - Sigmoid activation function - Tanh activation function - ReLU and Leaky ReLU activation function We can define the derivative of point 0 by ourselves."},{"title":"操作系统","date":"2022-02-28T11:44:08.000Z","url":"/2022/02/28/OperatingSystem/","categories":[["undefined",""]],"content":"一、进程-线程-协程1、进程、线程和协程的区别和联系 进程 线程 协程 定义 资源分配和拥有的基本单位 程序执行的基本单位 用户态的轻量级线程，线程内部调度的基本单位 切换情况 进程CPU环境（栈、寄存器、页表和文件句柄等）的保存以及新调度CPU环境设置 保存和设置程序计数器、少量寄存器和栈的内容 先将寄存器上下文和栈保存，等切换回来时进行恢复 切换者 操作系统 操作系统 用户 切换过程 用户-&gt;内核-&gt;用户 用户-&gt;内核-&gt;用户 用户（不陷入内核态） 调用栈 内核栈 内核栈 用户栈 拥有资源 CPU资源、内存、文件、句柄等 PC、寄存器、栈和状态字 自己的寄存器上下文和栈 并发性 不同进程之间切换实现并发，各自占有CPU实现并行 一个进程内部多个线程并发执行 同一时间只能运行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 系统开销 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 切换时只需保存和设置少量寄存器内容，开销很小 直接操作栈，则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 通信方面 进程间通信需要借助操作系统 线程间可以直接读写进程数据段（如全局变量）来进行通信 共享内存、消息队列 进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序【动态和静态】 线程是程序执行的基本单位，是轻量级的进程。每个进程都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。 协程是用户态的轻量级线程，线程内部调度的基本单位 2、线程和新城的比较 线程启动速度快，轻量级 线程的系统开销小 线程使用有一定难度，需要处理数据一致性问题【需要用到线程通信】 同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈 3、一个进程可以创建出多少线程，和什么有关？理论上，一个进程可用虚拟空间是 2G，默认情况下，线程栈大小是1MB，理论上可以创建2048个线程，如果要多余2048，则必须修改编译器设置。因此，一个进程可以创建的线程数由可用虚拟空间和线程栈大小共同决定，只要虚拟空间足够，则新线程的建立就会成功。按照上述限制，如果要创建超过2K个线程，减少线程栈即可。 过多的线程会导致大量时间浪费在线程切换上，给程序运行效率带来负面影响。 4、外中断和异常区别外中断：由CPU执行指令以外的事件引起，如I&#x2F;O完成中断、时钟中断、控制台中断等。（I&#x2F;O完成意味着处理器可以进行别的I&#x2F;O操作）异常：由CPU执行指令时的一些事件引起，如非法操作码、除0、地址越界、算术溢出、缺页等。 5、进程线程模型"},{"title":"LeetCode-Tips","date":"2022-02-26T10:45:43.000Z","url":"/2022/02/26/LeetCode-Tips/","categories":[["undefined",""]],"content":"一、数据结构小Tips 使用虚拟头指针Dummy 优先队列排序O(nlogn)，快速得到最小节点，LeetCode-P23 优先队列排序——大根堆 可以将一个大问题分为若干个小问题逐个解决，例如：翻转链表（递归写法）然而，递归一般而言复杂度不必迭代好。 本质上，链表也有前序遍历和后序遍历，参考判断回文链表事实上，二叉树又称为二叉链表，因此就有前序遍历和后序遍历类似的说法逆序打印链表：递归写法，后续遍历链表即可。 二叉树题目的递归解法：遍历一遍二叉树【回溯算法】、分解问题计算出答案【动态规划】例如：二叉树高度的动态规划解法：要算出二叉树的高度，要先计算出左右子树的高度，将最大高度+1即可换言之，如果题目要求子树的信息，则一般需要使用后续遍历算法。 二叉树的核心代码也就，前、中、后序遍历，不要把问题想的太复杂，而且二叉树也不一定对称。细化二叉树问题，例如连接节点问题：将每一层二叉树节点连接起来细化为：将每两个相邻节点连接起来 实际上，二叉树的递归也可以使用栈改写【递归的实现本质上是栈的实现过程】 如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。 BST代码框架 BST增删改查可以试着套用模板 二、DP小Tips 【重叠子问题】、【最优子结构】、【状态转移方程】 其中：最优子结构的子问题必须独立。 题目套路： 明确 base case 明确【状态】 明确【选择】 定义 dp 数组&#x2F;函数的含义 自顶向下递归求解f(20)-&gt;f(1)、自底向上递推求解f(1)-&gt;f(20)【常见】。 动态规划的关键：写出状态转移方程。【即暴力解】因此，写出暴力解，优化方法只有备忘录、DP Table。 例如，想求amount &#x3D; 11的最优解，只需要求出 amount &#x3D; 10的最优解 +1 即可 动态规划的核心思想是第一类数学归纳法。 能求最值的大部分有最优子结构特性，但最优子结构作为DP的必要条件，一定是要求最值的 反过来说，恶心人的最值题，往DP想 从Base Case向后推导，从前往后链式推导以满足性质。 "},{"title":"dp","date":"2022-02-25T12:35:14.000Z","url":"/2022/02/25/dp/","tags":[["动态规划","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"categories":[["undefined",""]],"content":"1、洛谷P1434-滑雪- 题目大意 只能从高滑到低，想知道一个最长的滑坡 - 示例 5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 output : 25 - 代码 - 注意事项 注意边界条件 dfs + dp 2、洛谷P2196-挖地雷- 题目描述 从任一处开始挖地雷，只能选择一条路径往下挖n个地点，之后n-1行是是否连通 - 示例 - 代码 - 注意事项3、力扣P95-不同的二叉搜索树- 题目大意 给一个整数，求恰由n个节点且结点值从1-n互不相同的二叉搜索树有多少种？ - 示例 - 代码 - 注意事项一个结点的左右子树都可以继续再分，所以可以推出状态转移方程。 4、力扣P96-不同的二叉搜索树（二）- 题目大意 给出一个整数 n，生成并返回结点值从 1-n 的二叉搜索树 - 示例 - 代码 - 注意事项可以细分左右子树，注意 nullptr 的使用"},{"title":"计算机网络","date":"2022-02-25T05:52:45.000Z","url":"/2022/02/25/network/","tags":[["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["undefined",""]],"content":"计算机网络1、OSI七层模型、功能 物理层：物理标准【比特】 数据链路层：定义数据的基本格式，如何传输，如何标识【帧】 网络层：IP、分组转发【包】 传输层：TCP、UDP，端到端传输【数据段】 会话层：控制应用程序之间会话 表示层：数据格式标识 应用层：各种应用软件 2、完整的HTTP请求： 域名解析； TCP的3次握手 建立TCP后的http请求 服务器响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器进行渲染 3、DNS【域名系统】域名和IP映射，不必记住目标地址的IP，而是可以记助记符4、DNS工作原理主机转换为IP地址，应用层协议，UDP传输 过程： 当用户输入域名时，浏览器先检查自己的缓存是否有这个域名映射的IP地址，有则解析结束 若未命中，则检查操作系统缓存有无解析过的过程（hosts），有则解析结束 若未命中，则请求本地域名服务器解析（LDNS - local DNS） 若未命中，则跳到根域名服务器请求解析。根域名服务器返回给LDNS一个主域名服务器地址 LDNS发送请求给上一步返回的gTLD（通用顶级域），接受请求的gTLD查找并返回这个域名对应的Name Server地址 Name Server根据映射关系表找到目标ip，返回给LDNS LDNS缓存这个域名和对应的IP，把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，过程结束 总结：浏览器缓存、系统缓存、路由器缓存、ISP服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存主机向本地域名服务器的查询一般都是递归查询本地域名服务器向根域名服务器的查询一般迭代查询 5、为什么域名解析用UDP因为若基于TCP的话，需要三次握手，发送数据以及应答，四次挥手。UDP相比而言快很多，一个请求、应答即可，同时UDP传输内容不超过512字节，一般DNS请求内容也不会太大。 6、区域传送使用TCP协议？TCP协议可靠性好，能够保证数据按序到达和无差错（包括下面几层的功劳）同时TCP能够传输大于512字节的内容，不同于UDP 7、HTTP长连接和短连接的区别在HTTP&#x2F;1.0中默认使用短连接。即客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。 从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。8、TCP粘包&#x2F;拆包？发生原因？一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据报发送，这个就是TCP的拆包和粘包问题。【应用层从TCP缓冲区读取数据无法确定发生方的发送边界】 原因： 应用程序写入数据的字节大小大于套接字发送缓存区的大小 进行MSS大小的TCP分段。（MSS &#x3D; TCP报文段长度 - TCP首部长度） 以太网的payload大于MTU进行IP分片（MTU：最大传输单元） 解决方案：【解决分界问题】 消息定长 在包尾部增加回车或者空格等特殊字符进行分割 将消息分为消息头和消息尾 使用其他复杂的协议，如RTMP协议。 9、为什么服务器会缓存功能？如何实现？原因： 缓解服务器压力 降低客户端获得资源的延迟：缓存通常位于内存中，读取缓存的速度更快。 缓存服务器在地理位置可能比原服务器更近，例如Browser Cache 实现方法： 让代理服务器进行缓存 让客户端浏览器进行缓存 10、HTTP请求方法？客户端发送的请求报文第一行为请求行，包含了方法字段 根据HTTP标准，HTTP请求可以使用多种方法 HTTP1.0 定义了三种请求方法：GET，POST和HEAD方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUTS、PATCH、DELETE、TRACE和CONNECT方法。 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体 2 HEAD 类似于GET请求，不过返回的响应中没有具体内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据被包含在请求体中，POST请求可能会导致新资源建立&#x2F;已有资源修改 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容 5 DELETE 请求服务器删除指定的页面 6 CONNECT HTTP&#x2F;1.1协议中预留给能将连接改为管道方式的代理服务器 7 OPTIONS 允许客户端查看服务器性能 8 TRACE 回显服务器收到的请求，主要用于测试或诊断 9 PATCH 是对PUT方法的补充，用来对已知资源进行局部更新 11、GET和POST的请求 get是获取数据post是修改数据 get把请求的数据放在url上，以?分割URL和传输，参数之间以&amp;相连，因此get不安全。post把数据放在HTTP的包体内（request body） get提交的数据最大是2k（限制实际上取决于浏览器）post理论上无限制 get产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）post产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应 200 ok（返回数据） get请求会被浏览器主动缓存post不会，除非手动设置 get是幂等的post不是幂等的（本质区别） 幂等性：一次和多次请求某一个资源应该具有同样的副作用，简单说意味着同一URL的多个请求返回同样结果。 因为上述区别：不应该也不能用get请求做数据的增删改这些有副作用的操作。由于get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，这种重复操作可能会导致副作用。（浏览器和操作系统不知道你用get请求增操作） 12、一个TCP连接可以对应几个HTTP请求？如果长连接，一个TCP连接是可以对应多个HTTP请求的。13、一个TCP连接中HTTP请求发送可以一起发送吗（如一起发送三个请求，在一起接受）？HTTP&#x2F;1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求即：两个请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠 在HTTP&#x2F;1.1存在Pipelining技术可以完成多个请求同时发送，但浏览器默认关闭，所以认为不可行。HTTP2中由于Multiplexing特点的存在，多个HTTP请求可以在同一个TCP连接中并行进行。 HTTP&#x2F;1.1中默认不行，实际可以开启HTTP&#x2F;2中可以 则在HTTP&#x2F;1.1时代，如何提高页面加载效率？ 维持和服务器已经建立的TCP连接，在同一连接上顺序处理多个请求。 和服务器建立多个TCP连接 14、浏览器对同一 Host 建立TCP连接到的数量有没有限制？假设HTTP&#x2F;1.1时代，没有多路传输，若接受到一个有几十张图片的网页如何处理？ 只开一个TCP很慢，每个图片一个TCP电脑和服务器都接受不了。 限制：有Chrome 最多允许对同一个Host建立六个TCP连接，不同的浏览器有一些区别。 如果图片都是HTTPS连接并且在同一个域名下，那么浏览器在SSL握手之后会和服务器商量能否使用HTTP2若能，则用Multiplexing功能进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个TCP去获取，但可以确定的是Multiplexing很可能会被用到。 如果用不了HTTP2或者HTTPS（HTTP2在HTTPS基础上实现） 则浏览器会在一个HOST上建立多个TCP连接，连接数量的最大限制取决于浏览器设置。这些连接会在空闲时被浏览器用来发送新的请求，若所有连接都在发送请求，则其他只能等待。 15、在浏览器中输入URL地址后显示主页的过程？ 根据域名，进行DNS解析。 拿到解析的IP地址，建立TCP连接。 向IP地址发送HTTP请求 服务器处理 返回结果 关闭TCP连接 浏览器解析HTML 浏览器渲染 16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？ 浏览器缓存 本机host 调用API，Linux下Socket函数 gethostbyname 向DNS服务器发送DNS请求，UPD协议 若在子网内，则用ARP地址解析协议进行查询，若不在一个子网内，则要对默认网关进行DNS查询，而且要一直向上找DNS服务器 若此时有服务器IP地址即默认端口号，http（80）、https（443）,则先尝试http然后调用Socket建立TCP连接 三次握手成功建立连接后，开始传送数据，若是http协议，则返回 若不是http协议，服务器会返回一个5开头的重定向消息，但是https，IP不变端口号不同 —— 传输完毕后四次挥手 除了80-&gt;443，还会采用SSL加密技术保证传输数据安全性，保证数据传输过程不被修改或替换 三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验CA安全证书 确认无误后开始通信，服务器返回要访问网址的一些数据，再次过程中会将界面进行渲染，牵涉到ajax技术等。 17、DNS解析过程 若是chrome浏览器，先找有无缓存过的域名对应IP地址若有，则跳过DNS解析若没有，则找硬盘的hosts文件【Hosts文件也是域名对应一个IP】 若hosts文件没能获得对应ip地址，则会发送一个dns请求到本地dns服务器，本地dns服务器一般都是ISP提供。 主机向本地DNS服务器发送DNS请求，使用的是递归方式，本地DNS也会查询自己的缓存。 本地DNS服务器会向域服务器发送请求【迭代】 本地DNS向域名解析服务器发送请求，从而获得DNS-&gt;IP 18、DNS负载均衡用户足够多，每次请求都在同一台机器上，则机器随时可能宕机 负载均衡：在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同解析结果将客户端的访问引导到不同机器上去，使得不同客户端访问不同服务器，从而负载均衡。 负载率、地理位置作为考量指标 19、HTTPS和HTTP区别 http协议传输的数据都是未加密的，明文的，因此http协议传输隐私信息非常不安全https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全 https协议要用到ca申请证书，免费证书较少，一般要费用 http(80)和https(443)使用完全不同连接方式，端口也不同 20、什么是SSL&#x2F;TLS？SSL：安全套接字层，用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。 加密https的加密机制是一种共享秘钥加密和公开密钥加密并用的混合加密机制。TLS：安全传输层协议 SSL&#x2F;TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议和解密需要两个不同的秘钥，因此称为非对称加密 加密和解密都使用一个秘钥的对称加密：优点在于加密解密效率通常较高，https是基于非对称加密的，公钥公开。21、HTTPS如何保证数据传输安全，整体流程？（SSL如何工作保证安全） 客户端向服务器端发起SSL连接请求 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥 客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端 服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密 进行数据传输，服务器和客户端双方用共有的相同的对称秘钥对数据进行加密解密，可以保证数据在收发过程中的安全，即使第三方获得数据包也无法加密解密篡改等。 由于数字签名、摘要是证书方位非常关键的武器。“摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名” SSL&#x2F;TLS协议的基本思路是采用公钥加密法，即客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 补充：SSL&#x2F;TLS四次握手，现在TLS 1.2已经成为主流，使用ECDHE算法。 22、如何保证公钥不被篡改？将公钥放在数字证书中。只要证书可信，公钥就是可信的。 公钥加密计算量太大，如何减少耗用时间？每一次对话（session），客户端和服务器端都生成一个“对话秘钥”（Session key），用它加密信息。 由于“对话秘钥”是对称加密，所以运算速度非常快，服务器公钥只用于加密“对话秘钥”本身，即减少了加密运算的消耗时间。 客户端向服务器端索要并验证公钥 双方协商生成“对话秘钥”【以上两步，即“握手阶段”（handshake）】 双方采用“对话秘钥”进行加密通信 23、HTTP请求和响应报文有哪些字段？ 请求报文： 请求行 ： Request Line 请求头 ： Request Headers 请求体 ： Request Body 响应报文： 状态行 ： Status Line 响应头 ： Response Headers 响应体 ： Response Body 24、Cookie是什么HTTP协议是无状态的，主要是为了让HTTPS协议尽可能简单，时期能处理大量事物HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发送请求时被携带上，用于告知服务端两个请求是否来自统一浏览器。由于之后每次请求都会需要携带Cookie数据，因此会带来额外性能开销（特别移动环境下） Cookie 曾一度用于客户端数据的存储，因为当时并没有其他合适的存储办法而作为唯一的存储手段，但技术更新的背景下，Cookie逐渐被淘汰。 新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或IndexedDB 由于HTTP无状态，服务器不知道你之前的信息，让你再次发送请求时，服务器能通过Cookie认识你 Cookie 可认为是一种【变量】，形如name &#x3D; value，存储在浏览器Session 可认为是一种【数据结构-映射】（键值对），存储在服务器 25、Cookie用途？ 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 26、Session知识总结 Cookie 可以将用户信息存储在用户浏览器中Session 可以将用户信息存储在客户端（更加安全） Session可以存储在服务器上的文件、数据库或内存中。可以将Session存储在Redis这种内存性数据库中，效率更高。 使用Session维护用户登录状态过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入HTTP请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到Redis中，它在Redis中的Key称为Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个Session ID，客户端收到响应报文后将该Cookie存入浏览器中。 客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到之后提取出Session ID，从Redis中取出用户信息，继续之前的业务操作。 注意，Session ID的安全性问题，有时候要重新生成，或者重新验证等。 27、Session 的工作原理？客户端登录完成后，服务器创建对应的session，session创建完后，会把Session ID发送给客户端，客户端再存储到浏览器中 客户端每次访问服务器时都带着Session ID，服务器拿到Session ID后，在内存中找到对应Session即可28、Cookie和Session的对比HTTP作为无状态协议，必然需要存在某种方式保持连接状态。简要介绍Cookie和Session Cookie：Cookie是客户端保持状态的方法 Cookie简单的理解即：存储由服务器发往客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在相应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到之后保存这个字符串，下次请求带上Cookie就可以被识别 除此之外，Cookie在客户端的保存形式可以有： 会话Cookie：将服务器返回的Cookie字符串保存在内存中，关闭浏览器之后自动销毁 持久Cookie：存储在客户端磁盘上，有效时间在服务器响应头中被指定，有效期内，客户端再次请求服务器时直接从本地取出。 存储在磁盘中的Cookie是可以被多个浏览器代理共享的。 SessionSession是服务器保持状态的方法 Session保存在服务器上，可以在数据库、文件或内存中每个用户有独立的Session用户，其在客户端上记录用户的操作。 理解为：每个用户有独一无二个Session ID作为Session文件的Hash键，通过该值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为 当服务器需要识别客户端时，需要结合Cookie。每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。实际上大多数应用都是可以用Cookie来实现Session跟踪的 第一次创建Session时，服务端会在HTTP协议中高速客户端，需要Set-Cookie记录一个Session ID 然后每次请求会把这个Session ID发送到服务器，服务器就能识别客户 如果客户端浏览器禁用了Cookie，会使用一种叫做URL重写的技术进行会话跟踪 即每次HTTP交互，URL后面都会被附加上一个例如：Sid &#x3D; xxxx 的参数，服务器以此来识别用户，可以帮用户完成注入用户信息自动填入等操作。 29、SQL注入攻击？攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行 防范SQL注入攻击 —— 使用预编译的PrepareStatementWeb端： 有效性检验 限制字符串输入长度 服务端： 不用拼接SQL字符串 使用预编译的PrepareStatement 有效性检验（服务端有效性检验：第一准则，外部都是不可信的，防止攻击者绕过Web端请求） 过滤SQL需要的参数中的特殊字符，比如单引号、双引号 30、网络的七层模型和各自功能略31、什么是RARP？工作原理概括：反向地址转换协议，网络层协议ARP：从IP地址返回物理地址RARP：从物理地址返回IP地址 —— 应答包括能提供所需信息的RARP服务器发出的IP地址。 原理： 网络上的每台设备都有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址 RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机 PC1收到RARP回应后，就使用得到的IP地址进行通讯。 32、端口有效范围？0-1023是知名端口号，其中HTTP是80，FTP是20（数据端口）、21（控制端口） UDP和TCP报头使用两个字节存放端口号，所以端口号有效范围是0-65536.动态端口的范围是1024-65535 33、为何要将TCP&#x2F;IP协议栈分层？ARPANET的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次性的。分层好处： 各层之间独立 灵活性好 结构上可以分开 易于实现和维护 能促进标准化工作 34、DNS查询方式？ 递归查询 迭代查询 35、HTTP中缓存的私有和公有字段？private指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。 public指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。 36、GET方法参数写法固定的吗？在约定中，参数写在?后面，用&amp;分割。 解析报文的过程是通过获取TCP数据，用正则等工具从数据中获取Header和Body，从而提取参数。 比如header请求头添加token，来验证用户是否登录等权限问题 即：我们可以自己约定参数的写法，只要服务端能解释出来即可37、GET方法的长度限制？网络上都会提到浏览器地址栏输入的参数是有限的。 虽然HTTP协议没有Body和URL的长度限制，对URL限制的大多是浏览器和服务器； 浏览器原因： 服务器原因：处理长URL要消耗较多资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。38、POST方法比GET方法安全？从传输角度而言，都不安全。因为HTTP在网络上都使明文传输的，只要在网络节点上抓包就可以截获报文。 想要安全传输，只有加密，即HTTPS39、POST方法产生两个TCP数据包？POST会将Header和Body分开发送，先发送header，服务端返回100状态码再发送body。 HTTP协议中没有明确说明POST会产生两个TCP数据包经过实际测试（Chrome）发现，header和body不会分开发送 综上所述：header和body分开发送是部分浏览器或框架的请求方法，不属于post必然行为。40、Session是什么？ —— 参见条目26略41、使用Session的过程 —— 参见条目26&#x2F;27略42、Session和Cookie应该如何选择（适用场景）？ Cookie 只能存储ASCII码字符串，而Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session； Cookie存储在浏览器，容易被恶意查看。如果非要将一些隐私数据存入Cookie中，可以将Cookie值进行加密，然后在服务器解密 对于大型网站，如果用户所有的信息都存储在Session中，那么开销非常大，因此不建议将所有用户的信息都存储到Session中。 43、Cookie和Session的区别？ Cookie和Session都是客户端与服务器之间保持状态的解决方案 存储的位置不同，cookie ： 存放在客户端session： 存放在服务端，Session存储的数据比较安全 存储的数据类型不同，两者都是key-value类型，但针对value的类型有差异cookie ： value只能是字符串类型session： value是Object类型 存储的数据大小限制不同，cookie ： 大小受浏览器限制，最多是4K大小session： 理论上受当前内存限制 生命周期的控制，cookie ： cookie的生命周期是累计的，从创建时开始计时，20分钟后，cookie生命周期结束session： session的生命周期是间隔的，从创建开始计时，如在20分钟没访问session，则生命周期被销毁 44、DDos攻击？客户端向服务器发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认没有彻底根治办法，除非不用TCP DDos预防： 限制同时打开SYN半链接的数目 缩短SYN半链接的Time out时间 关闭不必要的服务 45、MTU和MSS分别是什么？MTU：Maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。 MSS：Maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每分节中能发送的最大TCP数据。MSS值为MTU减去 IPv4 Header（20 Byte）和TCP header（20 Byte）得到。 46、HTTP中缓存机制，如何保证缓存最新？max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存 max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。 Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。 在 HTTP&#x2F;1.1中，会优先处理max-age指令 在 HTTP&#x2F;1.0中，max-age指令会被忽略掉 47、TCP头部中有哪些信息？ 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 &#x3D; ISN + 数据在整个字节流中的位移。假设 A-&gt;B 且ISN &#x3D; 1024，第一段数据512字节已经到B，则第二端数据发送时序号为1024+512。用于解决网络包乱序问题。 确认号（32bit）：接收方对发送方TCP报文段响应，其值是收到的序号值 + 1。 首部长（4bit）：标识首部有多少个4字节*首部长，最大为15，即60字节。 标志位（6bit）： URG：紧急指针是否有效 ACK：确认号是否有效（确认报文段），解决丢包问题 PSH：提示接收端立即从缓冲读走数据 RST：标识要求对方重新建立连接（复位报文段）。 SYN：标识请求建立一个连接（连接报文段）。 FIN：标识关闭连接（断开报文段）。 窗口（16bit）：接收窗口，用于告知对方（发送方）本方的缓冲还能接收多少字节数据，【流量控制】 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。 48、常见的TCP连接状态？ CLOSED：初始状态 LISTEN：服务器处于监听状态 SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态 SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。 ESTABLISH：表示连接建立。客户端发送了最后一个ACK包进入此状态，服务器接收到ACK包后进入此状态。 FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入，等待对方FIN。 CLOSE_WAIT：（假设服务器）接收到客户机FIN包后等待关闭的阶段，在接收到对方的FIN包之后，自然需要立即回复ACK包的，表示已经知道断开请求 但是本方是否立即断开（发送FIN包）取决于是否还有数据要发送给客户端，若有，则在发送FIN包之前均为此状态。【关闭之前发送完数据】 FIN_WAIT_2：此时是半链接状态，即有一方要求关闭连接，等待另一方关闭。 客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。 LAST_ACK：服务器发动最后的FIN包，等待最后的客户端ACK相应，进入此状态。 TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，再次之后的2MSL时间称为TIME_WAIT状态。 49、网络的七层&#x2F;五层协议有哪些？ 50、TCP？TCP（Transmission Control Protocol 传输控制协议）面向连接、可靠的、基于字节流的传输层通信协议。 51、TCP头部报文字段？各自功能？ 源端口和目的端口 source port ： 源端口号【本地端口】 destination port ： 目的端口号【远程端口】 扩展：应用程序所在主机的IP和应用程序的端口号统称为socket（套接字） —— IP:端口号在互联网上，是一个socket唯一标识一个应用程序源端口 + IP + 目的端口 + 目的IP 称为“套接字对”，一对套接字就是一个连接，一个客户端与服务器之间的连接 序列号 序列号。 用于TCP通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信有序性，避免网络中乱序问题。 接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。 初始序列号由自己定，后续的序列号由对端ACK决定：SN_x &#x3D; ACK_y（x的序列号 &#x3D; y发送给x的ACK） ACK确认序列号 确认序列号。 接收确认端期望收到的下一序列号。 确认序号应当是上次已成功收到的数据字节序号加1，只有当标志位中的ACK标志位1时，该确认序列号的字段才有效 解决不丢包问题。 TCP Flag TCP首部中有6个标志比特，他们中的多个可同时被设置为1，主要是用来控制TCP状态的 有：URG、ACK、PSH、RST、SYN、FIN ACK：理解为发送端发送数据到接收端，发送时ACK为0，标识接收端还未应答，一旦接收端接收数据之后，就将ACK置为1 发送端接收之后，就知道接收端已经接收到了数据。 SYN：表示【同步序列号】，是TCP握手发送的第一个数据包。用来建立TCP连接 SYN标志和ACK标志位搭配使用 当连接请求时，SYN &#x3D; 1, ACK &#x3D; 0 当连接相应时，SYN &#x3D; 1, ACK &#x3D; 1 这个标志的数据报经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明该主机存在端口 FIN：表示发送端已经达到数据末尾，也就是说双方数据传送完成，没有数据可以传送了 发送FIN标志位的TCP数据报后，连接将被断开。 这个标志位的数据报也经常被用于端口扫描。 发送端只剩最后一段数据了，同时要告诉接收端后面没有数据可以接受了，所以用FIN标识一下，接收端看到FIN后，接受完就关闭了 Windows Size 窗口大小 滑动窗口大小，用于流量控制 52、OSI的七层模型主要功能？ 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输 数据链路层：接收来自物理层的位流形式的数据，封装成帧 网络层：网络地址翻译成对应物理地址，通过路由选择算法为分组通过通信子网选择最适合路径【分组转发】 传输层：在源端和目的端之间提供可靠的透明数据传输【TCP&#x2F;UPD】 会话层：负责在网络中两节点之间建立、维持和终止通信【建立会话】 表示层：处理用户信息的表示问题，数据编码、压缩解压缩、数据的加密和解密 应用层：为用户的应用进程提供网络通信服务。 53、应用层常见协议？ 协议 名称 默认端口 底层协议 HTTP 超文本传输协议 80 TCP HTTPS 超文本传输安全协议 443 TCP Telnet 远程登录服务的标准协议 23 TCP FTP 文件传输协议 20传输、21连接 TCP TFTF 简单文件传输协议 69 UDP SMTP 简单邮件传输协议（发送用） 25 TCP POP 邮局协议（接收用） 110 TCP DNS 域名解析协议 53 服务器间进行域传输时候用TCP（更新信息）、客户端查询DNS时用UDP 54、浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？在 HTTP&#x2F;1.0 中，一个服务器在发送完一个HTTP响应后，会断开TCP链接。但这样每次请求都会重新建立和断开TCP链接，代价过大。 虽然标准中没有设定，某些服务器对Connection: keep-alive的Header进行了支持也即：完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接。好处是链接可以被重新使用，之后发送HTTP请求的时候不需要重新建立TCP连接，如果维持连接，SSL的开销也可避免。 持久连接：既然维持TCP连接好处那么多，HTTP&#x2F;1.1就把Connection头写进标准，并且默认开启持久连接，除非请求中声明Connection: close那么浏览器和服务器之间会维持一段时间的TCP连接，不会一个请求结束后就断掉 默认情况下建立TCP连接不会断开，只有在请求报头声明Connection: close才会在请求完成后关闭连接55、三次握手相关内容 三次握手，指建立一个TCP连接时，需要客户端和服务器总共发送三个包 SYN &#x3D; 1, seq &#x3D; client_seq SYN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; server_seq, ack &#x3D; client_seq + 1 ACK &#x3D; 1, seq &#x3D; client_seq + 1, ack &#x3D; server_seq + 1 进行三次握手的主要作用就是为了 确认双方的发送和接收能力是否正常 指定自己的初始化序列号为后面可靠性传输做准备 实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和交换号，交换TCP窗口大小信息。 初始状态：客户端处于closed(关闭)状态，服务器处于listen(监听)状态。第一次握手：客户端发送请求报文将SYN = 1, seq = x，同步序列号及初始化序列号发送给服务端 此后，客户端处于SYN_SEND状态（验证可客户端发送能力和服务器接收能力）第二次握手：服务器收到SYN确认报文之后，如果同意连接，会以自己的同步序列号SYN = 1, seq = y, ack = x + 1，即初始化序列号、确认号报文应答 此后，服务器处于SYN_RECEIVE状态（但是注意，此时客户端的发送能力得到确认，服务器发送和接收得到确认，但不知道客户端是否能接收）第三次握手：客户端接收到服务器的SYN + ACK之后，知道可以下次发送下一序列的数据包了，然后发送ACK = 1, seq = x + 1, ack = y + 1应答 此后客户端作为ESTABLISHED状态。（各自的发送和接受都OK） 56、为什么要三次握手，两次不行？需要弄明白三次握手的目的是什么，能不能只用两次握手达到同样目的 第一次握手：客户端发送数据包，服务器收到 —— 服务器得知：客户端发送能力、服务器接收能力正常。 第二次握手：服务器发送数据包，客户端收到 —— 客户端得知：客户端的发送、接收；服务器的发送、接收正常，但服务器不知道客户端的接收是否正常 第三次握手：客户端发送数据包，服务器收到 —— 服务器得知：客户端的发送、接收；服务器的发送、接收正常。 因此，需要三次握手才能确认双方的发送和接收能力是否正常若用两次握手，则可能： 客户端发送连接请求，但连接请求报文丢失未收到确认，于是客户端再重传一次连接请求，后来收到了确认，建立了连接。数据传输完毕后，释放了连接，客户端一共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务器 但第一个丢失的报文段只是在某些网络节点长时间滞留了，延误到连接释放以后的某个时间才到达服务器此时服务器误以为客户端又发出一次新的连接请求，于是向客户端发送确认报文段，同意建立连接。不采用三次握手，即服务器发送确认就相当于建立了新的连接，但客户端忽略了服务器的该请求，不发送数据服务器则一直等待客户端发送数据，浪费资源。 57、什么是半连接队列？服务器第一次收到客户端的SYN后，就会处于SYN_RCVD状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个队列里，该队列即半连接队列。 全连接队列：已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 补充一点关于SYN-ACK重传次数的问题：服务器发送完SYN-ACK包，如果未收到客户端确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意：每次等待时间不一定相同，一般指数增长，1&#x2F;2&#x2F;4&#x2F;8诸如此类 58、ISN（Initial Sequence Number）是固定的吗？当一端为建立连接而发送SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN，ISN可以看做是一个32bit的计数器，但不是简单计数器，大概每4ms加1。 ISN &#x3D; M + F（localhost, localport, remotehost, remoteport）（M为计数器），ISN应该由这个公式确定，F是哈希算法，不是简单计数器 这样选择序号的目的在于防止在网络上被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。 三次握手的其中一个重要功能是客户端和服务器交换ISN，以便让对方知道接下来收到数据时如何按照序列号组装数据若ISN固定，攻击者很容易猜出后续的序号，因此ISN要动态生成 59、三次握手过程可以携带数据吗？三次握手过程中，可以携带数据，但是，只有第三次才可以携带数据 为什么要这样？若第一次握手可以携带数据，若有人要恶意攻击服务器，则每次在第一次握手中的SYN报文中放入大量数据，就会让服务器花费很多资源去处理这些报文。 第一次握手中不可放入数据，否则会让服务器更加容易受到攻击。第三次握手中，客户端已经处于ESTABLISHED状态。对于客户端来说，已经建立起连接了，也知道服务器的发送、接受能力正常，所以可以携带。 60、SYN攻击？服务器端的资源分配是在第二次握手时分配的，客户端资源则是在第三次握手时分配的。因此服务器很容易受到SYN泛洪攻击 SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断发送SYN包，Server则回复确认包，等待Client确认由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因队满被丢弃，从而网络拥塞，系统瘫痪 SYN 攻击是一种典型的DoS&#x2F;DDoS攻击。 检测SYN攻击非常方便，但服务器上看到大量半连接状态时，特别源IP地址是随机的，基本上可以断定是SYN攻击。 在Linux&#x2F;Unix上可以使用系统自带的netstat命令检测SYN攻击。 常见的防御 SYN 攻击的方法： 缩短超时（SYN Timeout）时间 增加最大半连接数 过滤网关服务 SYN cookies技术 61、四次挥手相关内容 建立一个连接需要三次握手，终止一个连接需要四次挥手（或称四次握手）这由TCP的半关闭(half-close)造成的半关闭，即TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。 TCP的连接的拆除需要发送四个包，因此称为四次回收（Four-way handshake），客户端或服务器均可主动发起挥手动作。 初始状态：客户端和服务器都在ESTABLISHED（连接状态）下，接下来进行四次挥手断开连接操作。 第一次挥手：事实上，客户端和服务器都可以主动终止连接，此处假设客户端先终止链接。 客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。 即发送链接释放报文，FIN=1, seq = u，并停止再发送数据，主动关闭TCP链接，进入FIN_WAIT1（终止等待1）状态。 第二次挥手：服务器收到FIN之后，发送ACK报文，并把客户端序列号值+1作为ACK报文的ack值，表明收到，此时客户端处于CLOSE_WAIT状态 即发送确认报文段，ACK=1, seq = v, ack = u+1，服务端进入CLOSE_WAIT（关闭等待）状态 此时TCP处于半关闭状态 客户端到服务端的连接释放。客户端收到服务器的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务器发出的连接释放报文段 第三次挥手：服务器收到了客户端的连接释放请求，然而服务器可能还有未传输完毕的数据，则还需要发送消息，并主动断连 服务器也想断开连接，和客户端第一次挥手一样，发送FIN报文，且指定一个序列号，服务器进入LAST_ACK（最后确认）状态。 即服务端没有要向客户端发出的数据，服务器发出连接释放报文段，FIN=1, ACK=1, seq = w, ack = u+1 服务器进入LAST_ACK状态，等待客户端确认。 第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务器序列号值+1作为自己ACK报文的确认号，此时客户端处于TIME_WAIT状态 需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态（自己最后的ACK报文段可能出差错到不了服务器） 服务器收到ACK报文之后，就处于关闭连接了，即CLOSED状态。 即客户端收到服务器的链接释放报文后，向其发送确认报文段ACK = 1, seq = u + 1, ack = w + 1，客户端进入TIME_WAIT（时间等待）状态。 此时TCP未释放掉，要经过事件等待计时器设置的时间2MSL之后，客户端才进入CLOSED状态。 收到一个FIN只意味着在这一个方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。 在socket()编程中，任何一方执行close()操作即可产生挥手动作。62、挥手为什么要四次？因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。 但是关闭连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端“收到FIN请求” 但服务器也可能要发送自己的数据，只有当服务器数据也发送完毕，服务器才能发送FIN报文，因此不能一起发送，故四次挥手。63、2MSL等待状态？TIME_WAIT状态也称为2MSL等待状态 每个具体TCP必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据包在网络内传输，而IP数据包则有限制其生存时间的TTL字段。 对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留时间的2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN） 另一个结果：TCP连接在2MSL等待期间，定义这个连接的接口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。该连接只能在2MSL结束后才能再被使用。 防止自己的FIN_ACK丢失 可以阻塞其他该端口上的连接 64、四次挥手释放连接时，等待2MSL的意义？ MSL（Maximum Segment Lifetime）最长报文段寿命，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 为了保证客户端发送的最后一个ACK报文能到达服务器，因为这个ACK有可能丢失，从而导致处在LAST_ACK状态的服务器接收不到最后的FIN_ACK确认报文。服务器会超时重传这个FIN_ACK，接着客户端再重传一次确认，重新启动时间等待计时器。 最后客户端和服务器都能正常关闭，若服务器不等待2MSL，而是发送ACK后直接释放关闭，一旦这个ACK丢失，服务器无法正常进入关闭连接状态。 确保客户端发送的最后一个ACK能够到达服务器。该报文段可能丢失，使得LAST_ACK接收不到FIN_ACK报文段确认，服务器超时重传该FIN_ACK。若不等待，可能报文段丢失时再接到了FIN_ACK报文段确认。 防止“已经失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK后，经过2MSL，旧的报文段都会从网络中消失。新的连接中不会收到旧连接请求报文段。 阻塞其他该端口通信。 65、为什么TIME_WAIT状态要经过2MSL才能返回CLOSED状态？网络可能不可靠，TIME_WAIT状态用来重发可能丢失的最后一个ACK报文。 客户端给服务器发送的ACK &#x3D; 1丢失，服务器会再发一次，若客户端收到重发，说明之前的包丢失，要重启计时器，并在此发送确认请求。若接下来再无服务器信息，说明已收到确认，双方都关闭连接。 66、TCP粘包问题？如何解决？TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一个包从接收缓冲区来看，后一个数据包的数据头紧紧连着前一个数据包的数据尾 由TCP连接复用造成的粘包问题 因为TCP默认使用Nagle算法，此算法导致粘包问题。 只有上一个分组得到确认，才会发送下一个小组 收集多个小分组，在一个确认到来时一起发送 数据包过大造成的粘包问题。 流量控制，拥塞控制也可能导致粘包。 接收方不及时接收缓冲区的包，造成多个包接收 解决： Nagle算法问题导致的，要结合应用场景适当关闭该算法 尾部标记序列。通过特殊标识符表示数据边界，例如\\n\\t\\r或特殊字符 头部标记分步接收。在TCP报文头部加上表示数据长度。 应用层发送数据时定长发送 67、OSI七层模型表示层和会话层功能？ 表示层：图像、视频编码解码、数据加密。 会话层：建立会话，如Session认证、断点续传。 68、三次握手四次回收变迁图 69、对称秘钥加密的优点和缺点对称秘钥加密（Symmetric-Key Encryption），加密和解密使用同一秘钥 优点：运算速度快 缺点：无法安全地将秘钥传输给通信方 70、非对称秘钥加密的优缺点？非对称秘钥加密，即公开秘钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开秘钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开秘钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有秘钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断该签名是否正确。 71、HTTPS是什么？HTTPS不是新协议，是HTTP先和SSL（Secure Sockets Layer）通信，再由SSL和TCP通信，即HTTPS使用隧道进行通信通过使用SSL，HTTPS具有了加密性（防窃听）、认证（防伪装）和完整性保护（防篡改）。 72、HTTP缺点有哪些？ 使用明文进行通信，内容可能会被窃听 不验证通信方的身份，通信方的身份有可能遭遇伪装 无法证明报文的完整性，报文有可能遭篡改 73、HTTPS采用的加密方式有哪些？对称还是非对称？HTTPS采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性之后使用对称密钥加密进行通信来保证通信过程的效率。 非对称保证安全，对称保证效率 确保传输安全过程（其实就是rsa原理）： Client给出协议版本号、一个客户端生成的随机数（Client Random），以及客户端支持的加密算法。 Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server Random）。 Client确认数字证书有效，然后生成一个新的随机数（Premaster Secret），并使用数字证书中的公钥，加密这个随机数，发给Server Server使用自己的私钥，获取Client发来的随机数（Premaster Secret） Client和Server根据约定的加密方法，使用前面的三个随机数，生成“对话密钥”（Session Key），用来加密接下来的整个对话过程。 74、为什么有时候刷新页面不需要重新建立SSL连接？TCP连接有的时候会被浏览器和服务端维持一段时间TCP不需要重新建立，SSL自然也会用之前的。 75、SSL中的认证中的证书是什么？通过使用证书来对通信放进行认证。 数字证书认证机构（CA，Certficate Authority）是客户端和服务器双方都可信赖的第三方机构。 服务器的运营人员向CA提出公开密钥的申请，CA在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥整数后绑定在一起。 进行HTTPS通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以通信了。 76、HTTP如何禁用缓存？如何确认缓存？HTTP&#x2F;1.1 通过Cache-Control首部字段来控制缓存。 禁止进行缓存 no-store指令规定不能对请求或响应的任何一部分进行缓存。 强制确认缓存 no-cache指令规定缓存服务器需要先向源服务器验证缓存资源的有效性只有当缓存资源有效时才能使用该缓存对客户端的请求进行相应。 77、GET和POST传递数据的最大长度能达到多少？get 是通过URL提交数据，因此GET可提交的数据量就跟URL能达到的最大长度有直接关系。?和key:value 很多文章都说GET方式提交的数据最多只能是1024字节，实际上，URL不存在参数上限的问题，HTTP协议也没有对URL长度进行限制。然而，特定浏览器及服务器对URL有限制： IE对URL长度的限制是2083字节（2K+35字节）； 对于其他浏览器，如FireFox，Netscape等，没有长度限制，此时限制取决于服务器操作系统； 如果URL太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。 post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。 因为一般post的数据量很少超过MB，因此很少能感觉得到post的数据量限制但实际上如果上传文件过程中会发现这样的问题，即上传个头较大文件到服务器时，可能上传不上去。 以php语言来说，查原因的时候也许会看到说PHP上传文件涉及到的参数，PHP默认上传有限定，一般值是2MB更改这个值需要修改php.conf和post_max_size这个值。 78、网络层常见协议？ 协议 名称 作用 IP 网际协议 IP协议不但定义了数据传输时的基本单元和格式，还定义了数据包的递交方法和路由选择 ICMP Internet控制报文协议 ICMP就是一个“错误侦测和回报机制”，其目的就是让我们能够检测网络的连线状况，也能确保连线准确性，是ping和tracert的工作协议 RIP 路由信息协议 使用“跳数”（metric）来衡量到达目标地址的路由距离 IGMP Internet组管理协议 用于实现组播、广播等通信 79、TCP四大拥塞控制算法总结？（重要）四大算法拥塞控制主要是四个算法： 慢启动 拥塞控制 快重传 快恢复 慢启动 - Slow Start： 所谓慢启动，就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道秩序 连接建好时，初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。 每当收到一个ACK，cwnd大小加1，呈线性上升 每当过了一个往返延迟时间RTT（Round-Trip Time），cwnd大小直接翻倍，乘2，指数上升 还有一个ssthresh（Slow start threshold），是一个上线，当cwnd &gt;&#x3D; ssthresh时，就会进入拥塞避免算法 拥塞避免算法 - Congestion Avoidance 当拥塞窗口cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。 收到一个ACK，则cwnd &#x3D; cwnd + 1 &#x2F; cwnd 每当过了一个往返时延时间RTT，cwnd大小加1。【即收到一组之后cwnd才加】 过了慢启动阈值之后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢地增加调整到网络的最佳值。 拥塞发生状态时的算法 一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。 对于丢包有两种判定方式1. 超时重传RTO（Retransmission Timeout）超时2. 收到三个重复确认ACK 超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据包的ACK报文，那么就重发数据，直到发送成功为止 重复收到3个以上ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做快重传，而快速重传之后没有使用慢启动算法，而是拥塞避免算法，这个又叫做快恢复算法。 超出重传RTO（Retransmission Timeout）超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：* 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一般，即 ssthresh &#x3D; cwnd &#x2F; 2* cwnd 重置为1* 进入慢启动过程 最早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd重置为1，不利于网络数据的稳定传输。 所以TCP Reno算法进行了优化，当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，不用等到RTO超时再进行重传：* cwnd大小缩小为当前的一半* ssthresh设置为缩小后的cwnd大小（相当于ssthresh也缩小为一半）* 然后进入快速恢复算法Fast Recovery 快速恢复算法 - Fast Recovery TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。 在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。 快速恢复算法的逻辑如下：* cwnd &#x3D; cwnd + 3 MSS，加3 MSS的原因是因为受到三个重复的ACK* 重传DACKs指定的数据包* 如果再受到DACKs，则cwnd大小加1* 如果收到新的ACK，表明重传的包成功了，则退出快速恢复算法，将cwnd设置为ssthresh，然后进入拥塞避免算法。 如图所示，第五个包发生了丢失，所以导致接收方收到三次重复AK，也就是ACK5。 所以将ssthresh设置为当前cwnd的一半，也就是6&#x2F;2 &#x3D; 3，cwnd设置为3+3&#x3D;6，然后重传第五个包。 当收到新的ACK时，即ACK11，则退出快恢复阶段，将cwnd重新设置为当前的ssthresh，即3，然后进入拥塞避免算法阶段80、为何快速重传是选择3次ACK？主要的考虑还是要区分包的丢失是忧郁链路故障还是乱序等其他因素引发。 两次Duplicated ACK时很可能是乱序造成的。三次Duplicated ACK时很可能是丢包造成的。四次Duplicated ACK时更可能是丢包造成的，但四次重复ACK响应策略太慢。 丢包肯定会造成三次Duplicated ACK，综上所述，收到三个重复确认时窗口减半效果最好，是实践经验。 在没有快重传/快恢复算法之前，重传依靠发送方的retransit timeout，就是在timeout内如果没有接收到对方的ACK，默认丢包，发送方则重传包丢失的原因： 包checksum出错 网络拥塞 网络断，包括路由重收敛。 但是发送方无法判断是哪一种情况，于是采用最笨的方法，就是将自己的发送速率减半，即CWND减为1&#x2F;2这样的方法对2是有效的，可以缓解网络拥塞；3则无所谓，反正网络断了，无论发快发慢都会被丢；对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。 于是有了快恢复算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK如果在timeout时间内没有接收到&gt;2的Duplicated ACK，则大概率为乱序，乱序无序重传，接收方会进行排序工作。 而如果接收到三个或三个以上的Duplicated ACK，则大概率丢包，可以逻辑推理，发送方可以接收ACK，则网络可能是通的可能是1&#x2F;2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢） 而如果依然接收到Duplicated ACK，则认为是网络拥塞造成的，此时降速合理。81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？ FIN_WAIT_2: 半关闭状态 发送断开请求一方还有数据接收能力，但没有发送数据能力。 CLOSE_WAIT： 被动关闭连接一方收到FN包会立即返回ACK包表示已经收到断开请求。 被动关闭连接一方如果还有剩余数据要发送就进入CLOSE_WAIT状态。 TIME_WAIT状态： 也称2MSL等待状态 如果客户端直接进入CLOSED状态，如果服务器没有接收到最后一次ACK包，会在超时之后重新发送FIN包，因为客户端已经CLOSED，所以服务器就不会收到ACK而是RST。 因此，TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。 在2MSL时间内，同一个socket不能再被使用，否则可能会和旧连接数据混淆（如果新旧连接socket相同的话） 82、流量控制原理？ 目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。 TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗口和接收窗口 发送窗口：用来限制发送方可以发送的数据大小（应该是接收窗口和拥塞窗口最小值） 其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓存（受系统、硬件等限制）大小 接收窗口：用来标记可以接收的数据大小。 TCP是流数据，发送出去的数据流可以被分为以下四个部分： 已发送且被确认部分 已发送未被确认部分 未发送但可发送部分 不可发送部分 其中发送窗口 &#x3D; 已发送未确认 + 未发送但可发送部分。 接收到的数据流可分为： 已接收 未接收但准备接收 未接收不准备接收 其中接收窗口 &#x3D; 未接收但准备接收部分。 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗口，左边缘紧贴刚被确认的数据 接收窗口也只有接收到数据且最左侧连续时才移动接收窗口。 建立TCP服务器的各个系统调用的过程？ 服务器： 创建socket -&gt; int socket(int domain, int type, int protocol); domain：协议域，决定了socket的地址类型，IPv4为AF_INET type：指定socket类型，SOCK_STREAM为TCP连接 protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。 绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); sockfd：socket返回的套接字描述符，类似于文件描述符fd。 addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。 addrlen：地址长度 监听端口号 -&gt; int listen(int sockfd, int backlog); sockfd：要监听的socket描述字。 backlog：socket可以排队的最大连接数 接收用户请求 -&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); sockfd：服务器socket描述字。 addr：指向地址结构指针。 addrlen：协议地址长度。 注意：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。 从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count); fd：连接描述字 buf：缓冲区buf count：缓冲区长度 注：大于0标识读取的字节数，返回0标识文件读取结束，小于0标识发生错误。 关闭socket -&gt; int close(int fd); fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。 注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。 客户机： 创建socket -&gt; int socket(int domain, int type, int protocol); 连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr *addr, socklen_t addrlen); sockfd：客户端的sock描述字 addr：服务器的地址 addrlen：socket地址长度 向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count); fd、buf、count：同read中含义 大于0表示写了部分或全部数据，小于0则表示出错 关闭socket -&gt; int close(int fd); fd：同服务器端fd。 84、TCP协议如何保证可靠传输？ 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。 数据校验：TCP报文头有校验和，用于校验报文是否损坏 数据合理分片和排序： TCP会按最大传输单元（MTU）合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。 UDP：IP数据包大于1500字节，大于MTU，则IP层要分片，把数据报分成若干片，每一片小于MTU。接收方的IP层要进行重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据包，导致丢弃整个UDP数据报。 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止丢包 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止丢包。 85、UDP是什么？提供无连接的，尽最大努力交付的数据传输服务（不保证数据传输可靠性） 86、封包和拆包？基于TCP还是UDP？封包和拆包都是基于TCP的概念，因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。 封包：封包就是在发送数据报时为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。 包头是一个固定长度的结构体，里面包含该数据包的总长度。 拆包：接收方在收到报文后提取包头中的长度信息进行截取。 86、TCP和UDP的区别？ 是否面向连接？TCP面向连接（如同打电话要先拨号建立连接）UDP是无连接的，即发送数据之前不需要建立连接 是否可靠？TCP提供可靠的服务，即通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。 字节流？报文？TCP面向字节流，实际上TCP把数据看成一连串无结构的字节流； 可以想象成流水形式，发送方TCP会将数据放入缓存区，等到可以发送时候发送。不能发送就等着TCP会根据当前网络拥塞状态来确定每个报文段大小。UDP面向报文，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，直播等） 发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层 论应用层交给UDP多长的报文，它统统发送，一次发送一个。 接收方接到后直接去除首部，交给上面的应用层就完成任务了，因此需要应用层控制报文大小 如何交互？TCP连接，只能是点对点的UDP连接支持一对一，一对多，多对一，多对多的交互通信。 首部开销？TCP首部开销20字节；UDP首部开销8字节 逻辑通信信道？TCP逻辑通信信道是全双工的可靠信道UDP则是不可靠信道 87、UDP和TCP的特点？ UDP UDP是无连接的 UDP尽最大努力交付 UDP面向报文 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，IP电话，实时视频会议等） UDP支持一对一、一对多、多对一、多对多的交互通信 UDP的首部开销小，只有8个字节，比TCP的20字节首部短 TCP TCP面向连接 TCP提供可靠交付的服务 TCP提供全双工通信，因此双方都有发送和接收缓存 TCP面向字节流 TCP是点对点的，一对一 TCP首部20字节 88、TCP对应的应用层协议 FTP：定义了文件传输协议，使用21端口 Telnet：是一种用于远程登录的协议，使用23端口 SMTP：定义了简单邮件传送协议，服务器开放25端口 POP3：和SMTP对应，POP3用于接收邮件 89、UDP对应的应用层协议 DNS：用于域名解析服务，用53端口 SNMP：简单网络管理协议，使用161端口 TFTP（Trival File Transfer Protocol）：简单文件传输协议，使用69端口 90、数据链路层常见协议？ 协议 名称 作用 ARP 地址解析协议 根据IP地址获取物理地址 RARP 反向地址转换协议 根据物理地址获得IP地址 PPP 点对点协议 主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通解决方案 91、Ping命令基于哪一层协议的原理？ping命令基于网络层的命令，是基于ICMP协议工作的。92、在进行UDP编程时，一次发送多少Bytes好？没有唯一答案，对于不同系统，不同要求，得到答案不一样。 仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，也许能得到一点帮助： 首先，TCP&#x2F;IP通常被认为是一个四层协议系统，包括：链路层、网络层、运输层、应用层。 UDP属于运输层。 由下至上一步一步看： 以太网（Ethernet）数据帧长度必须在46-1500字节之间，这是由以太网的物理特性决定的。 这个1500字节被称为链路层的MTU（最大传输单元）。但这并不是指链路层的长度被限制在1500字节 其实MTU指的是链路层的数据区，并不包括链路层的首部和尾部18字节。 所以，其实1500字节就是网络层IP数据包的长度限制，因为IP数据包的首部为20字节，所以IP数据包的数据区长度最大为1480字节。而这1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的。因为UDP数据报的首部8字节，所以UDP数据报的数据区最大长度为1472字节。即可用字节数。 当UDP数据大于1472时候会怎样？即IP数据报大于1500字节，大于MTU。此时发送方IP层就要分片（fragmentation），把数据分成若干片，使每一片都小于MTU。接收方IP层要对数据报进行重组。这样会多做很多事情。更严重的是，UDP的特性导致当某一片数据传输中丢失时，接收方无法重组整个数据报，会导致UDP数据报被丢弃。 因此在普通局域网环境下，建议将UDP数据控制在1472字节一下为好。 进行Internet变成时则不同，因为Internet上路由器可能会将MTU设置为不同值。假定MTU为1500来发送数据，经过某个网络的MTU值小于1500字节，则系统将会使用一系列机制调整MTU，使数据报能顺利到达目的地，多做许多不必要操作。 鉴于Internet上标准的MTU值为576字节，因此建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节（576-8-20）以内。93、TCP利用滑动窗口实现流量控制的机制？ 流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP利用滑动窗口实现流量控制 TCP中采用滑动窗口进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报。 两种情况除外： 可以发送紧急数据 —— 例如允许用户终止在远端机上的运行程序。 发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方滑动窗口大小。 94、解释一下RTO&#x2F;RTT&#x2F;超时重传？ RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间，就是重传间隔。 通常每次重传RTO是前一次重传时间的两倍，计量单位通常是RTT。例如：1RTT&#x2F;2RTT&#x2F;4RTT&#x2F;8RTT… 重传次数到达上限之后停止重传 RTT：数据从发送到接收到对方响应之间的时间间隔，即数据包在网络中一个往返用时，大小不稳定 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况： 发送的数据没能到达接收端，所以对方没有相应。 接收端接收到数据，但是ACK报文在返回过程中丢失。 接收端拒绝或丢弃数据。 95、XSS攻击？跨站点脚本攻击，指攻击者通过篡改网络，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。 如何防范XSS？ 前端、服务端，同时需要字符串输入的长度限制 前端、服务端，同时需要对HTML转义处理，将其中”&lt;””&gt;”等特殊字符进行转义编码。 防XSS的核心是必须对输入的数据做过滤处理。96、CSRF攻击？跨站点请求伪造，指攻击者通过跨站请求，以合法的用户身份进行非法操作。 攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求CSRF能做的事包括用你的身份发邮件、发短信、进行交易转账、甚至盗取账号信息等。 97、如何防范CSRF攻击？ 安全框架：例如Spring Security。 token机制：在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。 验证码：通常情况下，验证码能够很好地遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，不是主要解决方案。 referer识别：在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。 但是，服务器并非都能取到Referer。很多用户处于隐私保护的考虑，限制了Referer的发送。 在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。 验证请求来源地址 关键操作添加验证码 在请求地址添加token并验证 98、文件上传漏洞是如何发生的？文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。许多第三方框架、服务，都曾经被曝出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等，可被攻击者上传恶意代码，有可能服务端被黑。 99、如何防范文件上传漏洞文件上传的目录设置为不可执行 判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。 对上传的文件类型进行白名单校验，只允许上传可靠类型。 上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本同时像shell.php.rar.ara这类文件，因为重命名而无法成功实施攻击。 限制上传文件的大小。 单独设置文件服务器的域名。 100、拥塞控制原理？ 拥塞控制的目的是防止数据被过多注入网络导致网络资源（路由器、交换机等）过载。 因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。 TCP拥塞控制算法： 慢开始 &amp; 拥塞避免： 慢开始：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到到达阈值ssthresh 拥塞避免：以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阈值减为原先一半，继续执行线性增加，这个过程为拥塞避免。 快速重传 &amp; 快速恢复： 略 最终拥塞窗口会收敛于稳定值。 101、如何区分流量控制和拥塞避免？ 流量控制属于通信双方协商拥塞控制涉及通信链路全局 流量控制需要通信双方各维护一个发送窗口、一个接收窗口，对任意一方，接收窗口大小由自身决定，发送窗口大小由接收方TCP报文段中窗口值确定拥塞控制的拥塞窗口大小由试探性发送一定数据量数据探查网络状况后而自适应调整 实际最终发送窗口 &#x3D; min（拥塞窗口，发送窗口） 102、常见HTTP状态码？ 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1XX 信息 100 Continue：表明目前为止很正常，客户端可以继续发送请求或忽略这个相应。 2XX 成功 200 OK 204 No Content：请求已经成功处理，但是返回的相应报文不包含实体的主题部分。 一般只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content：表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容。 3XX 重定向 301 Moved Permanently：永久性重定向 302 Found：临时性重定向 303 See Other：和302有相同的功能，但是303明确要求客户端应该采用GET方法获取资源 304 Not Modified：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Mathch，If-Range，If-Unmdodified-Since 如果不满足条件，则服务器返回304状态码 307 Temporary Redirect：临时重定向，与302的含义类似，但307要求浏览器不会把重定向请求的POST改为GET方法。 4XX 客户端错误 400 Bad Request：请求报文中存在语法错误 401 Unauthorized：该状态码表示发送的请求需要有认证信息（BASIC认证、DIGEST认证）。如果之前进行过一次请求，则表示用户认证失败。 403 Forbidden：请求被拒绝 404 Not Found 5XX 服务器错误 500 Internal Server Error：服务器正在执行请求时发生错误 503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 103、服务器出现大量close_wait的连接的原因是什么？有什么解决办法？CLOSE_WAIT状态实在TCP四次挥手时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量CLOSE_WAIT状态的原因有两种： 服务器内部业务处理占用了很多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致Socket的引用不为0无法回收。 处理方法： 停止应用程序 修改程序里的BUG 104、一台机器能够使用的端口号上限是多少，是否可以修改？如果象要用的端口超过这个限制怎么办？0-65535，因为TCP报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同的端口号 因此TCP可供识别的端口号最多只有65536个。但是由于0-1023是知名服务端口，所以实际上还要少1024个端口号。 对于服务器来说，可以开的端口与65536无关，其实受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置"},{"title":"MySQL","date":"2022-02-22T10:51:47.000Z","url":"/2022/02/22/MySQL/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["undefined",""]],"content":"一、MySQL 基础1、关系型数据库建立在关系模型基础上的数据库，表明了数据库中存储的数据之间的联系（一对一，一对多，多对多等）数据被存放在表中大部分关系型数据库都使用SQL操作数据库中的数据 2、常见的关系型数据库MySQL、Oracle、SQL Server、SQLite（wechat 聊天记录） 3、MySQL介绍关系型数据库，持久化存储系统中的一些数据。默认端口号 3306 二、存储引擎1、存储引擎相关命令 存储引擎相关命令 2、MyISAM 和 InnoDB 的区别MySQL 5.5 以前，默认存储引擎：MyISAMMySQL 5.5 以后，默认存储引擎：InnoDB（事务性数据库引擎） （１）是否支持行级锁 1 MyISAM：只有 表级锁InnoDB：有 行级锁 和 表级锁，默认 行级锁 表级锁：在上锁时锁住整张表，处理并发时效率更低因此，InnoDB在并发情况下，性能更好。 （２）是否支持事务 2 MyISAM：不提供事务支持InnoDB：提供事物支持，具有 提交（commit） 和 回滚（rollback）事务的能力。 （３）是否支持外键 3 MyISAM：不支持外键InnoDB：支持外键 一般不建议数据库层面使用外键，最好在应用层面解决，但这样会对数据一致性构成威胁。 （４）是否支持数据库异常崩溃后的安全恢复 4 MyISAM：不支持安全恢复InnoDB：支持安全恢复 InnoDB数据库异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo logredo log（重做事务）保证事务的持久性（Durability）undo log（回滚日志）保证事务的原子性（Atomicity）锁机制、MVCC保证事务的隔离性（Isolation）（参见ACID）而保证了事物的持久性、原子性、隔离性后，一致性（Consistency）才能得到保障。 （５）是否支持 MVCC(多版本并发控制) 5 MyISAM：不支持 MVCCInnoDB：支持 MVCCMVCC 可以看做是行级锁的一个升级，可以有效减少加锁操作，提供性能 3、关于 MyISAM 和 InnoDB 的选择问题一般都选择 InnoDB 存储引擎，读密集情况下可以选择 MyISAM，但不能保证上述不支持的操作。 在很多已知场景中，InnoDB 的速度都要比 MyISAM快，尤其用到了聚簇索引，或者需要访问的数据都可以放入内存的应用 三、锁机制与 InnoDB 锁算法（生疏）MyISAM：表级锁InnoDB：行级锁和表级锁，默认行级锁 表级锁：MySQL中锁定粒度最大，对当前操作表加锁 优点：实现简单，资源消耗小，加锁快，不会出现死锁。 缺点：锁定粒度最大，触发锁冲突的概率最高，并发度最低，因此不支持MVCC。 行级锁：MySQL中锁定粒度最小，对当前操作行加锁 优点：大大减少数据库操作的冲突，加锁粒度最小，并发度高。 缺点：加锁的开销也最大，加锁慢，会出现死锁。 InnoDB 存储引擎的三种锁算法： Record Lock：记录锁，单个行记录上的锁 Gap Lock：间隙锁，锁定一个范围，不包括记录本身，区间(x, y) Next-key Lock：Record + Gap 临键锁，锁定一个范围，包括记录本身，区间(x, y]锁算法参照：幻读 四、查询缓存（MySQL 8.0 版本后移除）my.cnf中加入以下配置 或 MySQL 执行以下命令 功能如其名，多次的同样查询条件会在缓存中直接返回结果。查询条件：查询本身、当前要查询的数据库、客户端协议版本号等 查询不命中的情况 1、任何两个查询在任何字符上的不同都会导致缓存不命中。 2、查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，结果也不会被缓存。 3、缓存建立后，MySQL的查询缓存系统会跟踪涉及的表，若表发生变化，则相应缓存数据失效。 因此，缓存虽然能提升数据库查询性能，但也带来额外的开销，查询要缓存，失效要销毁 此外，可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否要进行缓存： 五、事务（Transaction）1、事务的概念事务是逻辑上的一组操作，要么都执行，要么都不执行。举例：存钱，类似于OS中同步互斥操作。 2、数据库事务的概念注意，若没有特指 分布式事务，往往指的是 数据库事务数据库事务：保证多个 SQL 语句构成逻辑上整体，要么全部执行，要么全部不执行。 3、事务的ACID特性 1、原子性（Atomicity）：事务是最小的执行单位，要么全部完成，要么都不起作用。 2、一致性（Consistency）：执行事务前后，数据保持一致，转账举例，双方总额不变。 3、隔离性（Isolation）：并发访问数据库时，一个用户的事物不被其他事物干扰，并发事物之间数据库独立。 4、持久性（Durability）：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何的影响。 数据事务的实现原理：以InnoDB引擎为例：redo log（重做日志）保证事务的持久性undo log（回滚日志）保证事务的原子性锁机制、MVCC保证事务的隔离性（默认隔离级别REPEATABLE-READ）保证事务的持久性、原子性、隔离性之后，一致性才能得到保障。 4、并发事务带来哪些问题？多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作），并发虽然是必须的，但可能会导致一些问题： 脏读（Dirty read）：一个事务访问数据并对数据进行了修改，这种修改还没有提交到数据库中，这时另一个事务也访问了该数据。【此时数据修改并未提交】 丢失修改（Lost to modify）：T1 读取一个数据时，T2 也访问了该数据，则在 T1 中修改了这个数据后，T2 也修改了这个数据。【T1 的修改结果被丢失，称为丢失修改】 不可重复读（Unrepeatable read）：指在 T1 多次读同一数据，该事务还没结束时，T2 也访问该数据，则在 T1 的两次读数据之间，由于 T2 导致第一个事务两次读取的数据可能不一样。 幻读（Phantom read）：类似于不可重复读，在 T1 中读取了几行数据，T2 中插入了一些数据。随后的查询中，T1 就会发现多了一些原本不存在的记录。【产生幻觉，所以幻读】 不可重复读和幻读的区别：不可重复读修改：多次读取一条记录发现其中某些列的值被修改；幻读新增或删除：多次读取一条记录发现记录增多或减少了。 5、事务隔离级别： READ-UNCOMMITTED（读取未提交RU）：最低的隔离级别，允许读取尚未提交的数据变更可能导致脏读、幻读或不可重复读 READ-COMMITTED（读取已提交RC）：允许读取并发事务已经提交的数据可以阻止脏读可能导致幻读或不可重复读 REPEATABLE-READ（可重复读RR）：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改可以阻止脏读和不可重复读可能导致幻读 SERIALIZABLE（可串行化）：最高的隔离级别，完全服从ACID。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰。可以阻止脏读、不可重复读及幻读 6、MySQL的默认隔离级别MySQL InnoDB 存储引擎的默认支持的隔离级别是REPEATABLE-READ（可重读）可以通过SELECT @@tx_isolation;或SELECT @@transaction_isolation; MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。即使用Next-Key Locks。 隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED（读取提交内容），但InnoDB 存储引擎默认使用 RR 并不会有任何性能损失。 InnoDB 存储引擎在分布式事务的情况下一般会用到SERIALIZABLE（可串行化）隔离级别。 InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事物要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。此外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。 六、补充1、快照读和当前读 当前读：读取最新版本，并对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。 实现方式：Next-Key锁（Record Lock + Gap Lock）其中：Gap Lock 只在 RR 甚至以上的隔离级别才会有，锁定的是一个区间。1、主键或唯一索引，当前读时，where全部精确命中，只会加行记录锁2、没有索引的列，当前读时，会加全表Gap Lock。3、非唯一索引，条件部分命中(&gt;, &lt;, like 等)才会加 Gap Lock 快照读：单纯的select操作其中：RC的每次select都生成一个快照读，RR开启事务后第一个select才是快照读的地方快照读实现方式：undo log + MVCC事务ID：DB_TRX_ID回滚指针：DB_ROLL_PT "},{"title":"数据库","date":"2022-02-22T07:59:04.000Z","url":"/2022/02/22/Database/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["undefined",""]],"content":"1、关系型数据库和非关系型数据库的区别了解多少？ 关系型数据库： 容易理解，因为采用了关系模型来组织数据 可以保持数据一致性 数据更新开销较小 支持复杂查询（带where字句的查询） 非关系型数据库的优点 不需要经过SQL层的解析，读写效率高。 基于键值对，数据的扩展性很好。 可以支持多种类型数据的存储，如图片、文档等。 2、非关系型数据库？非关系型数据库也叫NoSQL，采用键值对形式进行存储 读写性能很好，易于扩展，可分为内存性数据库以及文档型数据库，例如：Redis，Mongodb，HBase等等。 适合使用非关系型数据库的场景： 日志系统 地理位置存储 数据量巨大 高可用 3、为什么使用索引？ 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 帮助服务器避免排序和临时表 将随机IO变为顺序IO 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 4、Innodb为什么要用自增id作为主键？如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引结点的后序位置，当一页写满，就会自动开辟一个新的页。 如果使用非自增主键（如身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要背插到现有索引页的中间某个位置，频繁的移动、分页操作了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。5、MyISAM和InnoDB实现B树索引方式的区别是什么？ MyISAM，B+Tree叶结点的data域存放的是数据记录的地址 在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值 然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引” InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构 树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键 因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而非地址 这也是和MyISAM不同的地方。 在根据主索引搜索时，直接找到key所在的节点即可取出数据； 在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，因为会造成主索引频繁分裂。 6、说一下MySQL是如何执行一条SQL的？具体步骤？ Server层按顺序执行SQL的步骤为： 客户端请求 连接器（验证用户身份，给予权限） 查询缓存（存在缓存则直接返回，不存在则执行后续操作） 分析器（对SQL进行词法分析和语法分析等操作） 优化器（主要对执行的SQL优化选择最优的执行方案方法） 执行器（之行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果） 简单概括： 连接器：管理连接、权限验证； 查询缓存：命中缓存则直接返回结果； 分析器：对SQL进行词法分析、语法分析（判断查询的SQL字段是否存在也在该步） 优化器：执行计划生成、选择索引； 执行器：操作引擎、返回结果 存储引擎：存储数据、提供读写接口 7、MySQL的内部构造？一般可以分为哪两部分？可以分为服务层和存储引擎层两部分 服务层：服务层包括连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）所有跨存储引擎的功能都在该层实现，比如存储过程、触发器、视图等。 存储引擎层：其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，从MySQL 5.5.5版本开始成为了默认的存储引擎。 8、Drop、Delete和Truncate的共同点和区别？Drop、Delete、Truncate都表示删除，但是三者有一点差别： Delete用来删除表的全部或者一部分数据行，执行delete后，用户需要提交(commit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有delete触发器 Truncate删除表中所有数据，这个操作不能回滚，也不会触发这个表上的触发器，Truncate比Delete更快，占用空间更小。 Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。 因此，在不再需要一张表的时候，用Drop；在想删除部分数据行的时候，用Delete；在保留表而删除所有数据的时候用Truncate。 具体解析： Delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。Truncate TABLE则一次性从表中删除所有的数据并不把单独的删除操作记录计入日志保存，删除行是不能恢复的。 并且在删除的过程中不会激发与表有关的删除触发器。执行速度快。 表和索引所占空间。Truncate后，这个表和索引所占用的空间会恢复到初始大小Delete操作不会减少表或索引占用的空间Drop语句将表所占用的空间全释放掉。 一般而言 drop &gt; truncate &gt; delete 应用范围。Truncate只能对tableDelete可以是table和view Truncate和Delete只删除数据drop则删除整个表（结构和数据） Truncate与不带where的Delete：只删除数据，而不删除表的结构（定义）Drop语句将删除表的结构被依赖的约束（constrain），触发器（trigger），索引（index）；依赖于该表的存储过程&#x2F;函数被保留，但状态变成：invalid Delete语句为DML（Data Manipulation Language），这个操作会被放到rollback segment中，事务提交后才生效。如果有相应的trigger，执行时将被触发。 Truncate、Drop是DDL（Data Define Language），操作立即生效。原数据不放到rollback segment中，不能回滚 在没有备份的情况下，谨慎使用Drop与Truncate。要删除部分数据行采用Delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用Drop；若想保留表而将表中数据删除，如果与事物无关，用Truncate；如果和事务有关，或老是想触发trigger，还是用delete Tuuncate TABLE 表名，速度快，效率高，因为：Truncate TABLE在功能上与不带WHERE字句的Delete语句相同，二者均删除表中的全部行但Truncate TABLE比DELETE速度快，且使用的相同和事务日志资源少。Delete语句每次删除一行，并在事务日志中为所删除的每行记录一项。Truncate TABLE通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 Truncate TABLE删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想要保留标识计数值，请改用Delete，如果要删除表定义及其数据，请用Drop TABLE语句。 对于由FOREIGN KEY约束引用的表，不能用Truncate TABLE而应该使用不带WHERE子句的Delete语句，由于Truncate TABLE不记录在日志中，所以不能激活触发器。 9、MySQL优化？哪些方面可以做到性能优化？ 为搜索字段创建索引 避免使用Select *， 列出需要查询的字段 垂直分割分表 选择正确的存储引擎 10、数据库隔离级别 未提交读（READ-UNCOMMITTED）：事务中发生了修改，即使没有提交，其他事务也是可见的。比如对于一个数A，原来50修改为100，但是还没有提交修改，另一个事务看到这个修改。而此时原事务发生了回滚，这时A还是50，但是另一个事务看到的A是100。可能会导致脏读、幻读、不可重复读 提交读（READ-COMMITTED）：对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的。比如对于一个数A原来是50，然后提交修改成100，这时另一个事物在A提交修改之前读取的A是50，刚读取完，A就被修改为100。此时另一个事物再进行读取就发现A突然变成了100。可以阻止脏读；可能导致幻读、不可重复读 重复读（REPEATABLE-READ）：就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的。可以阻止脏读、不可重复读；可能导致幻读 可串行化（SERIALIZABLE）：在并发情况下，和串行化的读取的结果是一致的，没什么不同，比如不会发生脏读和幻读。可以阻止脏读、不可重复读、幻读 隔离级别 脏读 不可重复读 幻读 未提交读READ-UNCOMMITTED √ √ √ 提交读READ-COMMITTED × √ √ 重复读REPEATABLE-READ × × √ 可串行化SERIALIZABLE × × × MySQL InnoDB存储引擎默认支持的隔离级别是REPEATABLE-READ（可重复读） 需要注意： 与SQL标准不同的地方在于InnoDB存储引擎在REPEATABLE-READ（可重复读）事务隔离级别下使用的是Next-Key Lock算法，因此可以避免幻读产生。 这与其他数据库系统（如SQL Server）是不同的。 所以InnoDB存储引擎的默认支持隔离级别是REPEATABLE-READ（可重复读）已经可以完全保证事务的隔离性要求 即InnoDB的可重复度达到了SQL标准的SERIALIZABLE（可串行化）隔离级别 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED（读已提交）但是InnoDB存储引擎默认使用REPEATABLE-READ（可重复读）并不会有任何性能损失 InnoDB存储引擎在分布式事务情况下一般会用到SERIALIZABLE（可串行化）隔离级别。11、都知道数据库索引采用B+树而非B树，主要原因？主要原因：B+树只要遍历叶子结点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是很频繁的B树只能中序遍历所有结点，效率太低。 12、文件索引和数据库索引为什么使用B+树？文件和数据库都是需要较大的存储，也就是说他们不可能全部存储在内存中，故需要存储到磁盘上。 而所谓索引，则为了数据的快速定位和查找那么索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理和磁盘预读原理，将一个节点的大小设为等于一个页，这样每个结点只需要一次I&#x2F;O就可以完全载入。 而红黑树这种结构，高度明显要深很多，并且由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性。 最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍即可B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。 B+树的磁盘读写代价更低：B+树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相比B树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中需要查找的关键字也就越多，相对于I&#x2F;O次数变少（降低I&#x2F;O次数，增加速度） B+树的查询效率更加稳定：由于内部结点并不是指向文件内容的节点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须从根节点一路找到叶子结点。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 13、视图？游标？视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能 游标是对查询出来的结果集作为一个单元来有效的处理。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 14、MySQL中为什么要有事务回滚机制在MySQL中，恢复机制是通过回滚日志（Undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。当事务已经被提交之后，就无法再次回滚了。 回滚日志作用： 能够在发生错误或者用户执行ROLLBACK的时候提供回滚相关的信息 在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立即通过查询回滚日志将之前未完成的事务进行回滚。这也就需要回滚日志必须先于数据持久化到硬盘上，是我们需要先写日志后写数据库的主要原因。 15、数据库引擎InnoDB和MyISAM的区别 InnoDB 是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其他存储引擎。【首选】 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻读 主索引是聚簇索引，在索引中保存了数据，从而避免直接读磁盘，因此对查询性能有很大提升 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。 支持真正的在线热设备。其他存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能意味着停止读取。 MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 提供了大量的特性，包括压缩表、空间数据索引等。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 总结 事务：InnoDB是事务型的，可以使用COMMIT和ROLLBACK语句。 并发：MyISAM只支持表级锁，InnoDB支持行级锁 外键：InnoDB支持外键 备份：InnoDB支持在线热备份 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复速度也更慢 其他特性：MyISAM支持压缩表和空间数据索引 16、数据库并发事务会带来哪些问题？数据库并发会带来脏读、幻读、丢弃更改、不可重复读四个常见问题 脏读：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务的结果就是脏数据了。【读取的数据和他应该是的数据不一致】 幻读：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了。【强调范围】 丢弃修改：两个写事务T1,T2同时对A &#x3D; 0进行递增操作，结果T2覆盖了T1，导致最终结果是1而不是2，事务被覆盖。 不可重复读：T2读取一个数据，然后T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。【两次读结果不同】 脏读：读的变量在后来被修改了幻读：读取的范围之间的值有变化丢弃修改：两个同时写，一个写会被覆盖不可重复读：两次读的结果不同 脏读 第一个事务首先读取var变量为50，接着准备更新为100的时候，并未提交。第二个事务已经读取var变量未100，此时第一个事务进行了回滚。最终导致第二个事务读取的var和数据库的var不一样。 幻读 T1读取某个范围的数据。T2在这个范围内插入新的数据。T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。 丢弃修改 T1和T2两个事务都对一个数据进行修改。T1先修改，T2后修改，T2的修改覆盖了T1的修改。 例如：事务1读取某表中的数据A &#x3D; 50，事务2也读取A &#x3D; 50，事务1修改A &#x3D; A + 50，事务2也修改A &#x3D; A + 50，最终结果A &#x3D; 100，事务1 的修改被丢失。 不可重复读 T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。 17、数据库悲观锁和乐观锁的原理和应用场景？ 悲观锁先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事物以外修改数据。当数据库执行 SELECT … FOR UPDATE 时会获取被SELECT中的数据行的行锁SELECT FOR UPDATE获取的行锁会在当前事物结束时自动释放，因此必须在事务中使用 乐观锁先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。Java并发包中的AtomicFieldUpdater类似，也是利用CAS机制，并不会对数据加锁，而是通过对比数据的时间戳或版本号，来实现乐观锁需要的版本判断。 18、MySQL索引主要使用的两种数据结构是什么？ 哈希索引对于哈希索引来说，底层的数据结构肯定是哈希表。因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引 BTree索引MySQL的BTree索引使用的是B树中的B+TreeBTree索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历Node，获得叶子结点。 但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。19、数据库为什么要进行分库和分表？都放在一个库或者一张表中不行？分库和分表的目的在于：减小数据库的单库单标负担，提高查询性能，缩短查询时间。 分表可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用。此外，可以很大地缓解表锁的问题。分表策略可以归纳为垂直拆分和水平拆分： 水平分表：取模分表就属于随机分表，而时间维度分表则属于连续分表。 垂直分表：将不常用的字段单独拆分到另外一张扩展表将大文本的字段单独拆分到另外一张扩展表将不经常修改的字段放在同一张表中将经常改变的字段放在另一张表中。 对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。 库内分表：仅仅是解决单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻MySQL服务器的压力仍然存在同一个物理机上的资源竞争和瓶颈，包括CPU、内存、磁盘IO、网络带宽等。 分库和分表带来的分布式困境和应对之策。 数据迁移和扩容问题：一般做法是通过程序先读出数据，然后按照指定的分表策略再讲数据写入到各个分表中。 分页与排序问题：需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。 20、不可重复读和幻读的区别？ 例子1（同样的条件，两次读取结果不一样）事务1中读取 A &#x3D; 1000 的操作还没完成，事务2中修改了 A &#x3D; 2000。此时事务1再读取 A 时候 A &#x3D; 2000，两次读取结果不一样 例子2（同样的条件，第1次和第2次读出来的记录数不一样）某表中，X 字段大于3000的有4个记录事务1中读取了X字段大于3000的人，共4条记录，事务2中插入了一条X字段大于3000的记录事务1再次读取时记录变为了5条，两次读取的记录数不一样。 不可重复读的重点是修改，幻读的重点在于新增或删除。 21、MySQL中有四种索引类型？ FULLTEXT（全文索引）全文索引，目前只有MyISAM支持。可以在CREATE TABLE, ALTER TABLE, CREATE INDEX使用不过目前只有 CHAR, VARCHAR, TEXT 列上可以创建全文索引。 HASH（哈希）由于HASH的唯一（几乎100%的唯一）以及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要树形索引那样逐层查找，因此具有极高效率。但这种高效有条件，即只在”&#x3D;”和”in”条件下高效，对于范围查询、排序和组合索引仍然效率不高。 BTREEBTREE索引就是一种将索引值按一定算法，存入到一个树形的数据结构中（二叉树）每次查询都是从树的入口root开始，依次遍历node，获取叶子结点。这是MySQL里默认和最常用的索引类型。 RTREERTREE在MySQL中很少使用，仅支持Gemometry类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDB、NDb、Archive几种。相比于BTREE，RTREE的优势在于范围查找。 22、视图的作用是什么？可以更改吗？视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询； 不包含任何列或数据，使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用他们。 视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。 创建视图：create view xxx as xxx 对于某些视图比如未使用联合子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新。但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。 视图优点： 视点集中，只用关心视图定义的数据而非引用表中数据 简化操作，可以只对视图本身查询，隐藏表与表之间复杂的连接 定制数据，可以让不同要求用户看到不同或相同的数据集 合并分割数据，不用更改表原先的结构，可以让视图保持原来的结构关系，外模式不变，但应用程序可以通过视图重载数据 安全性，用户只可以看到或修改他们能看到的数据，其他数据不可见也不可访问。 23、为什么时候B+Tree比BTree更适合实际应用中操作系统的文件索引和数据库索引？B+tree的磁盘读写代价更低，B+tree的查询效率更加稳定【因为必须查询到底】 数据库索引采用B+树而不是B树的主要原因： B+树只要遍历叶子结点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的 而B树只能中序遍历所有结点，效率太低。 B+树的特点： 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。 24、场景题：如果所在公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，优化手段？ 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。 选择合适的表字段数据结构类型和存储引擎，适当地添加索引。 MySQL库主从读写分离。 找规律分表，减少单表中的数据量提高查询速度。 添加缓存机制，比如Memcached，Apc等。 不经常改动的页面，生成静态页面。 书写高效率的SQL，例如SELECT * FROM TABLE 改为 SELECT field_1, field_2, field_3 FROM TABLE。 25、什么时候需要建立数据库索引？适合： 在最频繁使用的、用以缩小查询范围的字段，需要排序的字段上建立索引 不适合： 对于查询中很少涉及的列或重复值较多的列 对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。 26、覆盖索引是什么？如果一个索引包含（或覆盖）所有需要查询的字段的值，称之为“覆盖索引” 在InnoDB存储引擎中，如果不是主键索引，叶子结点存储的是主键+列值。 最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。 覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。27、数据库中的主键、超键、候选键、外键是什么？ 超键：在关系中能唯一标识元组属性集称为关系模式的超键【一个属性或者多个属性总和】 候选键：不含有多余属性的超键称为候选键。也就是在候选键中，任删除一个属性，就不是键了 主键：用户选作元组标识的一个候选键称为主键 外键：如果关系模式R中属性K是其他模式的主键，那么K在模式R中称为外键。 举例： 学号 姓名 性别 年龄 系别 专业 20020612 A 男 20 计算机 软件开发 20060613 B 男 18 计算机 软件开发 20060614 C 女 19 物理 力学 20060615 D 女 17 生物 动物学 20060616 E 男 21 化学 食品化学 20060617 F 女 20 生物 植物学 超键：例子中可以发现，学号是标识学生实体的唯一标识。那么元组的超键就为学号。 除此之外，还可以将它和其他属性组合起来，例如：（学号，性别）、（学号，年龄） 候选键：学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键。事实上，候选键是超键的子集。 比如（学号，年龄）是超键，但并非候选键。因为它还有了额外的属性。【不含有多余属性的超键】 主键：例子中元组候选键是学号，但选定学号为该元组的唯一标识，学号就成为了主键。 外键：相对于主键，例如在该表中，学号是主键，在成绩单表中，也有学号字段，因此学号是成绩单表的外键。 28、数据库三大范式 第一范式在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体的某个属性不能有多个值或不能有重复属性。 如果出现重复的属性，则可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。 简言之，第一范式是无重复的列 第二范式第二范式（2NF）是在第一范式（1NF）的基础上建立起来的。即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式（2NF）要求数据库表中的每个实例或行必须可被唯一地区分。 为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。 所谓完全依赖是指不能存在仅依赖关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体和原实体之间应该是一对多的关系。为了实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。 简言之，第二范式就是非主属性非部分依赖于主关键字。 第三范式满足第三范式（3NF）必须先满足第二范式（2NF）。简言之，第三范式（3NF）要求一个数据库表中不包含已在其他表中已包含的非主关键字信息。 例如：存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。 那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。 如果不存在部门信息表，则根据第三范式（3NF）也应该构建他它，否则就会有大量的数据冗余。 简言之，第三范式就是属性不依赖于其他非主属性 29、数据库三大范式精要总结 简单归纳： 第一范式（1NF）：字段不可分 第二范式（2NF）：有主键，非主键字段依赖主键 第三范式（3NF）：非主键字段不能相互依赖【员工ID，员工信息，部门ID，部门信息】 解释： 1NF：原子性。字段不可再分，否则就不是关系数据库。 2NF：唯一性。一个表只说明一个事物。 3NF：每列都与主键有直接关系，不存在传递依赖。 30、MySQL常见的存储引擎InnoDB，MyISAM的区别？适用场景分别是？ 事务：MyISAM不支持，InnoDB支持； 锁级别：MyISAM表级锁，InnoDB行级锁及外键约束； 存储行数：MyISAM存储表的总行数，InnoDB不存储表的总行数； 索引：MyISAM采用非聚簇索引，B+树叶子结点存储指向数据文件的指针。 InnoDB主键索引采用聚簇索引，B+树叶子存储数据。 适用场景： MyISAM适合：插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择，没有事务。 InnoDB适合：可靠性要求比较高，或者要求事务；表更新和查询都相当频繁，大量的INSERT或UPDATE 31、事务四大特性（ACID）原子性、一致性、隔离性、持久性？ 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。 因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency） 事务开始前和结束后，数据库的完整性约束没有被破坏。 比如A向B转账，不可能A扣了钱，B却没收到。 隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事物之间要相互隔离。 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。 比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 事物的隔离性，数据库提供了多种隔离级别。【READ-UNCOMMITTD&#x2F;READ-COMMITTED&#x2F;REPEATABLE-READ&#x2F;SERIALIZABLE】 持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。 即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 32、SQL中的NOW()和CURRENT_DATA()两个函数有什么区别？NOW()命令用于显示当前年份，月份，日期，小时，分钟和秒。CURRENT_DATE()仅显示当前年份，月份和日期。 33、聚合索引？聚簇索引就是按照拼音查询非聚簇索引就是按照偏旁等进行查询 其实汉语字典正文本身就是一个聚簇索引。 比如要查“安”字，会自然翻开字典前几页，因为“安”的拼音是“an”而按照拼音排序，汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”就自然地排在字典的首部。如果翻完了所有“a”开头的部分仍找不到，说明字典中没这个字；如果查“张”字，那也会将字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说字典的正文部分本身就是一个目录，不需要在找其他目录来找到想要内容。 于是，把这种正文内容本身就是一种按照一定规则排列的目录称为“聚簇索引”。34、什么是非聚簇索引如果认识某个字，可以快速地从自动中查到这个字。 但也可能会遇到不认识的字，不知道发音，这时候就不能按照刚才的方法找到要查的字，而需要去根据“偏旁部首”查到要找的字然后根据这个字的页码直接翻到某页来找到要找的字（相当于找到页码）。 但结合“部首目录”和“检字表”查到的字的排序并不是真正正文的排序方法。例如“张”，查部首检字表显示672页。“驰”页码显示63页。“弩”页码显示390页。 显然，这些字并不是真正的分别位于“张”字上下方，但看到的连续的三个字实际上就是他们在非聚簇索引中的排序，是字典正文中的字在非聚簇索引中的映射。我们可以通过这种方式来找到需要的字，但需要两个过程，先找目录，再翻到页码 于是，把目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚簇索引”35、聚簇索引和非聚簇索引的区别是什么？聚簇索引和非聚簇索引的区别在于： 通过聚簇索引可以查到需要查找的数据 通过非聚簇索引可以查到记录对应的主键值，再使用主键值通过聚簇索引查找到需要的数据。 聚簇索引和非聚簇索引的根本区别是表记录的排列顺序和索引的排列顺序是否一致。 聚簇索引（InnoDB）的叶结点就是数据结点非聚簇索引（MyISAM）的叶结点仍然是索引结点，只不过其包含一个指向对应数据块的指针。 36、创建索引时需要注意什么？ 非空字段：应该制定列为NOT NULL，除非想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替空值。 取值离散大的字段：（变量各个取值之间的差异速度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值。返回值越大说明字段的唯一值越多字段的离散程度高。【说明不同键的信息越多】 索引字段越小越好：数据库的数据存储以页为单位，一页存储的数据越多，一次IO操作获取的数据越大、效率越高。唯一、不为空、经常被查询的字段更适合建索引。【字段越小，一页存储的东西越多】 37、MySQL中CHAR和VARCHAR的区别有哪些？ char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。 char的存取速度比varchar要快得多 char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用2个字节。【相当于填充到1B或者2B】varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。 38、MySQL索引使用的注意事项MySQL索引通常是被用于提高Where条件的数据行匹配时的搜索速度，在索引使用过程中，存在一些使用细节和注意事项。 函数，运算，否定操作符，连接条件，多个单列索引，最左前缀原则，范围查询，不会包含有NULL值的列，like语句不要在列上使用函数和进行运算。 不要在列上使用函数，这将导致索引失效而进行全表扫描。 为了使用索引，防止执行全表扫描，可以进行改造。 还有一个建议，不要在列上进行运算，这也将导致索引失效而进行全表扫描。 为了使用索引，防止执行全表扫描，可以进行改造。 尽量避免使用 !&#x3D; 或 not in 或 &lt;&gt; 等否定运算符应该尽量避免在where子句中使用 !&#x3D; 或 not in 或 &lt;&gt; 操作符，因为这几个操作符都会导致索引失效而进行全表扫描。 尽量避免使用or来连接条件，应该尽量避免在where子句中使用or来连接条件，因为这会导致索引失效而进行全表扫描。 多个单列索引并不是最佳选择MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高MySQL的查询性能。 假如，有两个单列索引，分别为：news_year_idx(news_year)和news_month_idx(news_month)。 现在，有一个场景需要针对咨询的年份和月份进行查询，那么SQL语句可以写成 事实上，MySQL只能使用一个单列索引。为了提高性能，可以使用复合索引news_year_month_idx(news_year, news_month)保证news_year和news_month两个列都被索引覆盖。 复合索引的最左前缀原则复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。 因此，在复合索引中索引列的顺序至关重要。如果不是按照所以你的最左列开始查找，则无法使用索引。假设，有一个场景只需要针对咨询的月份进行查询，那么SQL语句可以写成： 此时，无法使用news_year_month_idx(news_year, news_month)索引因为遵守“最左前缀”原则，在查询条件中没有使用复合索引的第一个字段，索引不会被使用。 覆盖索引的好处如果一个索引包含所有需要查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大地提高性能。因此可以定义一个让索引包含的额外的列，即这个列对于索引而言是无用的。 范围查询对多列查询的影响查询中某个列有范围查询，则其右边所有列都无法使用索引优化查找。 举个例子：假设一个场景需要查询本周发布的咨询文章，其中的条件是必须是启用状态，且发布时间在本周内。那么SQL语句可以写成： 这种情况下，因为范围查询对多列查询的影响，将导致news_publish_idx(publish_time, enable)索引中publish_time右边所有列都无法使用索引优化查找。 换句话说，news_publish_idx(publish_time, enable)索引等价于news_publish_idx(publish_time)。 对于这种情况，可以：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以用别的方法间接实现业务场景。 例如：上面案例的需求是查询本周发布的咨询文章，一次可以创建一个news_weekth字段用来存储咨询文章周信息，使得范围查询变成普通查询，SQL可以改写： 然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，可以：不必试图用SQL来解决所有问题，可以使用其他数据存储技术控制时间轴，如Redis的SortedSet有序集合保存时间，或者通过缓存方式缓存查询结果提高性能。 索引不会包含有NULL值的列只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。因此，在数据库设计时，除非有一个特别原因使用NULL值，否则尽量不要让字段默认值为NULL。 隐式转换的影响当查询条件左右两侧类型不匹配时会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。下面的案例中，date_str是字符串，然而匹配的是整数类型，从而发生隐式转换。 因此要谨记隐式转换的危害，时刻注意通过同类型进行比较。 like语句的索引失效问题like的方式进行查询，在like “value %” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题。但是对于海量数据，全表扫描十分可怕。所以根据业务需求，考虑使用ElasticSearch 或 Solr 是个不错的方案。 39、MySQL中有哪些索引？特点？ 普通索引：仅加速查询 唯一索引：加速查询 + 列值唯一（可以有NULL） 主键索引：加速查询 + 列值唯一（不可有NULL） + 表中只有一个 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 全文索引：对文本的内容进行分词，进行搜索 索引合并：使用多个单列索引组合搜索 覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖 聚簇索引：表数据是和主键一起存储的，主键索引的叶子结点存储了行数据（包含了主键值），二级索引的叶结点存储行的主键值。【副索引查主键】 使用的是B+树作为索引的存储结构，非叶子结点都是索引关键字，但非叶子结点中的关键字中不存储对应记录的具体内容或内容地址。 叶子结点上的数据是主键与具体记录（数据内容） 40、既然索引有那么多优点，为什么不对表的每一列创建一个索引？ 当对表中数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 索引需要占物理空间，除了数据表占数据空间之外，每个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间也就更大。 创建索引和维护索引要耗费时间，这种时间会随着数据量的增加而增加。 41、索引是如何提高查询速度的？将无序的数据变成相对有序的数据（就像查有目的一样）42、使用索引的注意事项 在经常需要搜索的列上，可以加快搜索的速度。 在经常使用在where子句中的列上面创建索引，加快条件的判断速度。 将打算加索引的列设置成为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。 避免where子句中对字段施加函数，这会造成无法命中索引 在中到大型表中索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建议用逻辑索引 在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度。 与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，也不要用业务主键。 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。 在使用limit offset查询缓存时，可以借助索引来提高性能。 43、增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优查询效率？不可以。因为这样最终会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时B+树多路存储的好处就体现出来了，一次加载B+树的一个结点，恰好一个盘，然后一步步往下找。 44、数据库的表锁和列锁？ 表锁不会出现死锁，发生锁冲突几率高，并发低。MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁；在执行增删改操作前，会自动给涉及的所有表加写锁。 MySQL的表级锁有两种模式：表共享读锁和表独占写锁 读锁会阻塞写，写锁会阻塞读和写 对MyISAM表的读操作，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程写操作。 对MyISAM表的写操作，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。 MyISAM不适合做写为主表的引擎，因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而永久阻塞。 行锁会出现死锁，发生锁冲突几率低，并发高。 在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的行锁是通过索引加载的也就是说，行锁是加载索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁。此时其他事物无法对当前表进行更新或插入操作。 行锁的实现需要注意： 行锁必须有索引才能实现，否则会自动锁全表，那就不是行锁了。 两个事务不能锁同一个索引。 insert，delete，update在事务中都会自动默认加上排他锁。 行锁的适用场景A 用户消费，Service层先查询该用户的账户余额，若余额足够，则进行后续扣款操作，这种情况查询时应该对该记录进行加锁。 否则，B 用户在 A 用户查询后消费前抢先一步将 A 用户账号上的钱转走而此时 A 用户已经进行了用户余额是否足够的判断，则可能会出现用户余额不足但扣款成功情况。 为了避免此情况，需要在 A 用户操作该记录的时候进行 FOR UPDATE 加锁。 45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？ 内连接：只有两个元素表相匹配的才能在结果集中显示。 外连接： 左外连接：左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接：右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接中的表中不匹配的数据全部会显示出来。 交叉连接：笛卡尔积，显示的结果是链接表数的乘积。 46、你知道哪些数据库结构优化的手段？ 范式优化：比如消除冗余（节省空间） 反范式优化比如适当添加冗余（减少表的链接） 限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。例如：当用户在查询历史订单的时候，可以将时间控制在一个月的范围内。 读&#x2F;写分离：经典数据库拆分方案，主库负责写，从库负责读。 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间另外处于不同磁盘的分区也将对这个标的数据传输分散在不同的磁盘I&#x2F;O，一个精心设置的分区可以将数据传输对磁盘I&#x2F;O竞争均匀地分散开。对数据量大的时候表可以采取此方法，可按月自动建表分区。 47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于差分数据了解哪些？拆分分为垂直拆分和水平拆分 案例：简单购物系统暂涉及如下表：一、产品表（数据量10W，稳定）二、订单表（数据量200W，且有增长趋势）三、用户表（数据量100W，且有增长趋势）以MySQL为例讲述水平拆分和垂直拆分，MySQL能容忍的数量级在百万静态数据可以到千万。 垂直拆分【专库专用，不同表拆到不同数据库中】解决问题：表与表之间的I&#x2F;O竞争不解决问题：单表中数据量增长出现的压力方案：把产品表和用户表放到一个Server上，订单表单独放到另一个Server上。 水平拆分【同一个表拆到不同数据库中】解决问题：单表中数据增长出现的压力不解决问题：表于表之间的I&#x2F;O竞争方案： 用户表：通过性别拆分为男用户表和女用户表 订单表：通过已完成和完成中拆分为已完成订单和未完成订单 产品表：未完成订单放在一个Server上，已完成订单和男用户表放在一个Server上，女用户表放一个Server上。 48、为什么MySQL索引要使用B+树，而不是B树或者红黑树？在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作。磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转没分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂开始进行数据的读写。 那么就存在一个定位到磁盘中块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时间远远大于电子的运动。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以使用B树进行优化，提高磁盘读取时定位的效率。 为什么B类树可以进行优化？根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息保证层数（树的高度）尽量的少，以便后面我们可以更快地找到信息磁盘的I/O也就少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。 特别的：只有B-树和B+树，而B-树叫做B树，没有B减树说法。49、为什么MySQL索引适用B+树而不用hash表和B树？ 利用Hash需要把数据全部加载到内存中，如果数据量大，是一个很消耗内存的事情，而采用B+树，是基于按照结点分段加载，由此减少内存消耗。 和业务场景有关，对于唯一查找（查找一个值），Hash确实更快，但数据库中经常查询多条数据这时候由于B+树的有序性，而叶子结点又有链表相邻，他的查询效率会比Hash快的多。 B+树的非叶子结点不保存数据，只保存子树的临界值（最大或最小），所以同样大小的节点【比如一个页框】B+树相对于B树能够有更多的分支，使得这棵树更加矮胖，查询时候做的I/O次数也就更少。 50、既然Hash比B+树更快，为什么MySQL用B+树来存储索引？MySQL中存储索引用到的数据结构是B+树，B+树的查询时间和树的高度有关，是O(logn)，如果用hash存储，那么查询的时间是O(1)。 采用Hash来存储确实要更快，但是采用B+树来存储索引的原因主要有以下两点： 从内存角度来说，数据库的索引一般是在磁盘上，数据量大的情况下可能无法一次性装入内存，B+树的设计可以允许数据分批加载 从业务场景来说，如果只选择一个数据那必然是Hash更快，但是数据库中经常会选中多条【例如where】此时由于B+树索引有序，而且又有链表相连，它的查询效率比Hash就快多了。 51、关系型数据库的四大特性在得不到保障的情况下会怎样？ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 接下来，以从A账户转账50元到B账户为例说明ACID四大特性： 原子性 原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。 即要么转账成功，要么转账失败，不存在中间的状态。 如果无法保证原子性就会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。从此，系统无缘无故少了50元。 一致性 一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 什么是合法的数据状态？满足预定的约束就叫做合法的状态，这个状态是由自己来定义的。 满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的 如果无法保证一致性例一：A有200元，转账300元出去，A账户余额-100元，自然发现此时数据不一致 因为定义了一个状态，余额列必须大于0元。例二：A有200元，转账50元给B账户，A账户的钱扣了，但是B账户由于各种意外，余额并未增加。 此时数据也是不一致的，因为定义了一个状态，要求A+B的总额保持不变 隔离性 隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的 并发执行的各个事务之间不能相互干扰。 如果无法保证隔离性假设A账户有200元，B账户0元。A账户往B账户转账两次，金额50元，分别在两个事务中执行。如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只增加了一次，凭空消失50元，依然出现数据不一致。【如：A&#x3D;200，B&#x3D;0，A-50，B+50；A&#x3D;150，B&#x3D;0，A-50，B+50；A&#x3D;100，B&#x3D;50】 持久性 持久性是指事务一旦提交，它对数据库的改变就应该是永久性的 接下来的其他操作或故障不应该对其有任何影响。 如果无法保证持久性在MySQL中，为了解决CPU和磁盘速度不一致的问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再写回磁盘。假设此时宕机，内存中修改的数据全部丢失，持久性便无法保证。 如果系统提示转账成功，但发现金额没有发生任何变化，此时数据出现了不合法的数据状态，我们将这种状态认为是数据不一致的情形。 52、数据库如何保证一致性？两个层面来说： 从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说，ACID四大特性之中，C（一致性）是目的，A（原子性）、I（隔离性）、D（持久性）是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。 例如，原子性无法保证，一致性显然也无法保证 从应用层面通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。 53、数据库如何保证原子性？主要是利用InnoDB（支持事务）的undo log。undo log 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的SQL语句，他需要记录你要回滚的相应日志信息。 例如： 当DELETE一条数据的时候，就需要记录这条数据的信息，回滚时候，INSERT这条旧数据。 当UPDATE一条数据的时候，就需要记录这条数据的旧值，回滚时候，根据旧值执行UPDATE操作。 当INSERT一条数据的时候，就需要记录这条数据的主键，回滚时候，根据主键执行DELETE操作。 undo log记录了这些回滚需要的信息，当事务执行失败或调用了ROLLBACK，导致事务需要回滚便可以利用 undo log 中的信息将数据回滚到修改之前的样子。 54、数据库如何保证持久性？主要是利用InnoDB中的redo log重写日志。 正如之前所说，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。如何解决？事物提交之前直接把事务写入磁盘，这么做有什么问题？ 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，浪费资源。毕竟一个页面16kb大小，只改其中一点点东西，就要将16kb内容重刷入磁盘，有些不合理。 一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。操作随机IO，速度会比较慢。 于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘（redo log一部分在内存中，一部分在磁盘上）当数据库宕机重启时，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚还是提交数据。 采用redo log的好处？好处就是将redo log进行刷盘比对数据页进行刷盘效率高，具体表现如下： redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。 redo log是一直往末尾进行追加，属于顺序I&#x2F;O，效率显然比随机I&#x2F;O来得快。 55、数据库高并发是经常会遇到的，有什么好的解决方案？ 在web服务框架中加入缓存。在服务器和数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。 增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，而且数据库的写入会导致索引的更新，也会导致速度变慢等） 主从读写分离，让主服务器负责写，从服务器负责读。 将数据库进行拆分，使得数据库的表尽可能小，提高查询速度。 使用分布式架构，分散计算压力 "},{"title":"数据结构","date":"2022-02-19T10:48:08.000Z","url":"/2022/02/19/DataStruct/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"1、替换空格（简单）- 题目大意 实现一个函数，把字符串中的每个空格替换为’%20’ - 示例 略 - 代码 双指针版 - 注意事项上述解法使用了双指针此题注意事项：此处双指针是要从末尾开始数 2、从尾到头打印链表（简单）- 题目大意 输入一个链表的头结点，从尾到头反过来返回每个结点的值（数组返回） - 示例 略 - 代码 栈 - 注意事项用栈即可 递归本质也是用栈实现的，因此递归也是不错的选择 3、用两个栈实现队列（简单）- 描述 用两个栈实现队列，实现 appendTail 和 deleteHead 函数 - 示例 略 - 代码 两个栈实现队列 - 注意事项注意在暴力的基础上想想怎么改进 4、表示数值的字符串（中等）- 描述 一个函数判断字符串是否表示数值（包括整数和小数），整数，小数 - 示例 数值：[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]非数值：[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”] - 代码 暂无 - 注意事项前置知识：编译原理 5、翻转链表（简单）- 描述 定义一个函数，输入一个链表的头结点，翻转该链表并输出翻转后链表的头结点。 - 示例 略 - 代码 链表遍历 递归 - 注意事项普通写法：头插法注意递归写法 6、包含min函数的栈（简单）- 题目大意 实现一个栈，栈中能够得到最小元素的min函数，调用min、push及pop的时间复杂度都是O(1) - 示例 略 - 代码 带min的栈 - 注意事项感觉可以注意一下栈空时不能pop和查询啊，标准代码里面并没有 7、复杂链表的复制（简单）- 题目大意 复杂链表的复制，除了next指针指向下一个结点，还有random指针指向随机结点 - 示例 - 代码 map映射解法，hash，旧结点指针映射新节点 神奇解法 - 注意事项1、STL库的使用2、注意第二种神奇解法，值得学习3、值得注意的是，要时刻留意题目所给范围是不是能为空：nullptr4、创建新的结点链表时，要注意不能对原链表进行改动 8、左旋转字符串（简单，花样多）- 题目大意 把字符串前面的若干个字符转移到字符串的尾部 - 示例 输入: s &#x3D; “abcdefg”, k &#x3D; 2输出: “cdefgab” - 代码 字符串切片方法 不允许字符串切片，旋转方法 - 注意事项1、C++ 中 substr 函数，参数1：起始下标，参数2：从下标开始多少个数2、翻转三次，相当于前后颠倒3、C++ 中 字符串 属于 可变类型，因此可以原地操作，不同于 Python 和 Java4、注意，如果要改变实参的话，需要使用引用5、如果要使用reverse函数，则需要使用迭代器 9、滑动窗口的最大值（中等）- 题目大意 给定一个数组 nums 和 滑动窗口的大小 k，找出所有滑动窗口里的最大值。 - 示例 - 代码 本人垃圾写法,multiset 单调队列写法【值得二刷】 - 注意事项multiset 和 priority_queue 优化一下就变成了单调队列的写法 10、队列的最大值（和上题一样）- 题目大意 定义一个队列，实现函数max_value得到队列里的最大值，要求函数max_value、push_back和pop_front的均摊时间复杂度都是O(n)。若队列为空，则返回pop_front、max_value返回-1 - 示例 略 - 代码 估计可以单调队列写 -注意事项和上体一样，单调队列解决 11、12、回文链表（简单）- 题目大意 判断一个链表是否回文 - 示例 [1, 2, 2, 1] —— true[1, 2] —— false - 代码 - 注意事项使用链表的递归特性，不显式翻转链表的情况下，逆序读链表。当然，本人的做法是翻转slow指针后的链表，如果想不破坏链表结构，再次翻转回来即可。 13、填充每一个节点的下一个右侧指针（中等）- 题目大意 给定一个完全二叉树，所有叶子结点都在同一层，每个父节点有两个子节点。填充其 next 指针，指向下一个右侧结点 - 示例 - 代码 - 注意事项使用递归的解法，连接两个结点。 14、二叉树展开为链表（中等）- 题目大意 给出一个二叉树的根节点root，将其展开为一个单链表 展开后的单链表同样使用TreeNode，其中right指针指向链表中下一个结点，而左指针时钟为null 展开后的单链表应该与二叉树先序遍历相同 - 示例 - 代码 - 注意事项解题步骤： 将root的左子树和右子树拉平。 将root的右子树接在左子树的下方，并将整个左子树作为右子树。由上述步骤可知，对每个子树都将其左子树和右子树拉平，其实就是完成一系列的递归操作。综上，写二叉树的算法题，都是基于递归框架的，基于每个步骤的实现时机，选择先序、中序、后序。 15、寻找重复的子树- 题目大意 给定一棵二叉树，返回所有重复的子树，对同一类重复的子树只需要返回任意一棵即可 - 示例 - 代码 - 注意事项1、如何知道自己的子树什么样2、如何知道别的子树长什么样 16、删除二叉搜索树中的节点（中等）- 题目大意 给定 root 和 key，删除对应 key 的节点 - 示例 略 -代码 - 注意事项递归删除 17、子数组范围和（中等）- 题目大意 给一个整数数组nums。其中，子数组的范围是子数组中最大和最小元素差值。返回其中所有子数组的和。 - 示例 - 代码 单调栈解法 - 注意事项注意一下左右区间，一边闭，另一边就要开，都是要处理相等的情况 18、蜡烛之间的盘子（中等）- 题目大意 用’*’代表盘子，’|’代表蜡烛，给定一个字符串，询问若干次，问：所询问区间内有多少蜡烛之间的盘子 - 示例 - 代码 - 注意事项前缀和思想处理蜡烛的数量，同时存储区间最近的左边界和右边界。"},{"title":"Hello World","date":"2022-02-12T08:42:27.602Z","url":"/2022/02/12/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]