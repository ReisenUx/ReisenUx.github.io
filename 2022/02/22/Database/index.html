<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>数据库 | 月战老兵月球基地</title>
  <meta name="author" content="ReisenU" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="数据库" />
  
  <meta name="description" content="1、关系型数据库和非关系型数据库的区别了解多少？ 关系型数据库：  容易理解，因为采用了关系模型来组织数据  可以保持数据一致性  数据更新开销较小  支持复杂查询（带where字句的查询）    非关系型数据库的优点  不需要经过SQL层的解析，读写效率高。  基于键值对，数据的扩展性很好。  可以支持多种类型数据的存储，如图片、文档等。      2、非关系型数据库？非关系型数据库也叫NoSQ">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="http://example.com/2022/02/22/Database/index.html">
<meta property="og:site_name" content="月战老兵月球基地">
<meta property="og:description" content="1、关系型数据库和非关系型数据库的区别了解多少？ 关系型数据库：  容易理解，因为采用了关系模型来组织数据  可以保持数据一致性  数据更新开销较小  支持复杂查询（带where字句的查询）    非关系型数据库的优点  不需要经过SQL层的解析，读写效率高。  基于键值对，数据的扩展性很好。  可以支持多种类型数据的存储，如图片、文档等。      2、非关系型数据库？非关系型数据库也叫NoSQ">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2022-02-22T07:59:04.000Z">
<meta property="article:modified_time" content="2022-03-30T08:28:29.452Z">
<meta property="article:author" content="ReisenU">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li><a href="/"><i class="fa fa-link"></i>链接</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">月战老兵月球基地</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>月战老兵月球基地</h2> <br />
                        <span>Lunar Capital</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">数据库</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-02-22</li>
                <li><i class="fa fa-user"></i> 作者 ReisenU</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~23.25K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1648628909452"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1、关系型数据库和非关系型数据库的区别了解多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2、非关系型数据库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3、为什么使用索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Innodb%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%87%AA%E5%A2%9Eid%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4、Innodb为什么要用自增id作为主键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E9%9D%9E%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%88%E5%A6%82%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E6%88%96%E5%AD%A6%E5%8F%B7%E7%AD%89%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%AF%8F%E6%AC%A1%E6%8F%92%E5%85%A5%E4%B8%BB%E9%94%AE%E7%9A%84%E5%80%BC%E8%BF%91%E4%BC%BC%E4%BA%8E%E9%9A%8F%E6%9C%BA%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%AF%8F%E6%AC%A1%E6%96%B0%E7%BA%AA%E5%BD%95%E9%83%BD%E8%A6%81%E8%83%8C%E6%8F%92%E5%88%B0%E7%8E%B0%E6%9C%89%E7%B4%A2%E5%BC%95%E9%A1%B5%E7%9A%84%E4%B8%AD%E9%97%B4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%A2%91%E7%B9%81%E7%9A%84%E7%A7%BB%E5%8A%A8%E3%80%81%E5%88%86%E9%A1%B5%E6%93%8D%E4%BD%9C%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E7%A2%8E%E7%89%87%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E4%B8%8D%E5%A4%9F%E7%B4%A7%E5%87%91%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%8C%E5%90%8E%E7%BB%AD%E4%B8%8D%E5%BE%97%E4%B8%8D%E9%80%9A%E8%BF%87OPTIMIZE-TABLE%E6%9D%A5%E9%87%8D%E5%BB%BA%E8%A1%A8%E5%B9%B6%E4%BC%98%E5%8C%96%E5%A1%AB%E5%85%85%E9%A1%B5%E9%9D%A2%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">如果使用非自增主键（如身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要背插到现有索引页的中间某个位置，频繁的移动、分页操作了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81MyISAM%E5%92%8CInnoDB%E5%AE%9E%E7%8E%B0B%E6%A0%91%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">5、MyISAM和InnoDB实现B树索引方式的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%EF%BC%9F%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">6、说一下MySQL是如何执行一条SQL的？具体步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81MySQL%E7%9A%84%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0%EF%BC%9F%E4%B8%80%E8%88%AC%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">7、MySQL的内部构造？一般可以分为哪两部分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Drop%E3%80%81Delete%E5%92%8CTruncate%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">8、Drop、Delete和Truncate的共同点和区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81MySQL%E4%BC%98%E5%8C%96%EF%BC%9F%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">9、MySQL优化？哪些方面可以做到性能优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">10、数据库隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E8%88%AC%E4%BC%9A%E7%94%A8%E5%88%B0SERIALIZABLE%EF%BC%88%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%82"><span class="toc-number">12.</span> <span class="toc-text">InnoDB存储引擎在分布式事务情况下一般会用到SERIALIZABLE（可串行化）隔离级别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E9%83%BD%E7%9F%A5%E9%81%93%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E9%87%87%E7%94%A8B-%E6%A0%91%E8%80%8C%E9%9D%9EB%E6%A0%91%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">11、都知道数据库索引采用B+树而非B树，主要原因？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">12、文件索引和数据库索引为什么使用B+树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E8%A7%86%E5%9B%BE%EF%BC%9F%E6%B8%B8%E6%A0%87%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">13、视图？游标？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81MySQL%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">16.</span> <span class="toc-text">14、MySQL中为什么要有事务回滚机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8EInnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">15、数据库引擎InnoDB和MyISAM的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">16、数据库并发事务会带来哪些问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">17、数据库悲观锁和乐观锁的原理和应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81MySQL%E7%B4%A2%E5%BC%95%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">18、MySQL索引主要使用的两种数据结构是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%86%E5%AF%B9%E4%BA%8E%E4%B8%BB%E8%A6%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88MyISAM%E5%92%8CInnoDB%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%E3%80%82"><span class="toc-number">21.</span> <span class="toc-text">但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%EF%BC%9F%E9%83%BD%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E6%88%96%E8%80%85%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E4%B8%8D%E8%A1%8C%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">19、数据库为什么要进行分库和分表？都放在一个库或者一张表中不行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">20、不可重复读和幻读的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81MySQL%E4%B8%AD%E6%9C%89%E5%9B%9B%E7%A7%8D%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">21、MySQL中有四种索引类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">22、视图的作用是什么？可以更改吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99B-Tree%E6%AF%94BTree%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">23、为什么时候B+Tree比BTree更适合实际应用中操作系统的文件索引和数据库索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%89%80%E5%9C%A8%E5%85%AC%E5%8F%B8%E9%80%89%E6%8B%A9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%8C%E4%B8%80%E5%A4%A9%E4%BA%94%E4%B8%87%E6%9D%A1%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%A2%9E%E9%87%8F%EF%BC%8C%E9%A2%84%E8%AE%A1%E8%BF%90%E7%BB%B4%E4%B8%89%E5%B9%B4%EF%BC%8C%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">24、场景题：如果所在公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，优化手段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">25、什么时候需要建立数据库索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">26、覆盖索引是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%B0%B1%E6%98%AF%E6%8A%8A%E8%A6%81%E6%9F%A5%E8%AF%A2%E5%87%BA%E7%9A%84%E5%88%97%E5%92%8C%E7%B4%A2%E5%BC%95%E6%98%AF%E5%AF%B9%E5%BA%94%E7%9A%84%EF%BC%8C%E4%B8%8D%E5%81%9A%E5%9B%9E%E8%A1%A8%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">30.</span> <span class="toc-text">覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E9%94%AE%E3%80%81%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">27、数据库中的主键、超键、候选键、外键是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">32.</span> <span class="toc-text">28、数据库三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E7%B2%BE%E8%A6%81%E6%80%BB%E7%BB%93"><span class="toc-number">33.</span> <span class="toc-text">29、数据库三大范式精要总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EInnoDB%EF%BC%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">30、MySQL常见的存储引擎InnoDB，MyISAM的区别？适用场景分别是？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">31、事务四大特性（ACID）原子性、一致性、隔离性、持久性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81SQL%E4%B8%AD%E7%9A%84NOW-%E5%92%8CCURRENT-DATA-%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">32、SQL中的NOW()和CURRENT_DATA()两个函数有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E8%81%9A%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">33、聚合索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8E%E6%98%AF%EF%BC%8C%E6%8A%8A%E8%BF%99%E7%A7%8D%E6%AD%A3%E6%96%87%E5%86%85%E5%AE%B9%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8C%89%E7%85%A7%E4%B8%80%E5%AE%9A%E8%A7%84%E5%88%99%E6%8E%92%E5%88%97%E7%9A%84%E7%9B%AE%E5%BD%95%E7%A7%B0%E4%B8%BA%E2%80%9C%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E2%80%9D%E3%80%82"><span class="toc-number">38.</span> <span class="toc-text">于是，把这种正文内容本身就是一种按照一定规则排列的目录称为“聚簇索引”。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">39.</span> <span class="toc-text">34、什么是非聚簇索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8E%E6%98%AF%EF%BC%8C%E6%8A%8A%E7%9B%AE%E5%BD%95%E7%BA%AF%E7%B2%B9%E6%98%AF%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%AD%A3%E6%96%87%E7%BA%AF%E7%B2%B9%E6%98%AF%E6%AD%A3%E6%96%87%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%A7%B0%E4%B8%BA%E2%80%9C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E2%80%9D"><span class="toc-number">40.</span> <span class="toc-text">于是，把目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚簇索引”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">35、聚簇索引和非聚簇索引的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">36、创建索引时需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81MySQL%E4%B8%ADCHAR%E5%92%8CVARCHAR%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">37、MySQL中CHAR和VARCHAR的区别有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81MySQL%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">44.</span> <span class="toc-text">38、MySQL索引使用的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81MySQL%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95%EF%BC%9F%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">39、MySQL中有哪些索引？特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81%E6%97%A2%E7%84%B6%E7%B4%A2%E5%BC%95%E6%9C%89%E9%82%A3%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">40、既然索引有那么多优点，为什么不对表的每一列创建一个索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">41、索引是如何提高查询速度的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%97%A0%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E6%88%90%E7%9B%B8%E5%AF%B9%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E5%B0%B1%E5%83%8F%E6%9F%A5%E6%9C%89%E7%9B%AE%E7%9A%84%E4%B8%80%E6%A0%B7%EF%BC%89"><span class="toc-number">48.</span> <span class="toc-text">将无序的数据变成相对有序的数据（就像查有目的一样）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">49.</span> <span class="toc-text">42、使用索引的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81%E5%A2%9E%E5%8A%A0B-%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%8C%E9%82%A3%E4%B9%88%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9C%80%E4%BC%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">43、增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优查询效率？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A1%A8%E9%94%81%E5%92%8C%E5%88%97%E9%94%81%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">44、数据库的表锁和列锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81SQL%E8%AF%AD%E6%B3%95%E4%B8%AD%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E8%87%AA%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%B7%A6%E3%80%81%E5%8F%B3%E3%80%81%E5%85%A8%EF%BC%89%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">52.</span> <span class="toc-text">45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">46、你知道哪些数据库结构优化的手段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%8B%E6%AE%B5%E5%B0%B1%E6%98%AF%E6%8A%8A%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%B7%AE%E5%88%86%E6%95%B0%E6%8D%AE%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于差分数据了解哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%B4%A2%E5%BC%95%E8%A6%81%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%E6%88%96%E8%80%85%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">55.</span> <span class="toc-text">48、为什么MySQL索引要使用B+树，而不是B树或者红黑树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%EF%BC%9A%E5%8F%AA%E6%9C%89B-%E6%A0%91%E5%92%8CB-%E6%A0%91%EF%BC%8C%E8%80%8CB-%E6%A0%91%E5%8F%AB%E5%81%9AB%E6%A0%91%EF%BC%8C%E6%B2%A1%E6%9C%89B%E5%87%8F%E6%A0%91%E8%AF%B4%E6%B3%95%E3%80%82"><span class="toc-number">56.</span> <span class="toc-text">特别的：只有B-树和B+树，而B-树叫做B树，没有B减树说法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%B4%A2%E5%BC%95%E9%80%82%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8hash%E8%A1%A8%E5%92%8CB%E6%A0%91%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">49、为什么MySQL索引适用B+树而不用hash表和B树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E6%97%A2%E7%84%B6Hash%E6%AF%94B-%E6%A0%91%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%94%A8B-%E6%A0%91%E6%9D%A5%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">50、既然Hash比B+树更快，为什么MySQL用B+树来存储索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E5%9C%A8%E5%BE%97%E4%B8%8D%E5%88%B0%E4%BF%9D%E9%9A%9C%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">51、关系型数据库的四大特性在得不到保障的情况下会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">60.</span> <span class="toc-text">52、数据库如何保证一致性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-number">61.</span> <span class="toc-text">53、数据库如何保证原子性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">54、数据库如何保证持久性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E6%98%AF%E7%BB%8F%E5%B8%B8%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">63.</span> <span class="toc-text">55、数据库高并发是经常会遇到的，有什么好的解决方案？</span></a></li></ol>
                </div>
            
            <hr />
            <h2 id="1、关系型数据库和非关系型数据库的区别了解多少？"><a href="#1、关系型数据库和非关系型数据库的区别了解多少？" class="headerlink" title="1、关系型数据库和非关系型数据库的区别了解多少？"></a>1、关系型数据库和非关系型数据库的区别了解多少？</h2><ul>
<li><p>关系型数据库：</p>
<ul>
<li><p>容易理解，因为采用了关系模型来组织数据</p>
</li>
<li><p>可以保持数据一致性</p>
</li>
<li><p>数据更新开销较小</p>
</li>
<li><p>支持复杂查询（带where字句的查询）</p>
</li>
</ul>
</li>
<li><p>非关系型数据库的优点</p>
<ul>
<li><p>不需要经过SQL层的解析，读写效率高。</p>
</li>
<li><p>基于键值对，数据的扩展性很好。</p>
</li>
<li><p>可以支持多种类型数据的存储，如图片、文档等。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2、非关系型数据库？"><a href="#2、非关系型数据库？" class="headerlink" title="2、非关系型数据库？"></a>2、非关系型数据库？</h2><p>非关系型数据库也叫NoSQL，采用键值对形式进行存储</p>
<p>读写性能很好，易于扩展，可分为内存性数据库以及文档型数据库，例如：Redis，Mongodb，HBase等等。</p>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用</li>
</ul>
<hr>
<h2 id="3、为什么使用索引？"><a href="#3、为什么使用索引？" class="headerlink" title="3、为什么使用索引？"></a>3、为什么使用索引？</h2><ul>
<li><p>通过创建<code>唯一性索引</code>，可以保证数据库表中每一行数据的唯一性。</p>
</li>
<li><p>可以大大加快数据的<code>检索速度</code>，这也是创建索引的最主要的原因。</p>
</li>
<li><p>帮助服务器避免排序和临时表</p>
</li>
<li><p>将随机IO变为顺序IO</p>
</li>
<li><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
</li>
</ul>
<hr>
<h2 id="4、Innodb为什么要用自增id作为主键？"><a href="#4、Innodb为什么要用自增id作为主键？" class="headerlink" title="4、Innodb为什么要用自增id作为主键？"></a>4、Innodb为什么要用自增id作为主键？</h2><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引结点的后序位置，当一页写满，就会自动开辟一个新的页。</p>
<h2 id="如果使用非自增主键（如身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要背插到现有索引页的中间某个位置，频繁的移动、分页操作了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE-TABLE来重建表并优化填充页面。"><a href="#如果使用非自增主键（如身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要背插到现有索引页的中间某个位置，频繁的移动、分页操作了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE-TABLE来重建表并优化填充页面。" class="headerlink" title="如果使用非自增主键（如身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要背插到现有索引页的中间某个位置，频繁的移动、分页操作了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。"></a>如果使用非自增主键（如身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要背插到现有索引页的中间某个位置，频繁的移动、分页操作了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</h2><h2 id="5、MyISAM和InnoDB实现B树索引方式的区别是什么？"><a href="#5、MyISAM和InnoDB实现B树索引方式的区别是什么？" class="headerlink" title="5、MyISAM和InnoDB实现B树索引方式的区别是什么？"></a>5、MyISAM和InnoDB实现B树索引方式的区别是什么？</h2><ul>
<li><p>MyISAM，B+Tree叶结点的data域存放的是数据记录的地址<br>  在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值<br>  然后以data域的值为地址读取相应的数据记录，这被称为<code>“非聚簇索引”</code></p>
</li>
<li><p>InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构<br>  树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键<br>  因此InnoDB表数据文件本身就是主索引，这被称为<code>“聚簇索引”</code>或聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而非地址<br>  这也是和MyISAM不同的地方。</p>
<p>  在根据主索引搜索时，直接找到key所在的节点即可取出数据；<br>  在根据辅助索引查找时，则<code>需要先取出主键的值</code>，再走一遍主索引。<br>  因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，因为会造成主索引频繁分裂。</p>
</li>
</ul>
<hr>
<h2 id="6、说一下MySQL是如何执行一条SQL的？具体步骤？"><a href="#6、说一下MySQL是如何执行一条SQL的？具体步骤？" class="headerlink" title="6、说一下MySQL是如何执行一条SQL的？具体步骤？"></a>6、说一下MySQL是如何执行一条SQL的？具体步骤？</h2><img src="/2022/02/22/Database/MySQLProcess.png" class="">

<p>Server层按顺序执行SQL的步骤为：</p>
<ol>
<li>客户端请求</li>
<li>连接器（验证用户身份，给予权限）</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）</li>
<li>分析器（对SQL进行词法分析和语法分析等操作）</li>
<li>优化器（主要对执行的SQL优化选择最优的执行方案方法）</li>
<li>执行器（之行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ol>
<p>简单概括：</p>
<ol>
<li>连接器：管理连接、权限验证；</li>
<li>查询缓存：命中缓存则直接返回结果；</li>
<li>分析器：对SQL进行词法分析、语法分析（判断查询的SQL字段是否存在也在该步）</li>
<li>优化器：执行计划生成、选择索引；</li>
<li>执行器：操作引擎、返回结果</li>
<li>存储引擎：存储数据、提供读写接口</li>
</ol>
<hr>
<h2 id="7、MySQL的内部构造？一般可以分为哪两部分？"><a href="#7、MySQL的内部构造？一般可以分为哪两部分？" class="headerlink" title="7、MySQL的内部构造？一般可以分为哪两部分？"></a>7、MySQL的内部构造？一般可以分为哪两部分？</h2><p>可以分为<code>服务层</code>和<code>存储引擎层</code>两部分</p>
<ul>
<li><p>服务层：<br>服务层包括<b>连接器、查询缓存、分析器、优化器、执行器等</b>。<br>涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）<br>所有跨存储引擎的功能都在该层实现，比如<b>存储过程、触发器、视图等</b>。</p>
</li>
<li><p>存储引擎层：<br>其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。<br>现在最常用的存储引擎是InnoDB，从MySQL 5.5.5版本开始成为了默认的存储引擎。</p>
</li>
</ul>
<hr>
<h2 id="8、Drop、Delete和Truncate的共同点和区别？"><a href="#8、Drop、Delete和Truncate的共同点和区别？" class="headerlink" title="8、Drop、Delete和Truncate的共同点和区别？"></a>8、Drop、Delete和Truncate的共同点和区别？</h2><p>Drop、Delete、Truncate都表示删除，但是三者有一点差别：</p>
<ul>
<li><p>Delete用来删除表的全部或者一部分数据行，执行delete后，用户需要提交(commit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有delete触发器</p>
</li>
<li><p>Truncate删除表中所有数据，这个操作不能回滚，也不会触发这个表上的触发器，Truncate比Delete更快，占用空间更小。</p>
</li>
<li><p>Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。</p>
</li>
</ul>
<p>因此，在不再需要一张表的时候，用Drop；<br>在想删除部分数据行的时候，用Delete；<br>在保留表而删除所有数据的时候用Truncate。</p>
<p>具体解析：</p>
<ol>
<li><p>Delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。<br>Truncate TABLE则一次性从表中删除所有的数据并不把单独的删除操作记录计入日志保存，删除行是不能恢复的。<br> 并且在删除的过程中不会激发与表有关的删除触发器。执行速度快。</p>
</li>
<li><p>表和索引所占空间。<br>Truncate后，这个表和索引所占用的空间会恢复到初始大小<br>Delete操作不会减少表或索引占用的空间<br>Drop语句将表所占用的空间全释放掉。</p>
</li>
<li><p>一般而言 drop &gt; truncate &gt; delete</p>
</li>
<li><p>应用范围。<br>Truncate只能对table<br>Delete可以是table和view</p>
</li>
<li><p>Truncate和Delete只删除数据<br>drop则删除整个表（结构和数据）</p>
</li>
<li><p>Truncate与不带where的Delete：只删除数据，而不删除表的结构（定义）<br>Drop语句将删除表的结构被依赖的约束（constrain），触发器（trigger），索引（index）；依赖于该表的存储过程&#x2F;函数被保留，但状态变成：invalid</p>
</li>
<li><p>Delete语句为DML（Data Manipulation Language），这个操作会被放到rollback segment中，事务提交后才生效。<br>如果有相应的trigger，执行时将被触发。</p>
</li>
<li><p>Truncate、Drop是DDL（Data Define Language），操作立即生效。<br>原数据不放到rollback segment中，不能回滚</p>
</li>
<li><p>在没有备份的情况下，谨慎使用Drop与Truncate。<br>要删除部分数据行采用Delete且注意结合where来约束影响范围。回滚段要足够大。<br>要删除表用Drop；<br>若想保留表而将表中数据删除，如果与事物无关，用Truncate；<br>如果和事务有关，或老是想触发trigger，还是用delete</p>
</li>
<li><p>Tuuncate TABLE 表名，速度快，效率高，<br>因为：Truncate TABLE在功能上与不带WHERE字句的Delete语句相同，二者均删除表中的全部行<br>但Truncate TABLE比DELETE速度快，且使用的相同和事务日志资源少。<br>Delete语句每次删除一行，并在事务日志中为所删除的每行记录一项。<br>Truncate TABLE通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>
</li>
<li><p>Truncate TABLE删除表中的所有行，但表结构及其列、约束、索引等保持不变。<br>新行标识所用的计数值重置为该列的种子。<br>如果想要保留标识计数值，请改用Delete，如果要删除表定义及其数据，请用Drop TABLE语句。</p>
</li>
<li><p>对于由FOREIGN KEY约束引用的表，不能用Truncate TABLE<br>而应该使用不带WHERE子句的Delete语句，由于Truncate TABLE不记录在日志中，所以不能激活触发器。</p>
</li>
</ol>
<hr>
<h2 id="9、MySQL优化？哪些方面可以做到性能优化？"><a href="#9、MySQL优化？哪些方面可以做到性能优化？" class="headerlink" title="9、MySQL优化？哪些方面可以做到性能优化？"></a>9、MySQL优化？哪些方面可以做到性能优化？</h2><ul>
<li><p>为搜索字段创建索引</p>
</li>
<li><p>避免使用Select *， 列出需要查询的字段</p>
</li>
<li><p>垂直分割分表</p>
</li>
<li><p>选择正确的存储引擎</p>
</li>
</ul>
<hr>
<h2 id="10、数据库隔离级别"><a href="#10、数据库隔离级别" class="headerlink" title="10、数据库隔离级别"></a>10、数据库隔离级别</h2><ul>
<li><p><b>未提交读（READ-UNCOMMITTED）</b>：事务中发生了修改，即使没有提交，其他事务也是可见的。<br>比如对于一个数A，原来50修改为100，但是还没有提交修改，另一个事务看到这个修改。<br>而此时原事务发生了回滚，这时A还是50，但是另一个事务看到的A是100。<br><b>可能会导致脏读、幻读、不可重复读</b></p>
</li>
<li><p><b>提交读（READ-COMMITTED）</b>：对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的。<br>比如对于一个数A原来是50，然后提交修改成100，这时另一个事物在A提交修改之前读取的A是50，刚读取完，A就被修改为100。<br>此时另一个事物再进行读取就发现A突然变成了100。<br><b>可以阻止脏读；可能导致幻读、不可重复读</b></p>
</li>
<li><p><b>重复读（REPEATABLE-READ）</b>：就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的。<br><b>可以阻止脏读、不可重复读；可能导致幻读</b></p>
</li>
<li><p><b>可串行化（SERIALIZABLE）</b>：在并发情况下，和串行化的读取的结果是一致的，没什么不同，比如不会发生脏读和幻读。<br><b>可以阻止脏读、不可重复读、幻读</b></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未提交读READ-UNCOMMITTED</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">提交读READ-COMMITTED</td>
<td align="left">×</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">重复读REPEATABLE-READ</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">可串行化SERIALIZABLE</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB存储引擎默认支持的隔离级别是REPEATABLE-READ（可重复读）</p>
<p>需要注意：<br>  与SQL标准不同的地方在于InnoDB存储引擎在REPEATABLE-READ（可重复读）事务隔离级别下使用的是<code>Next-Key Lock</code>算法，因此可以避免幻读产生。</p>
<p>  这与其他数据库系统（如SQL Server）是不同的。<br>  所以InnoDB存储引擎的默认支持隔离级别是REPEATABLE-READ（可重复读）已经可以完全保证事务的隔离性要求<br>  即InnoDB的可重复度达到了SQL标准的SERIALIZABLE（可串行化）隔离级别</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED（读已提交）<br>但是InnoDB存储引擎默认使用<b>REPEATABLE-READ（可重复读）并不会有任何性能损失</b></p>
<h2 id="InnoDB存储引擎在分布式事务情况下一般会用到SERIALIZABLE（可串行化）隔离级别。"><a href="#InnoDB存储引擎在分布式事务情况下一般会用到SERIALIZABLE（可串行化）隔离级别。" class="headerlink" title="InnoDB存储引擎在分布式事务情况下一般会用到SERIALIZABLE（可串行化）隔离级别。"></a>InnoDB存储引擎在分布式事务情况下一般会用到SERIALIZABLE（可串行化）隔离级别。</h2><h2 id="11、都知道数据库索引采用B-树而非B树，主要原因？"><a href="#11、都知道数据库索引采用B-树而非B树，主要原因？" class="headerlink" title="11、都知道数据库索引采用B+树而非B树，主要原因？"></a>11、都知道数据库索引采用B+树而非B树，主要原因？</h2><p>主要原因：<br>B+树只要遍历叶子结点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是很频繁的<br>B树只能中序遍历所有结点，效率太低。</p>
<hr>
<h2 id="12、文件索引和数据库索引为什么使用B-树？"><a href="#12、文件索引和数据库索引为什么使用B-树？" class="headerlink" title="12、文件索引和数据库索引为什么使用B+树？"></a>12、文件索引和数据库索引为什么使用B+树？</h2><p>文件和数据库都是需要较大的存储，也就是说他们不可能全部存储在内存中，故需要存储到磁盘上。</p>
<ul>
<li><p>而所谓索引，则为了数据的快速定位和查找<br>那么索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数，因此B+树相比B树更为合适。<br>数据库系统巧妙利用了局部性原理和磁盘预读原理，将一个节点的大小设为等于一个页，这样每个结点只需要一次I&#x2F;O就可以完全载入。</p>
<p>而红黑树这种结构，高度明显要深很多，并且由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性。</p>
</li>
<li><p>最重要的是，B+树还有一个最大的好处：方便扫库。<br>B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍即可<br>B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p>
</li>
<li><p>B+树的磁盘读写代价更低：<br>B+树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相比B树更小。<br>如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。<br>一次性读入内存中需要查找的关键字也就越多，相对于I&#x2F;O次数变少（降低I&#x2F;O次数，增加速度）</p>
</li>
<li><p>B+树的查询效率更加稳定：<br>由于内部结点并不是指向文件内容的节点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须从根节点一路找到叶子结点。<br>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ul>
<hr>
<h2 id="13、视图？游标？"><a href="#13、视图？游标？" class="headerlink" title="13、视图？游标？"></a>13、视图？游标？</h2><p>视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能</p>
<p>游标是对查询出来的结果集作为一个单元来有效的处理。<br>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<hr>
<h2 id="14、MySQL中为什么要有事务回滚机制"><a href="#14、MySQL中为什么要有事务回滚机制" class="headerlink" title="14、MySQL中为什么要有事务回滚机制"></a>14、MySQL中为什么要有事务回滚机制</h2><p>在MySQL中，恢复机制是通过回滚日志（Undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。<br>当事务已经被提交之后，就无法再次回滚了。</p>
<p>回滚日志作用：</p>
<ol>
<li>能够在发生错误或者用户执行ROLLBACK的时候提供回滚相关的信息</li>
<li>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立即通过查询回滚日志将之前未完成的事务进行回滚。<br>这也就需要回滚日志必须先于数据持久化到硬盘上，是我们需要先写日志后写数据库的主要原因。</li>
</ol>
<hr>
<h2 id="15、数据库引擎InnoDB和MyISAM的区别"><a href="#15、数据库引擎InnoDB和MyISAM的区别" class="headerlink" title="15、数据库引擎InnoDB和MyISAM的区别"></a>15、数据库引擎InnoDB和MyISAM的区别</h2><ul>
<li><p>InnoDB</p>
<ul>
<li><p>是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其他存储引擎。【首选】</p>
</li>
<li><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。<br>在可重复读隔离级别下，通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻读</p>
</li>
<li><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读磁盘，因此对查询性能有很大提升</p>
</li>
<li><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
</li>
<li><p>支持真正的在线热设备。其他存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能意味着停止读取。</p>
</li>
</ul>
</li>
<li><p>MyISAM</p>
<ul>
<li><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
</li>
<li><p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
</li>
<li><p>不支持事务。</p>
</li>
<li><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。<br>但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>事务：InnoDB是事务型的，可以使用<code>COMMIT</code>和<code>ROLLBACK</code>语句。</li>
<li>并发：MyISAM只支持表级锁，InnoDB支持行级锁</li>
<li>外键：InnoDB支持外键</li>
<li>备份：InnoDB支持在线热备份</li>
<li>崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复速度也更慢</li>
<li>其他特性：MyISAM支持压缩表和空间数据索引</li>
</ul>
</li>
</ul>
<hr>
<h2 id="16、数据库并发事务会带来哪些问题？"><a href="#16、数据库并发事务会带来哪些问题？" class="headerlink" title="16、数据库并发事务会带来哪些问题？"></a>16、数据库并发事务会带来哪些问题？</h2><p>数据库并发会带来脏读、幻读、丢弃更改、不可重复读四个常见问题</p>
<p><b>脏读</b>：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务的结果就是脏数据了。【读取的数据和他应该是的数据不一致】</p>
<p><b>幻读</b>：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了。【强调范围】</p>
<p><b>丢弃修改</b>：两个写事务T1,T2同时对A &#x3D; 0进行递增操作，结果T2覆盖了T1，导致最终结果是1而不是2，事务被覆盖。</p>
<p><b>不可重复读</b>：T2读取一个数据，然后T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。【两次读结果不同】</p>
<blockquote>
<p>脏读：读的变量在后来被修改了<br>幻读：读取的范围之间的值有变化<br>丢弃修改：两个同时写，一个写会被覆盖<br>不可重复读：两次读的结果不同</p>
</blockquote>
<ul>
<li><p>脏读</p>
<img src="/2022/02/22/Database/DirtyRead.png" class="">
<p>第一个事务首先读取var变量为50，接着准备更新为100的时候，并未提交。<br>第二个事务已经读取var变量未100，此时第一个事务进行了回滚。<br>最终导致第二个事务读取的var和数据库的var不一样。</p>
</li>
<li><p>幻读</p>

<p>T1读取某个范围的数据。<br>T2在这个范围内插入新的数据。<br>T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。</p>
</li>
<li><p>丢弃修改</p>
<img src="/2022/02/22/Database/ModifyCancel.png" class="">
<p>T1和T2两个事务都对一个数据进行修改。<br>T1先修改，T2后修改，T2的修改覆盖了T1的修改。</p>
</li>
</ul>
<p>例如：事务1读取某表中的数据A &#x3D; 50，事务2也读取A &#x3D; 50，事务1修改A &#x3D; A + 50，事务2也修改A &#x3D; A + 50，最终结果A &#x3D; 100，事务1 的修改被丢失。</p>
<ul>
<li>不可重复读<img src="/2022/02/22/Database/UnrepeatedRead.png" class="">
T2读取一个数据，T1对该数据做了修改。<br>如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li>
</ul>
<hr>
<h2 id="17、数据库悲观锁和乐观锁的原理和应用场景？"><a href="#17、数据库悲观锁和乐观锁的原理和应用场景？" class="headerlink" title="17、数据库悲观锁和乐观锁的原理和应用场景？"></a>17、数据库悲观锁和乐观锁的原理和应用场景？</h2><ul>
<li><p>悲观锁<br>先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事物以外修改数据。<br>当数据库执行 SELECT … FOR UPDATE 时会获取被SELECT中的数据行的行锁<br>SELECT FOR UPDATE获取的行锁会在当前事物结束时自动释放，因此必须在事务中使用</p>
</li>
<li><p>乐观锁<br>先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。<br>Java并发包中的AtomicFieldUpdater类似，也是利用CAS机制，并不会对数据加锁，而是通过对比数据的时间戳或版本号，来实现乐观锁需要的版本判断。</p>
</li>
</ul>
<hr>
<h2 id="18、MySQL索引主要使用的两种数据结构是什么？"><a href="#18、MySQL索引主要使用的两种数据结构是什么？" class="headerlink" title="18、MySQL索引主要使用的两种数据结构是什么？"></a>18、MySQL索引主要使用的两种数据结构是什么？</h2><ul>
<li><p>哈希索引<br>对于哈希索引来说，底层的数据结构肯定是哈希表。<br>因此<b>在绝大多数需求为单条记录查询</b>的时候，可以选择哈希索引，查询性能最快；<br>其余大部分场景，建议选择BTree索引</p>
</li>
<li><p>BTree索引<br>MySQL的BTree索引使用的是B树中的B+Tree<br>BTree索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历Node，获得叶子结点。</p>
</li>
</ul>
<h2 id="但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。"><a href="#但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。" class="headerlink" title="但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。"></a>但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</h2><h2 id="19、数据库为什么要进行分库和分表？都放在一个库或者一张表中不行？"><a href="#19、数据库为什么要进行分库和分表？都放在一个库或者一张表中不行？" class="headerlink" title="19、数据库为什么要进行分库和分表？都放在一个库或者一张表中不行？"></a>19、数据库为什么要进行分库和分表？都放在一个库或者一张表中不行？</h2><p>分库和分表的目的在于：减小数据库的单库单标负担，提高查询性能，缩短查询时间。</p>
<ul>
<li><p>分表<br>可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用。<br>此外，可以很大地缓解表锁的问题。<br>分表策略可以归纳为垂直拆分和水平拆分：</p>
<ul>
<li><p>水平分表：<br>取模分表就属于随机分表，而时间维度分表则属于连续分表。</p>
</li>
<li><p>垂直分表：<br>将不常用的字段单独拆分到另外一张扩展表<br>将大文本的字段单独拆分到另外一张扩展表<br>将不经常修改的字段放在同一张表中<br>将经常改变的字段放在另一张表中。</p>
</li>
</ul>
<p>对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</p>
<ul>
<li><p>库内分表：<br>仅仅是解决单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻MySQL服务器的压力<br>仍然存在同一个物理机上的资源竞争和瓶颈，包括CPU、内存、磁盘IO、网络带宽等。</p>
</li>
<li><p>分库和分表带来的分布式困境和应对之策。</p>
<ol>
<li><p>数据迁移和扩容问题：一般做法是通过程序先读出数据，然后按照指定的分表策略再讲数据写入到各个分表中。</p>
</li>
<li><p>分页与排序问题：需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="20、不可重复读和幻读的区别？"><a href="#20、不可重复读和幻读的区别？" class="headerlink" title="20、不可重复读和幻读的区别？"></a>20、不可重复读和幻读的区别？</h2><ul>
<li><p>例子1（同样的条件，两次读取结果不一样）<br>事务1中读取 A &#x3D; 1000 的操作还没完成，事务2中修改了 A &#x3D; 2000。<br>此时事务1再读取 A 时候 A &#x3D; 2000，两次读取结果不一样</p>
</li>
<li><p>例子2（同样的条件，第1次和第2次读出来的记录数不一样）<br>某表中，X 字段大于3000的有4个记录<br>事务1中读取了X字段大于3000的人，共4条记录，<br>事务2中插入了一条X字段大于3000的记录<br>事务1再次读取时记录变为了5条，两次读取的记录数不一样。</p>
</li>
</ul>
<blockquote>
<p>不可重复读的重点是修改，幻读的重点在于新增或删除。</p>
</blockquote>
<hr>
<h2 id="21、MySQL中有四种索引类型？"><a href="#21、MySQL中有四种索引类型？" class="headerlink" title="21、MySQL中有四种索引类型？"></a>21、MySQL中有四种索引类型？</h2><ul>
<li><p>FULLTEXT（全文索引）<br>全文索引，目前只有MyISAM支持。<br>可以在CREATE TABLE, ALTER TABLE, CREATE INDEX使用<br>不过目前只有 CHAR, VARCHAR, TEXT 列上可以创建全文索引。</p>
</li>
<li><p>HASH（哈希）<br>由于HASH的唯一（几乎100%的唯一）以及类似键值对的形式，很适合作为索引。<br>HASH索引可以一次定位，不需要树形索引那样逐层查找，因此具有极高效率。<br>但这种高效有条件，即只在”&#x3D;”和”in”条件下高效，对于范围查询、排序和组合索引仍然效率不高。</p>
</li>
<li><p>BTREE<br>BTREE索引就是一种将索引值按一定算法，存入到一个树形的数据结构中（二叉树）<br>每次查询都是从树的入口root开始，依次遍历node，获取叶子结点。<br>这是MySQL里默认和最常用的索引类型。</p>
</li>
<li><p>RTREE<br>RTREE在MySQL中很少使用，仅支持Gemometry类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDB、NDb、Archive几种。<br>相比于BTREE，RTREE的优势在于范围查找。</p>
</li>
</ul>
<hr>
<h2 id="22、视图的作用是什么？可以更改吗？"><a href="#22、视图的作用是什么？可以更改吗？" class="headerlink" title="22、视图的作用是什么？可以更改吗？"></a>22、视图的作用是什么？可以更改吗？</h2><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；</p>
<p>不包含任何列或数据，使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；<br>视图创建后，可以使用与表相同的方式利用他们。</p>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。</p>
<p>创建视图：create view xxx as xxx</p>
<p>对于某些视图比如未使用联合子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新。<br>但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>
<blockquote>
<p>视图优点：</p>
<ol>
<li>视点集中，只用关心视图定义的数据而非引用表中数据</li>
<li>简化操作，可以只对视图本身查询，隐藏表与表之间复杂的连接</li>
<li>定制数据，可以让不同要求用户看到不同或相同的数据集</li>
<li>合并分割数据，不用更改表原先的结构，可以让视图保持原来的结构关系，外模式不变，但应用程序可以通过视图重载数据</li>
<li>安全性，用户只可以看到或修改他们能看到的数据，其他数据不可见也不可访问。</li>
</ol>
</blockquote>
<hr>
<h2 id="23、为什么时候B-Tree比BTree更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#23、为什么时候B-Tree比BTree更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="23、为什么时候B+Tree比BTree更适合实际应用中操作系统的文件索引和数据库索引？"></a>23、为什么时候B+Tree比BTree更适合实际应用中操作系统的文件索引和数据库索引？</h2><p>B+tree的磁盘读写代价更低，B+tree的查询效率更加稳定【因为必须查询到底】</p>
<p>数据库索引采用B+树而不是B树的主要原因：<br>  B+树只要遍历叶子结点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的<br>  而B树只能中序遍历所有结点，效率太低。</p>
<p>B+树的特点：</p>
<ul>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。</li>
</ul>
<hr>
<h2 id="24、场景题：如果所在公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，优化手段？"><a href="#24、场景题：如果所在公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，优化手段？" class="headerlink" title="24、场景题：如果所在公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，优化手段？"></a>24、场景题：如果所在公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，优化手段？</h2><ul>
<li><p>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</p>
</li>
<li><p>选择合适的表字段数据结构类型和存储引擎，适当地添加索引。</p>
</li>
<li><p>MySQL库主从读写分离。</p>
</li>
<li><p>找规律分表，减少单表中的数据量提高查询速度。</p>
</li>
<li><p>添加缓存机制，比如Memcached，Apc等。</p>
</li>
<li><p>不经常改动的页面，生成静态页面。</p>
</li>
<li><p>书写高效率的SQL，例如SELECT * FROM TABLE 改为 SELECT field_1, field_2, field_3 FROM TABLE。</p>
</li>
</ul>
<hr>
<h2 id="25、什么时候需要建立数据库索引？"><a href="#25、什么时候需要建立数据库索引？" class="headerlink" title="25、什么时候需要建立数据库索引？"></a>25、什么时候需要建立数据库索引？</h2><p>适合：<br>  在最频繁使用的、用以缩小查询范围的字段，需要排序的字段上建立索引</p>
<p>不适合：</p>
<ol>
<li>对于查询中很少涉及的列或重复值较多的列</li>
<li>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。</li>
</ol>
<hr>
<h2 id="26、覆盖索引是什么？"><a href="#26、覆盖索引是什么？" class="headerlink" title="26、覆盖索引是什么？"></a>26、覆盖索引是什么？</h2><p>如果一个索引包含（或覆盖）所有需要查询的字段的值，称之为“覆盖索引”</p>
<p>在InnoDB存储引擎中，如果不是主键索引，叶子结点存储的是主键+列值。</p>
<p>最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。</p>
<h2 id="覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。"><a href="#覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。" class="headerlink" title="覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。"></a>覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。</h2><h2 id="27、数据库中的主键、超键、候选键、外键是什么？"><a href="#27、数据库中的主键、超键、候选键、外键是什么？" class="headerlink" title="27、数据库中的主键、超键、候选键、外键是什么？"></a>27、数据库中的主键、超键、候选键、外键是什么？</h2><ul>
<li><p>超键：在关系中能唯一标识<b>元组属性集</b>称为关系模式的超键【一个属性或者多个属性总和】</p>
</li>
<li><p>候选键：不含有<b>多余属性的超键</b>称为候选键。也就是在候选键中，任删除一个属性，就不是键了</p>
</li>
<li><p>主键：<b>用户选作元组标识的一个候选键称为主键</b></p>
</li>
<li><p>外键：如果关系模式R中<b>属性K是其他模式的主键</b>，那么K在模式R中称为外键。</p>
</li>
</ul>
<p>举例：</p>
<table>
<thead>
<tr>
<th align="left">学号</th>
<th align="left">姓名</th>
<th align="left">性别</th>
<th align="left">年龄</th>
<th align="left">系别</th>
<th align="left">专业</th>
</tr>
</thead>
<tbody><tr>
<td align="left">20020612</td>
<td align="left">A</td>
<td align="left">男</td>
<td align="left">20</td>
<td align="left">计算机</td>
<td align="left">软件开发</td>
</tr>
<tr>
<td align="left">20060613</td>
<td align="left">B</td>
<td align="left">男</td>
<td align="left">18</td>
<td align="left">计算机</td>
<td align="left">软件开发</td>
</tr>
<tr>
<td align="left">20060614</td>
<td align="left">C</td>
<td align="left">女</td>
<td align="left">19</td>
<td align="left">物理</td>
<td align="left">力学</td>
</tr>
<tr>
<td align="left">20060615</td>
<td align="left">D</td>
<td align="left">女</td>
<td align="left">17</td>
<td align="left">生物</td>
<td align="left">动物学</td>
</tr>
<tr>
<td align="left">20060616</td>
<td align="left">E</td>
<td align="left">男</td>
<td align="left">21</td>
<td align="left">化学</td>
<td align="left">食品化学</td>
</tr>
<tr>
<td align="left">20060617</td>
<td align="left">F</td>
<td align="left">女</td>
<td align="left">20</td>
<td align="left">生物</td>
<td align="left">植物学</td>
</tr>
</tbody></table>
<ol>
<li><p>超键：例子中可以发现，学号是标识学生实体的唯一标识。那么元组的超键就为学号。<br>  除此之外，还可以将它和其他属性组合起来，例如：（学号，性别）、（学号，年龄）</p>
</li>
<li><p>候选键：学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键。事实上，候选键是超键的子集。<br>    比如（学号，年龄）是超键，但并非候选键。因为它还有了额外的属性。【不含有多余属性的超键】</p>
</li>
<li><p>主键：例子中元组候选键是学号，但选定学号为该元组的唯一标识，学号就成为了主键。</p>
</li>
<li><p>外键：相对于主键，例如在该表中，学号是主键，在成绩单表中，也有学号字段，因此学号是成绩单表的外键。</p>
</li>
</ol>
<hr>
<h2 id="28、数据库三大范式"><a href="#28、数据库三大范式" class="headerlink" title="28、数据库三大范式"></a>28、数据库三大范式</h2><ul>
<li><p>第一范式<br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。<br>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体的某个属性不能有多个值或不能有重复属性。</p>
<p>如果出现重复的属性，则可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。<br>在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<blockquote>
<p>简言之，<b>第一范式是无重复的列</b></p>
</blockquote>
</li>
<li><p>第二范式<br>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的。<br>即满足第二范式（2NF）必须先满足第一范式（1NF）。</p>
<p>第二范式（2NF）要求数据库表中的每个实例或行必须可被<b>唯一地区分</b>。</p>
<p>为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。<br>这个唯一属性列被称为主关键字或主键、主码。<br>第二范式（2NF）要求实体的属性完全依赖于主关键字。</p>
<p>所谓完全依赖是指不能存在仅依赖关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体和原实体之间应该是一对多的关系。<br>为了实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。</p>
<blockquote>
<p>简言之，<b>第二范式就是非主属性非部分依赖于主关键字</b>。</p>
</blockquote>
</li>
<li><p>第三范式<br>满足第三范式（3NF）必须先满足第二范式（2NF）。<br>简言之，第三范式（3NF）要求一个数据库表中不包含已在其他表中已包含的非主关键字信息。</p>
<p>例如：存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。<br>  那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。<br>  如果不存在部门信息表，则根据第三范式（3NF）也应该构建他它，否则就会有大量的数据冗余。</p>
<blockquote>
<p>简言之，第三范式就是属性不依赖于其他非主属性</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="29、数据库三大范式精要总结"><a href="#29、数据库三大范式精要总结" class="headerlink" title="29、数据库三大范式精要总结"></a>29、数据库三大范式精要总结</h2><ol>
<li><p>简单归纳：</p>
</li>
<li><p>第一范式（1NF）：字段不可分</p>
</li>
<li><p>第二范式（2NF）：有主键，非主键字段依赖主键</p>
</li>
<li><p>第三范式（3NF）：非主键字段不能相互依赖【员工ID，员工信息，部门ID，部门信息】</p>
</li>
<li><p>解释：</p>
</li>
<li><p>1NF：原子性。字段不可再分，否则就不是关系数据库。</p>
</li>
<li><p>2NF：唯一性。一个表只说明一个事物。</p>
</li>
<li><p>3NF：每列都与主键有直接关系，不存在传递依赖。</p>
</li>
</ol>
<hr>
<h2 id="30、MySQL常见的存储引擎InnoDB，MyISAM的区别？适用场景分别是？"><a href="#30、MySQL常见的存储引擎InnoDB，MyISAM的区别？适用场景分别是？" class="headerlink" title="30、MySQL常见的存储引擎InnoDB，MyISAM的区别？适用场景分别是？"></a>30、MySQL常见的存储引擎InnoDB，MyISAM的区别？适用场景分别是？</h2><ol>
<li><p>事务：MyISAM不支持，InnoDB支持；</p>
</li>
<li><p>锁级别：MyISAM表级锁，InnoDB行级锁及外键约束；</p>
</li>
<li><p>存储行数：MyISAM存储表的总行数，InnoDB不存储表的总行数；</p>
</li>
<li><p>索引：MyISAM采用非聚簇索引，B+树叶子结点<b>存储指向数据文件的指针</b>。<br> InnoDB主键索引采用聚簇索引，B+树叶子<b>存储数据</b>。</p>
</li>
</ol>
<p>适用场景：<br>  MyISAM适合：插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择，没有事务。<br>  InnoDB适合：可靠性要求比较高，或者要求事务；表更新和查询都相当频繁，大量的INSERT或UPDATE</p>
<hr>
<h2 id="31、事务四大特性（ACID）原子性、一致性、隔离性、持久性？"><a href="#31、事务四大特性（ACID）原子性、一致性、隔离性、持久性？" class="headerlink" title="31、事务四大特性（ACID）原子性、一致性、隔离性、持久性？"></a>31、事务四大特性（ACID）原子性、一致性、隔离性、持久性？</h2><ol>
<li><p>原子性（Atomicity）<br>  原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。<br>  因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
</li>
<li><p>一致性（Consistency）<br>  事务开始前和结束后，数据库的完整性约束没有被破坏。<br>  比如A向B转账，不可能A扣了钱，B却没收到。</p>
</li>
<li><p>隔离性（Isolation）<br>  隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事物之间要相互隔离。<br>  同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。<br>  比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。<br>  事物的隔离性，数据库提供了多种隔离级别。【READ-UNCOMMITTD&#x2F;READ-COMMITTED&#x2F;REPEATABLE-READ&#x2F;SERIALIZABLE】</p>
</li>
<li><p>持久性（Durability）<br>  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。<br>  即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
</li>
</ol>
<hr>
<h2 id="32、SQL中的NOW-和CURRENT-DATA-两个函数有什么区别？"><a href="#32、SQL中的NOW-和CURRENT-DATA-两个函数有什么区别？" class="headerlink" title="32、SQL中的NOW()和CURRENT_DATA()两个函数有什么区别？"></a>32、SQL中的NOW()和CURRENT_DATA()两个函数有什么区别？</h2><p>NOW()命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE()仅显示当前年份，月份和日期。</p>
<hr>
<h2 id="33、聚合索引？"><a href="#33、聚合索引？" class="headerlink" title="33、聚合索引？"></a>33、聚合索引？</h2><p>聚簇索引就是按照拼音查询<br>非聚簇索引就是按照偏旁等进行查询</p>
<p>其实汉语字典<code>正文</code>本身就是一个聚簇索引。</p>
<p>比如要查“安”字，会自然翻开字典前几页，因为“安”的拼音是“an”<br>而按照拼音排序，汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”就自然地排在字典的首部。<br>如果翻完了所有“a”开头的部分仍找不到，说明字典中没这个字；<br>如果查“张”字，那也会将字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说字典的正文部分本身就是一个目录，不需要在找其他目录来找到想要内容。</p>
<h2 id="于是，把这种正文内容本身就是一种按照一定规则排列的目录称为“聚簇索引”。"><a href="#于是，把这种正文内容本身就是一种按照一定规则排列的目录称为“聚簇索引”。" class="headerlink" title="于是，把这种正文内容本身就是一种按照一定规则排列的目录称为“聚簇索引”。"></a>于是，把这种<b>正文内容本身就是一种按照一定规则排列的目录称为“聚簇索引”</b>。</h2><h2 id="34、什么是非聚簇索引"><a href="#34、什么是非聚簇索引" class="headerlink" title="34、什么是非聚簇索引"></a>34、什么是非聚簇索引</h2><p>如果认识某个字，可以快速地从自动中查到这个字。</p>
<p>但也可能会遇到不认识的字，不知道发音，这时候就不能按照刚才的方法找到要查的字，而需要去根据“偏旁部首”查到要找的字<br>然后根据这个字的页码直接翻到某页来找到要找的字（相当于找到页码）。</p>
<p>但结合“部首目录”和“检字表”查到的字的排序并不是真正正文的排序方法。<br>例如“张”，查部首检字表显示672页。“驰”页码显示63页。“弩”页码显示390页。</p>
<p>显然，这些字并不是真正的分别位于“张”字上下方，但看到的连续的三个字实际上就是他们在非聚簇索引中的排序，是字典正文中的字在非聚簇索引中的映射。<br>我们可以通过这种方式来找到需要的字，但需要两个过程，<code>先找目录，再翻到页码</code></p>
<h2 id="于是，把目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚簇索引”"><a href="#于是，把目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚簇索引”" class="headerlink" title="于是，把目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚簇索引”"></a>于是，把<b>目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚簇索引”</b></h2><h2 id="35、聚簇索引和非聚簇索引的区别是什么？"><a href="#35、聚簇索引和非聚簇索引的区别是什么？" class="headerlink" title="35、聚簇索引和非聚簇索引的区别是什么？"></a>35、聚簇索引和非聚簇索引的区别是什么？</h2><p>聚簇索引和非聚簇索引的区别在于：<br>  通过聚簇索引可以查到需要查找的数据<br>  通过非聚簇索引可以查到记录对应的主键值，再使用主键值通过聚簇索引查找到需要的数据。</p>
<p>  聚簇索引和非聚簇索引的根本区别是表记录的排列顺序和索引的排列顺序是否一致。</p>
<p>聚簇索引（InnoDB）的叶结点就是数据结点<br>非聚簇索引（MyISAM）的叶结点仍然是索引结点，只不过其包含一个指向对应数据块的指针。</p>
<hr>
<h2 id="36、创建索引时需要注意什么？"><a href="#36、创建索引时需要注意什么？" class="headerlink" title="36、创建索引时需要注意什么？"></a>36、创建索引时需要注意什么？</h2><ul>
<li><p>非空字段：应该制定列为NOT NULL，除非想存储NULL。<br>在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。<br>应该用0、一个特殊的值或者一个空串代替空值。</p>
</li>
<li><p>取值离散大的字段：<br>（变量各个取值之间的差异速度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值。<br>返回值越大说明字段的唯一值越多字段的离散程度高。【说明不同键的信息越多】</p>
</li>
<li><p>索引字段越小越好：<br>数据库的数据存储以页为单位，一页存储的数据越多，一次IO操作获取的数据越大、效率越高。<br>唯一、不为空、经常被查询的字段更适合建索引。【字段越小，一页存储的东西越多】</p>
</li>
</ul>
<hr>
<h2 id="37、MySQL中CHAR和VARCHAR的区别有哪些？"><a href="#37、MySQL中CHAR和VARCHAR的区别有哪些？" class="headerlink" title="37、MySQL中CHAR和VARCHAR的区别有哪些？"></a>37、MySQL中CHAR和VARCHAR的区别有哪些？</h2><ul>
<li><p>char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。</p>
</li>
<li><p>char的存取速度比varchar要快得多</p>
</li>
<li><p>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用2个字节。【相当于填充到1B或者2B】<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p>
</li>
</ul>
<hr>
<h2 id="38、MySQL索引使用的注意事项"><a href="#38、MySQL索引使用的注意事项" class="headerlink" title="38、MySQL索引使用的注意事项"></a>38、MySQL索引使用的注意事项</h2><p>MySQL索引通常是被用于提高Where条件的数据行匹配时的搜索速度，在索引使用过程中，存在一些使用细节和注意事项。</p>
<p>函数，运算，否定操作符，连接条件，多个单列索引，最左前缀原则，范围查询，不会包含有NULL值的列，like语句不要在列上使用函数和进行运算。</p>
<ol>
<li>不要在列上使用函数，这将导致索引失效而进行全表扫描。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">year</span>(publish_time) <span class="operator">&lt;</span> <span class="number">2017</span></span><br><span class="line"><span class="comment">-- 避免使用函数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>为了使用索引，防止执行全表扫描，可以进行改造。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> publish_time <span class="operator">&lt;</span> <span class="string">&#x27;2017-01-01&#x27;</span></span><br></pre></td></tr></table></figure>

<p>还有一个建议，不要在列上进行运算，这也将导致索引失效而进行全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id <span class="operator">/</span> <span class="number">100</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>为了使用索引，防止执行全表扫描，可以进行改造。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="operator">*</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>尽量避免使用 !&#x3D; 或 not in 或 &lt;&gt; 等否定运算符<br>应该尽量避免在where子句中使用 !&#x3D; 或 not in 或 &lt;&gt; 操作符，因为这几个操作符都会导致索引失效而进行全表扫描。</li>
</ol>
<p>尽量避免使用or来连接条件，应该尽量避免在where子句中使用or来连接条件，因为这会导致索引失效而进行全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> id <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多个单列索引并不是最佳选择<br>MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高MySQL的查询性能。</li>
</ol>
<p>假如，有两个单列索引，分别为：<br>news_year_idx(news_year)和news_month_idx(news_month)。</p>
<p>现在，有一个场景需要针对咨询的年份和月份进行查询，那么SQL语句可以写成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> news_year <span class="operator">=</span> <span class="number">2017</span> <span class="keyword">and</span> news_month <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>事实上，MySQL只能使用一个单列索引。<br>为了提高性能，可以使用复合索引news_year_month_idx(news_year, news_month)保证news_year和news_month两个列都被索引覆盖。</p>
<ol start="4">
<li>复合索引的最左前缀原则<br>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。</li>
</ol>
<p>因此，在复合索引中索引列的顺序至关重要。如果不是按照所以你的最左列开始查找，则无法使用索引。<br>假设，有一个场景只需要针对咨询的月份进行查询，那么SQL语句可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> news_month <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="comment">-- 最左使用的是news_year，而非news_month，索引不会被使用</span></span><br></pre></td></tr></table></figure>

<p>此时，无法使用news_year_month_idx(news_year, news_month)索引<br>因为遵守“最左前缀”原则，在查询条件中没有使用复合索引的第一个字段，索引不会被使用。</p>
<ol start="5">
<li><p>覆盖索引的好处<br>如果一个索引包含所有需要查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大地提高性能。<br>因此可以定义一个让索引包含的额外的列，即这个列对于索引而言是无用的。</p>
</li>
<li><p>范围查询对多列查询的影响<br>查询中某个列有范围查询，则其右边所有列都无法使用索引优化查找。</p>
</li>
</ol>
<p>举个例子：假设一个场景需要查询本周发布的咨询文章，其中的条件是必须是启用状态，且发布时间在本周内。<br>那么SQL语句可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> publish_time <span class="operator">&gt;=</span> <span class="string">&#x27;2017-01-02&#x27;</span> <span class="keyword">and</span> publish_time <span class="operator">&lt;=</span> <span class="string">&#x27;2017-01-08&#x27;</span> <span class="keyword">and</span> enable <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，因为范围查询对多列查询的影响，将导致news_publish_idx(publish_time, enable)索引中publish_time右边所有列都无法使用索引优化查找。</p>
<p>换句话说，news_publish_idx(publish_time, enable)索引等价于news_publish_idx(publish_time)。</p>
<p>对于这种情况，可以：<br>对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以用别的方法间接实现业务场景。</p>
<p>例如：上面案例的需求是查询本周发布的咨询文章，一次可以创建一个news_weekth字段用来存储咨询文章周信息，使得范围查询变成普通查询，SQL可以改写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> news_weekth <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> enable <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，可以：<br>不必试图用SQL来解决所有问题，可以使用其他数据存储技术控制时间轴，如Redis的SortedSet有序集合保存时间，或者通过缓存方式缓存查询结果提高性能。</p>
<ol start="7">
<li><p>索引不会包含有NULL值的列<br>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。<br>因此，在数据库设计时，除非有一个特别原因使用NULL值，否则尽量不要让字段默认值为NULL。</p>
</li>
<li><p>隐式转换的影响<br>当查询条件左右两侧类型不匹配时会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。<br>下面的案例中，date_str是字符串，然而匹配的是整数类型，从而发生隐式转换。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> date_str <span class="operator">=</span> <span class="number">201701</span></span><br></pre></td></tr></table></figure>

<p>因此要谨记隐式转换的危害，时刻注意通过同类型进行比较。</p>
<ol start="9">
<li>like语句的索引失效问题<br>like的方式进行查询，在like “value %” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题。<br>但是对于海量数据，全表扫描十分可怕。<br>所以根据业务需求，考虑使用ElasticSearch 或 Solr 是个不错的方案。</li>
</ol>
<hr>
<h2 id="39、MySQL中有哪些索引？特点？"><a href="#39、MySQL中有哪些索引？特点？" class="headerlink" title="39、MySQL中有哪些索引？特点？"></a>39、MySQL中有哪些索引？特点？</h2><ul>
<li><p>普通索引：仅加速查询</p>
</li>
<li><p>唯一索引：加速查询 + 列值唯一（可以有NULL）</p>
</li>
<li><p>主键索引：加速查询 + 列值唯一（不可有NULL） + 表中只有一个</p>
</li>
<li><p>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p>
</li>
<li><p>全文索引：对文本的内容进行分词，进行搜索</p>
</li>
<li><p>索引合并：使用多个单列索引组合搜索</p>
</li>
<li><p>覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p>
</li>
<li><p>聚簇索引：表数据是和主键一起存储的，主键索引的叶子结点存储了行数据（包含了主键值），二级索引的叶结点存储行的主键值。【副索引查主键】<br>     使用的是B+树作为索引的存储结构，非叶子结点都是索引关键字，但非叶子结点中的关键字中不存储对应记录的具体内容或内容地址。<br>     叶子结点上的数据是主键与具体记录（数据内容）</p>
</li>
</ul>
<hr>
<h2 id="40、既然索引有那么多优点，为什么不对表的每一列创建一个索引？"><a href="#40、既然索引有那么多优点，为什么不对表的每一列创建一个索引？" class="headerlink" title="40、既然索引有那么多优点，为什么不对表的每一列创建一个索引？"></a>40、既然索引有那么多优点，为什么不对表的每一列创建一个索引？</h2><ul>
<li><p>当对表中数据进行增加、删除和修改的时候，<b>索引也要动态地维护</b>，这样就降低了数据的维护速度。</p>
</li>
<li><p><b>索引需要占物理空间</b>，除了数据表占数据空间之外，每个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间也就更大。</p>
</li>
<li><p><b>创建索引和维护索引要耗费时间</b>，这种时间会随着数据量的增加而增加。</p>
</li>
</ul>
<hr>
<h2 id="41、索引是如何提高查询速度的？"><a href="#41、索引是如何提高查询速度的？" class="headerlink" title="41、索引是如何提高查询速度的？"></a>41、索引是如何提高查询速度的？</h2><h2 id="将无序的数据变成相对有序的数据（就像查有目的一样）"><a href="#将无序的数据变成相对有序的数据（就像查有目的一样）" class="headerlink" title="将无序的数据变成相对有序的数据（就像查有目的一样）"></a>将无序的数据变成相对有序的数据（就像查有目的一样）</h2><h2 id="42、使用索引的注意事项"><a href="#42、使用索引的注意事项" class="headerlink" title="42、使用索引的注意事项"></a>42、使用索引的注意事项</h2><ul>
<li><p>在经常需要搜索的列上，可以加快搜索的速度。</p>
</li>
<li><p>在经常使用在where子句中的列上面创建索引，加快条件的判断速度。</p>
</li>
<li><p><b>将打算加索引的列设置成为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描</b></p>
</li>
<li><p>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
</li>
<li><p>避免where子句中对字段施加函数，这会造成无法命中索引</p>
</li>
<li><p>在中到大型表中索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建议用逻辑索引</p>
</li>
<li><p>在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度。</p>
</li>
<li><p>与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，也不要用业务主键。</p>
</li>
<li><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。</p>
</li>
<li><p>在使用limit offset查询缓存时，可以借助索引来提高性能。</p>
</li>
</ul>
<hr>
<h2 id="43、增加B-树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优查询效率？"><a href="#43、增加B-树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优查询效率？" class="headerlink" title="43、增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优查询效率？"></a>43、增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优查询效率？</h2><p>不可以。<br>因为这样最终会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。<br>有序数组没法一次性加载进内存，这时B+树多路存储的好处就体现出来了，一次加载B+树的一个结点，恰好一个盘，然后一步步往下找。</p>
<hr>
<h2 id="44、数据库的表锁和列锁？"><a href="#44、数据库的表锁和列锁？" class="headerlink" title="44、数据库的表锁和列锁？"></a>44、数据库的表锁和列锁？</h2><ul>
<li><p>表锁<br>不会出现死锁，发生锁冲突几率高，并发低。<br>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁；<br>在执行增删改操作前，会自动给涉及的所有表加写锁。</p>
<p>MySQL的表级锁有两种模式：<code>表共享读锁</code>和<code>表独占写锁</code></p>
<p>读锁会阻塞写，写锁会阻塞读和写</p>
<ul>
<li>对MyISAM表的<b>读操作</b>，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程写操作。</li>
<li>对MyISAM表的<b>写操作</b>，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</li>
</ul>
<p>MyISAM不适合做写为主表的引擎，因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而永久阻塞。</p>
</li>
<li><p>行锁<br>会出现死锁，发生锁冲突几率低，并发高。</p>
<p>在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的行锁是通过索引加载的<br>也就是说，行锁是加载索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，行锁则无法实现，取而代之的是表锁。<br>此时其他事物无法对当前表进行更新或插入操作。</p>
</li>
<li><p>行锁的实现需要注意：</p>
<ul>
<li><p>行锁必须有索引才能实现，否则会自动锁全表，那就不是行锁了。</p>
</li>
<li><p>两个事务不能锁同一个索引。</p>
</li>
<li><p>insert，delete，update在事务中都会自动默认加上排他锁。</p>
</li>
</ul>
</li>
<li><p>行锁的适用场景<br>A 用户消费，Service层先查询该用户的账户余额，若余额足够，则进行后续扣款操作，这种情况查询时应该对该记录进行加锁。</p>
<p>否则，B 用户在 A 用户查询后消费前抢先一步将 A 用户账号上的钱转走<br>而此时 A 用户已经进行了用户余额是否足够的判断，则可能会出现用户余额不足但扣款成功情况。</p>
<p>为了避免此情况，需要在 A 用户操作该记录的时候进行 FOR UPDATE 加锁。</p>
</li>
</ul>
<hr>
<h2 id="45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？"><a href="#45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？" class="headerlink" title="45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？"></a>45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？</h2><ul>
<li><p>内连接：<br>只有两个元素表相匹配的才能在结果集中显示。</p>
</li>
<li><p>外连接：</p>
<ul>
<li>左外连接：左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。</li>
<li>右外连接：右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。</li>
<li>全外连接：连接中的表中不匹配的数据全部会显示出来。</li>
</ul>
</li>
<li><p>交叉连接：<br>笛卡尔积，显示的结果是链接表数的乘积。</p>
</li>
</ul>
<hr>
<h2 id="46、你知道哪些数据库结构优化的手段？"><a href="#46、你知道哪些数据库结构优化的手段？" class="headerlink" title="46、你知道哪些数据库结构优化的手段？"></a>46、你知道哪些数据库结构优化的手段？</h2><ul>
<li><p>范式优化：<br>比如消除冗余（节省空间）</p>
</li>
<li><p>反范式优化<br>比如适当添加冗余（减少表的链接）</p>
</li>
<li><p>限定数据的范围：<br>务必禁止不带任何限制数据范围条件的查询语句。<br>例如：当用户在查询历史订单的时候，可以将时间控制在一个月的范围内。</p>
</li>
<li><p>读&#x2F;写分离：<br>经典数据库拆分方案，主库负责写，从库负责读。</p>
</li>
<li><p>拆分表：<br>分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。<br>这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间<br>另外处于不同磁盘的分区也将对这个标的数据传输分散在不同的磁盘I&#x2F;O，一个精心设置的分区可以将数据传输对磁盘I&#x2F;O竞争均匀地分散开。<br>对数据量大的时候表可以采取此方法，可按月自动建表分区。</p>
</li>
</ul>
<hr>
<h2 id="47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于差分数据了解哪些？"><a href="#47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于差分数据了解哪些？" class="headerlink" title="47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于差分数据了解哪些？"></a>47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于差分数据了解哪些？</h2><p>拆分分为<code>垂直拆分</code>和<code>水平拆分</code></p>
<p>案例：简单购物系统暂涉及如下表：<br>一、产品表（数据量10W，稳定）<br>二、订单表（数据量200W，且有增长趋势）<br>三、用户表（数据量100W，且有增长趋势）<br>以MySQL为例讲述水平拆分和垂直拆分，MySQL能容忍的数量级在百万静态数据可以到千万。</p>
<ul>
<li><p>垂直拆分【专库专用，不同表拆到不同数据库中】<br>解决问题：表与表之间的I&#x2F;O竞争<br>不解决问题：单表中数据量增长出现的压力<br>方案：把产品表和用户表放到一个Server上，订单表单独放到另一个Server上。</p>
</li>
<li><p>水平拆分【同一个表拆到不同数据库中】<br>解决问题：单表中数据增长出现的压力<br>不解决问题：表于表之间的I&#x2F;O竞争<br>方案：</p>
<ol>
<li>用户表：通过性别拆分为男用户表和女用户表</li>
<li>订单表：通过已完成和完成中拆分为已完成订单和未完成订单</li>
<li>产品表：未完成订单放在一个Server上，已完成订单和男用户表放在一个Server上，女用户表放一个Server上。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="48、为什么MySQL索引要使用B-树，而不是B树或者红黑树？"><a href="#48、为什么MySQL索引要使用B-树，而不是B树或者红黑树？" class="headerlink" title="48、为什么MySQL索引要使用B+树，而不是B树或者红黑树？"></a>48、为什么MySQL索引要使用B+树，而不是B树或者红黑树？</h2><p>在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有<code>访问磁盘</code>的操作。<br>磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。<br>盘片旋转就是我们市面上所提到的多少转没分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂开始进行数据的读写。</p>
<p>那么就存在一个定位到磁盘中块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时间远远大于电子的运动。<br>当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以使用B树进行优化，提高磁盘读取时定位的效率。</p>
<p>为什么B类树可以进行优化？<br>根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息<br><code>保证层数（树的高度）尽量的少</code>，以便后面我们可以更快地找到信息<br><code>磁盘的I/O也就少一些</code>，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<h2 id="特别的：只有B-树和B-树，而B-树叫做B树，没有B减树说法。"><a href="#特别的：只有B-树和B-树，而B-树叫做B树，没有B减树说法。" class="headerlink" title="特别的：只有B-树和B+树，而B-树叫做B树，没有B减树说法。"></a>特别的：只有B-树和B+树，而B-树叫做B树，没有B减树说法。</h2><h2 id="49、为什么MySQL索引适用B-树而不用hash表和B树？"><a href="#49、为什么MySQL索引适用B-树而不用hash表和B树？" class="headerlink" title="49、为什么MySQL索引适用B+树而不用hash表和B树？"></a>49、为什么MySQL索引适用B+树而不用hash表和B树？</h2><ul>
<li><p>利用Hash需要把数据全部加载到内存中，如果数据量大，是一个很<code>消耗内存</code>的事情，而采用B+树，是基于<code>按照结点分段加载，由此减少内存消耗</code>。</p>
</li>
<li><p>和业务场景有关，对于<code>唯一查找</code>（查找一个值），Hash确实更快，但数据库中经常查询多条数据<br>这时候由于B+树的有序性，而叶子结点又有链表相邻，他的查询效率会比Hash快的多。</p>
</li>
<li><p>B+树的<code>非叶子结点不保存数据，只保存子树的临界值</code>（最大或最小），所以同样大小的节点【比如一个页框】<br><code>B+树相对于B树能够有更多的分支，使得这棵树更加矮胖，查询时候做的I/O次数也就更少</code>。</p>
</li>
</ul>
<hr>
<h2 id="50、既然Hash比B-树更快，为什么MySQL用B-树来存储索引？"><a href="#50、既然Hash比B-树更快，为什么MySQL用B-树来存储索引？" class="headerlink" title="50、既然Hash比B+树更快，为什么MySQL用B+树来存储索引？"></a>50、既然Hash比B+树更快，为什么MySQL用B+树来存储索引？</h2><p>MySQL中存储索引用到的数据结构是B+树，B+树的查询时间和树的高度有关，是O(logn)，如果用hash存储，那么查询的时间是O(1)。</p>
<p>采用Hash来存储确实要更快，但是采用B+树来存储索引的原因主要有以下两点：</p>
<ol>
<li><p><code>从内存角度来说</code>，数据库的索引一般是在磁盘上，数据量大的情况下可能无法一次性装入内存，B+树的设计可以允许数据分批加载</p>
</li>
<li><p><code>从业务场景来说</code>，如果只选择一个数据那必然是Hash更快，但是数据库中经常会选中多条【例如where】<br>此时由于B+树索引有序，而且又有链表相连，它的查询效率比Hash就快多了。</p>
</li>
</ol>
<hr>
<h2 id="51、关系型数据库的四大特性在得不到保障的情况下会怎样？"><a href="#51、关系型数据库的四大特性在得不到保障的情况下会怎样？" class="headerlink" title="51、关系型数据库的四大特性在得不到保障的情况下会怎样？"></a>51、关系型数据库的四大特性在得不到保障的情况下会怎样？</h2><p>ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</p>
<p>接下来，以从A账户转账50元到B账户为例说明ACID四大特性：</p>
<ol>
<li>原子性<br>  原子性是指一个事务是一个不可分割的工作单位，<b>其中的操作要么都做，要么都不做</b>。<br>  即要么转账成功，要么转账失败，不存在中间的状态。</li>
</ol>
<ul>
<li>如果无法保证原子性<br>就会出现数据不一致的情形，A账户减去50元，而B账户增加50元操作失败。<br>从此，系统无缘无故少了50元。</li>
</ul>
<ol start="2">
<li>一致性<br>  一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。<br>  什么是合法的数据状态？满足预定的约束就叫做合法的状态，这个状态是由自己来定义的。</li>
</ol>
<p>  <b>满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的</b></p>
<ul>
<li>如果无法保证一致性<br>例一：A有200元，转账300元出去，A账户余额-100元，自然发现此时数据不一致<br> 因为定义了一个状态，余额列必须大于0元。<br>例二：A有200元，转账50元给B账户，A账户的钱扣了，但是B账户由于各种意外，余额并未增加。<br> 此时数据也是不一致的，因为定义了一个状态，要求A+B的总额保持不变</li>
</ul>
<ol start="3">
<li>隔离性<br>  隔离性是指<b>多个事务并发执行的时候，事务内部的操作与其他事务是隔离的</b><br>  并发执行的各个事务之间不能相互干扰。</li>
</ol>
<ul>
<li>如果无法保证隔离性<br>假设A账户有200元，B账户0元。<br>A账户往B账户转账两次，金额50元，分别在两个事务中执行。<br>如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只增加了一次，凭空消失50元，依然出现数据不一致。<br>【如：A&#x3D;200，B&#x3D;0，A-50，B+50；A&#x3D;150，B&#x3D;0，A-50，B+50；A&#x3D;100，B&#x3D;50】</li>
</ul>
<ol start="4">
<li>持久性<br>  持久性是指<b>事务一旦提交，它对数据库的改变就应该是永久性的</b><br>  接下来的其他操作或故障不应该对其有任何影响。</li>
</ol>
<ul>
<li><p>如果无法保证持久性<br>在MySQL中，为了解决CPU和磁盘速度不一致的问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再写回磁盘。<br>假设此时宕机，内存中修改的数据全部丢失，持久性便无法保证。</p>
<p>如果系统提示转账成功，但发现金额没有发生任何变化，此时数据出现了不合法的数据状态，我们将这种状态认为是<code>数据不一致</code>的情形。</p>
</li>
</ul>
<hr>
<h2 id="52、数据库如何保证一致性？"><a href="#52、数据库如何保证一致性？" class="headerlink" title="52、数据库如何保证一致性？"></a>52、数据库如何保证一致性？</h2><p>两个层面来说：</p>
<ol>
<li><p>从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。<br>也就是说，ACID四大特性之中，<code>C（一致性）是目的，A（原子性）、I（隔离性）、D（持久性）是手段</code>，是为了保证一致性，数据库提供的手段。<br><b>数据库必须要实现AID三大特性，才有可能实现一致性</b>。</p>
<p>例如，原子性无法保证，一致性显然也无法保证</p>
</li>
<li><p>从应用层面<br>通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。</p>
</li>
</ol>
<hr>
<h2 id="53、数据库如何保证原子性？"><a href="#53、数据库如何保证原子性？" class="headerlink" title="53、数据库如何保证原子性？"></a>53、数据库如何保证原子性？</h2><p>主要是利用InnoDB（支持事务）的<code>undo log</code>。<br>undo log 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的SQL语句，他需要记录你要回滚的相应日志信息。</p>
<p>例如：</p>
<ul>
<li><p>当DELETE一条数据的时候，就需要记录这条数据的信息，回滚时候，INSERT这条旧数据。</p>
</li>
<li><p>当UPDATE一条数据的时候，就需要记录这条数据的旧值，回滚时候，根据旧值执行UPDATE操作。</p>
</li>
<li><p>当INSERT一条数据的时候，就需要记录这条数据的主键，回滚时候，根据主键执行DELETE操作。</p>
</li>
</ul>
<p>undo log记录了这些回滚需要的信息，当事务执行失败或调用了ROLLBACK，导致事务需要回滚<br>便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p>
<hr>
<h2 id="54、数据库如何保证持久性？"><a href="#54、数据库如何保证持久性？" class="headerlink" title="54、数据库如何保证持久性？"></a>54、数据库如何保证持久性？</h2><p>主要是利用InnoDB中的<code>redo log</code>重写日志。</p>
<p>正如之前所说，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。<br>如果此时突然宕机，内存中的数据就会丢失。<br>如何解决？事物提交之前直接把事务写入磁盘，这么做有什么问题？</p>
<ul>
<li><p>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，浪费资源。<br>毕竟一个页面16kb大小，只改其中一点点东西，就要将16kb内容重刷入磁盘，有些不合理。</p>
</li>
<li><p>一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。<br>操作随机IO，速度会比较慢。</p>
</li>
</ul>
<p>于是，决定采用redo log解决上面的问题。<br>当做数据修改的时候，不仅在内存操作，还会在redo log中记录这次操作。<br>当事务提交的时候，会将redo log日志进行刷盘（redo log一部分在内存中，一部分在磁盘上）<br>当数据库宕机重启时，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚还是提交数据。</p>
<ul>
<li>采用redo log的好处？<br>好处就是将redo log进行刷盘比对数据页进行刷盘效率高，具体表现如下：<ul>
<li><p>redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</p>
</li>
<li><p>redo log是一直往末尾进行追加，属于顺序I&#x2F;O，效率显然比随机I&#x2F;O来得快。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="55、数据库高并发是经常会遇到的，有什么好的解决方案？"><a href="#55、数据库高并发是经常会遇到的，有什么好的解决方案？" class="headerlink" title="55、数据库高并发是经常会遇到的，有什么好的解决方案？"></a>55、数据库高并发是经常会遇到的，有什么好的解决方案？</h2><ul>
<li><p>在web服务框架中加入缓存。在服务器和数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</p>
</li>
<li><p>增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，而且数据库的写入会导致索引的更新，也会导致速度变慢等）</p>
</li>
<li><p>主从读写分离，让主服务器负责写，从服务器负责读。</p>
</li>
<li><p>将数据库进行拆分，使得数据库的表尽可能小，提高查询速度。</p>
</li>
<li><p>使用分布式架构，分散计算压力</p>
</li>
</ul>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/02/22/Database/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/02/22/Database/";
            const title         = "「数据库」";
            const excerpt       = `1、关系型数据库和非关系型数据库的区别了解多少？
关系型数据库：

容易理解，因为采用了关系模型来组织数据

可以保持数据一致性

数据更新开销较小

支持复杂查询（带where字句的查询）



非关系型数据库的优点

不需要经过S...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a>
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-03-30</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 数据结构" href="/2022/02/19/DataStruct/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" MySQL" href="/2022/02/22/MySQL/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/Ru.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">人间归离复归离，借一浮生逃浮生</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">1、关系型数据库和非关系型数据库的区别了解多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-text">2、非关系型数据库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">3、为什么使用索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Innodb%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%87%AA%E5%A2%9Eid%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-text">4、Innodb为什么要用自增id作为主键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E9%9D%9E%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%88%E5%A6%82%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E6%88%96%E5%AD%A6%E5%8F%B7%E7%AD%89%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%AF%8F%E6%AC%A1%E6%8F%92%E5%85%A5%E4%B8%BB%E9%94%AE%E7%9A%84%E5%80%BC%E8%BF%91%E4%BC%BC%E4%BA%8E%E9%9A%8F%E6%9C%BA%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%AF%8F%E6%AC%A1%E6%96%B0%E7%BA%AA%E5%BD%95%E9%83%BD%E8%A6%81%E8%83%8C%E6%8F%92%E5%88%B0%E7%8E%B0%E6%9C%89%E7%B4%A2%E5%BC%95%E9%A1%B5%E7%9A%84%E4%B8%AD%E9%97%B4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8C%E9%A2%91%E7%B9%81%E7%9A%84%E7%A7%BB%E5%8A%A8%E3%80%81%E5%88%86%E9%A1%B5%E6%93%8D%E4%BD%9C%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E7%A2%8E%E7%89%87%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E4%B8%8D%E5%A4%9F%E7%B4%A7%E5%87%91%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%8C%E5%90%8E%E7%BB%AD%E4%B8%8D%E5%BE%97%E4%B8%8D%E9%80%9A%E8%BF%87OPTIMIZE-TABLE%E6%9D%A5%E9%87%8D%E5%BB%BA%E8%A1%A8%E5%B9%B6%E4%BC%98%E5%8C%96%E5%A1%AB%E5%85%85%E9%A1%B5%E9%9D%A2%E3%80%82"><span class="toc-text">如果使用非自增主键（如身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要背插到现有索引页的中间某个位置，频繁的移动、分页操作了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81MyISAM%E5%92%8CInnoDB%E5%AE%9E%E7%8E%B0B%E6%A0%91%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5、MyISAM和InnoDB实现B树索引方式的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%EF%BC%9F%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">6、说一下MySQL是如何执行一条SQL的？具体步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81MySQL%E7%9A%84%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0%EF%BC%9F%E4%B8%80%E8%88%AC%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-text">7、MySQL的内部构造？一般可以分为哪两部分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Drop%E3%80%81Delete%E5%92%8CTruncate%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">8、Drop、Delete和Truncate的共同点和区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81MySQL%E4%BC%98%E5%8C%96%EF%BC%9F%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">9、MySQL优化？哪些方面可以做到性能优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">10、数据库隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E8%88%AC%E4%BC%9A%E7%94%A8%E5%88%B0SERIALIZABLE%EF%BC%88%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E3%80%82"><span class="toc-text">InnoDB存储引擎在分布式事务情况下一般会用到SERIALIZABLE（可串行化）隔离级别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E9%83%BD%E7%9F%A5%E9%81%93%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E9%87%87%E7%94%A8B-%E6%A0%91%E8%80%8C%E9%9D%9EB%E6%A0%91%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">11、都知道数据库索引采用B+树而非B树，主要原因？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F"><span class="toc-text">12、文件索引和数据库索引为什么使用B+树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E8%A7%86%E5%9B%BE%EF%BC%9F%E6%B8%B8%E6%A0%87%EF%BC%9F"><span class="toc-text">13、视图？游标？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81MySQL%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6"><span class="toc-text">14、MySQL中为什么要有事务回滚机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8EInnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">15、数据库引擎InnoDB和MyISAM的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">16、数据库并发事务会带来哪些问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">17、数据库悲观锁和乐观锁的原理和应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81MySQL%E7%B4%A2%E5%BC%95%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">18、MySQL索引主要使用的两种数据结构是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%86%E5%AF%B9%E4%BA%8E%E4%B8%BB%E8%A6%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88MyISAM%E5%92%8CInnoDB%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84%E3%80%82"><span class="toc-text">但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%EF%BC%9F%E9%83%BD%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E6%88%96%E8%80%85%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E4%B8%8D%E8%A1%8C%EF%BC%9F"><span class="toc-text">19、数据库为什么要进行分库和分表？都放在一个库或者一张表中不行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">20、不可重复读和幻读的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81MySQL%E4%B8%AD%E6%9C%89%E5%9B%9B%E7%A7%8D%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">21、MySQL中有四种索引类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-text">22、视图的作用是什么？可以更改吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99B-Tree%E6%AF%94BTree%E6%9B%B4%E9%80%82%E5%90%88%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">23、为什么时候B+Tree比BTree更适合实际应用中操作系统的文件索引和数据库索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%89%80%E5%9C%A8%E5%85%AC%E5%8F%B8%E9%80%89%E6%8B%A9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%8C%E4%B8%80%E5%A4%A9%E4%BA%94%E4%B8%87%E6%9D%A1%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%A2%9E%E9%87%8F%EF%BC%8C%E9%A2%84%E8%AE%A1%E8%BF%90%E7%BB%B4%E4%B8%89%E5%B9%B4%EF%BC%8C%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="toc-text">24、场景题：如果所在公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，优化手段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">25、什么时候需要建立数据库索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">26、覆盖索引是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%B0%B1%E6%98%AF%E6%8A%8A%E8%A6%81%E6%9F%A5%E8%AF%A2%E5%87%BA%E7%9A%84%E5%88%97%E5%92%8C%E7%B4%A2%E5%BC%95%E6%98%AF%E5%AF%B9%E5%BA%94%E7%9A%84%EF%BC%8C%E4%B8%8D%E5%81%9A%E5%9B%9E%E8%A1%A8%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-text">覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E9%94%AE%E3%80%81%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">27、数据库中的主键、超键、候选键、外键是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-text">28、数据库三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E7%B2%BE%E8%A6%81%E6%80%BB%E7%BB%93"><span class="toc-text">29、数据库三大范式精要总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81MySQL%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EInnoDB%EF%BC%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-text">30、MySQL常见的存储引擎InnoDB，MyISAM的区别？适用场景分别是？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="toc-text">31、事务四大特性（ACID）原子性、一致性、隔离性、持久性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81SQL%E4%B8%AD%E7%9A%84NOW-%E5%92%8CCURRENT-DATA-%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">32、SQL中的NOW()和CURRENT_DATA()两个函数有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E8%81%9A%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">33、聚合索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8E%E6%98%AF%EF%BC%8C%E6%8A%8A%E8%BF%99%E7%A7%8D%E6%AD%A3%E6%96%87%E5%86%85%E5%AE%B9%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8C%89%E7%85%A7%E4%B8%80%E5%AE%9A%E8%A7%84%E5%88%99%E6%8E%92%E5%88%97%E7%9A%84%E7%9B%AE%E5%BD%95%E7%A7%B0%E4%B8%BA%E2%80%9C%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E2%80%9D%E3%80%82"><span class="toc-text">于是，把这种正文内容本身就是一种按照一定规则排列的目录称为“聚簇索引”。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">34、什么是非聚簇索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8E%E6%98%AF%EF%BC%8C%E6%8A%8A%E7%9B%AE%E5%BD%95%E7%BA%AF%E7%B2%B9%E6%98%AF%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%AD%A3%E6%96%87%E7%BA%AF%E7%B2%B9%E6%98%AF%E6%AD%A3%E6%96%87%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%A7%B0%E4%B8%BA%E2%80%9C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E2%80%9D"><span class="toc-text">于是，把目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚簇索引”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">35、聚簇索引和非聚簇索引的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">36、创建索引时需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81MySQL%E4%B8%ADCHAR%E5%92%8CVARCHAR%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">37、MySQL中CHAR和VARCHAR的区别有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81MySQL%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">38、MySQL索引使用的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81MySQL%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95%EF%BC%9F%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">39、MySQL中有哪些索引？特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81%E6%97%A2%E7%84%B6%E7%B4%A2%E5%BC%95%E6%9C%89%E9%82%A3%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">40、既然索引有那么多优点，为什么不对表的每一列创建一个索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%9F"><span class="toc-text">41、索引是如何提高查询速度的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%97%A0%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E6%88%90%E7%9B%B8%E5%AF%B9%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E5%B0%B1%E5%83%8F%E6%9F%A5%E6%9C%89%E7%9B%AE%E7%9A%84%E4%B8%80%E6%A0%B7%EF%BC%89"><span class="toc-text">将无序的数据变成相对有序的数据（就像查有目的一样）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">42、使用索引的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81%E5%A2%9E%E5%8A%A0B-%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%8C%E9%82%A3%E4%B9%88%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9C%80%E4%BC%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-text">43、增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优查询效率？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A1%A8%E9%94%81%E5%92%8C%E5%88%97%E9%94%81%EF%BC%9F"><span class="toc-text">44、数据库的表锁和列锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81SQL%E8%AF%AD%E6%B3%95%E4%B8%AD%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E8%87%AA%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%B7%A6%E3%80%81%E5%8F%B3%E3%80%81%E5%85%A8%EF%BC%89%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="toc-text">46、你知道哪些数据库结构优化的手段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%8B%E6%AE%B5%E5%B0%B1%E6%98%AF%E6%8A%8A%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%B7%AE%E5%88%86%E6%95%B0%E6%8D%AE%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于差分数据了解哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%B4%A2%E5%BC%95%E8%A6%81%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%E6%88%96%E8%80%85%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-text">48、为什么MySQL索引要使用B+树，而不是B树或者红黑树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%EF%BC%9A%E5%8F%AA%E6%9C%89B-%E6%A0%91%E5%92%8CB-%E6%A0%91%EF%BC%8C%E8%80%8CB-%E6%A0%91%E5%8F%AB%E5%81%9AB%E6%A0%91%EF%BC%8C%E6%B2%A1%E6%9C%89B%E5%87%8F%E6%A0%91%E8%AF%B4%E6%B3%95%E3%80%82"><span class="toc-text">特别的：只有B-树和B+树，而B-树叫做B树，没有B减树说法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%B4%A2%E5%BC%95%E9%80%82%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8hash%E8%A1%A8%E5%92%8CB%E6%A0%91%EF%BC%9F"><span class="toc-text">49、为什么MySQL索引适用B+树而不用hash表和B树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E6%97%A2%E7%84%B6Hash%E6%AF%94B-%E6%A0%91%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%94%A8B-%E6%A0%91%E6%9D%A5%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">50、既然Hash比B+树更快，为什么MySQL用B+树来存储索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E5%9C%A8%E5%BE%97%E4%B8%8D%E5%88%B0%E4%BF%9D%E9%9A%9C%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-text">51、关系型数据库的四大特性在得不到保障的情况下会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">52、数据库如何保证一致性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-text">53、数据库如何保证原子性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="toc-text">54、数据库如何保证持久性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E6%98%AF%E7%BB%8F%E5%B8%B8%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">55、数据库高并发是经常会遇到的，有什么好的解决方案？</span></a></li></ol>
    </div>
</aside>
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.6em;">动态规划</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.8em;">数据库</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.6em;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.6em;">计算机网络</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/03/30/Git/"><i class="fa  fa-book"></i> Git</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/28/cppRest/"><i class="fa  fa-book"></i> cppRest</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/27/cpp11/"><i class="fa  fa-book"></i> cpp11</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/26/cppMemory/"><i class="fa  fa-book"></i> cppMemory</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/24/STL/"><i class="fa  fa-book"></i> STL</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/ReisenU"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@ReisenU"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/ReisenUx"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 月战老兵月球基地 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by ReisenU.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>




    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="7292006123"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>