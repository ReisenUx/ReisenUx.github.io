<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>操作系统 | 月战老兵月球基地</title>
  <meta name="author" content="ReisenU" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2022/02/28/OperatingSystem/index.html">
<meta property="og:site_name" content="月战老兵月球基地">
<meta property="og:description" content="操作系统">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2022-02-28T11:44:08.000Z">
<meta property="article:modified_time" content="2022-04-12T11:44:12.417Z">
<meta property="article:author" content="ReisenU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li><a href="/"><i class="fa fa-link"></i>链接</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">月战老兵月球基地</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>月战老兵月球基地</h2> <br />
                        <span>Lunar Capital</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">操作系统</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-02-28</li>
                <li><i class="fa fa-user"></i> 作者 ReisenU</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~44.54K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1649763852417"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">一、进程-线程-协程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1、进程、线程和协程的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%96%B0%E5%9F%8E%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.</span> <span class="toc-text">2、线程和新城的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%87%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3、一个进程可以创建出多少线程，和什么有关？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">4、外中断和异常区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">5、进程线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6、进程调度算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7、Linux下进程间通信方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Linux%E4%B8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">8、Linux下同步机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%A6%82%E6%9E%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%90%8E%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BA%86%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8B%A5%E6%9C%AA%E9%87%87%E7%94%A8%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%88%99%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E9%9C%80%E8%A6%81100-100-x3D-200us%EF%BC%8C%E6%98%BE%E7%84%B6%EF%BC%8C%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6%E5%90%8E%EF%BC%8C%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E9%80%9F%E5%BA%A6%E5%BF%AB%E5%A4%9A%E4%BA%86%E3%80%82"><span class="toc-number">1.10.</span> <span class="toc-text">若未采用快表机制，则访问一个逻辑地址需要100+100&#x3D;200us，显然，引入快表机制后，访问一个逻辑地址的速度快多了。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%A6%86%E7%9B%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">10、内存交换和覆盖有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%88%86%E5%88%AB%E8%AF%B4%E8%AF%B4%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">11、动态分区分配算法有哪几种？分别说说？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94-%E7%94%B1%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E6%BC%94%E5%8F%98%E8%80%8C%E6%9D%A5%EF%BC%8C%E6%AF%8F%E6%AC%A1%E4%BB%8E%E4%B8%8A%E6%AC%A1%E6%9F%A5%E6%89%BE%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B%E6%9F%A5%E6%89%BE-%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E4%BB%A5%E5%9C%B0%E5%9D%80%E9%80%92%E5%A2%9E%E6%AC%A1%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%88%E5%8F%AF%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%89-%E4%B8%8D%E7%94%A8%E6%AF%8F%E6%AC%A1%E9%83%BD%E4%BB%8E%E4%BD%8E%E5%9C%B0%E5%9D%80%E7%9A%84%E5%B0%8F%E5%88%86%E5%8C%BA%E5%BC%80%E5%A7%8B%E6%A3%80%E7%B4%A2%E3%80%82%E7%AE%97%E6%B3%95%E5%BC%80%E9%94%80%E5%B0%8F%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F-%E4%BC%9A%E4%BD%BF%E9%AB%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%88%86%E5%8C%BA%E8%A2%AB%E7%94%A8%E5%AE%8C"><span class="toc-number">1.13.</span> <span class="toc-text">|邻近适应|由首次适应演变而来，每次从上次查找结束位置开始查找|空闲分区以地址递增次序排列（可循环链表）|不用每次都从低地址的小分区开始检索。算法开销小，不需要排序|会使高地址空间大分区被用完|</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">12、虚拟技术？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">13、进程状态的切换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%E5%88%B0%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">14、一个程序从开始运行到结束的完整过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E9%80%9A%E8%BF%87%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%A7%A3%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">1.17.</span> <span class="toc-text">15、通过例子讲解逻辑地址转换为物理地址的基本过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">16、进程同步的四种方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%AF%B9%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">17、操作系统在对内存进行管理的时候需要做些什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8CWindows%E4%B8%8B%EF%BC%89%EF%BC%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8CWindows%E4%B8%8B%EF%BC%89"><span class="toc-number">1.20.</span> <span class="toc-text">18、进程通信方法（Linux和Windows下），线程通信方法（Linux和Windows下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">19、进程间通信有哪几种形式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%9B%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">20、虚拟内存的目的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">21、说一下理解中的内存，有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90"><span class="toc-number">1.24.</span> <span class="toc-text">22、操作系统经典问题 - 哲学家进餐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.25.</span> <span class="toc-text">23、操作系统经典问题 - 读者写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">24、介绍一下几种典型的锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-1%E3%80%81%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">1.27.</span> <span class="toc-text">24-1、哪几种线程锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-VS-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">1.28.</span> <span class="toc-text">25、逻辑地址 VS 物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%9C%B0%E5%9D%80%E5%8F%88%E7%A7%B0%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%E5%8F%88%E7%A7%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%82"><span class="toc-number">1.29.</span> <span class="toc-text">相对地址又称逻辑地址，绝对地址又称物理地址。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E6%80%8E%E4%B9%88%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">26、怎么回收线程？有哪几种方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">27、内存的覆盖是什么？有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.32.</span> <span class="toc-text">28、内存交换是什么？有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">29、什么时候会进行内存交换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E7%BB%88%E7%AB%AF%E9%80%80%E5%87%BA%EF%BC%8C%E7%BB%88%E7%AB%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">30、终端退出，终端运行的进程会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">1.35.</span> <span class="toc-text">31、如何让进程后台运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E8%A1%A8%EF%BC%8C%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%E5%85%B3%E4%BA%8E%E5%BF%AB%E8%A1%A8%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">32、什么是快表，知道多少关于快表的知识？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%92%8C%E6%B2%A1%E5%BF%AB%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.37.</span> <span class="toc-text">33、地址变换中，有快表和没快表有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-1%E3%80%81%E7%AE%97%E9%A1%B5%E5%8F%B7%E3%80%81%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%9B2%E3%80%81%E6%A3%80%E6%9F%A5%E9%A1%B5%E5%8F%B7%E5%90%88%E6%B3%95%E6%80%A7%EF%BC%9B3%E3%80%81%E6%9F%A5%E5%BF%AB%E8%A1%A8%EF%BC%8C%E8%8B%A5%E5%91%BD%E4%B8%AD%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9F%A5%E9%81%93%E9%A1%B5%E9%9D%A2%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E5%8F%B7%EF%BC%8C%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C5%E3%80%81%E8%8B%A5%E6%9C%AA%E5%91%BD%E4%B8%AD%E5%88%99%E8%BF%9B%E8%A1%8C4%EF%BC%9B4%E3%80%81%E6%9F%A5%E9%A1%B5%E8%A1%A8%EF%BC%8C%E6%89%BE%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E5%8F%B7%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%86%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%A4%8D%E5%88%B6%E5%88%B0%E5%BF%AB%E8%A1%A8%E4%B8%AD%EF%BC%9B5%E3%80%81%E6%A0%B9%E6%8D%AE%E5%86%85%E5%AD%98%E5%9D%97%E5%8F%B7%E5%92%8C%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E9%87%8F%E5%BE%97%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%9B6%E3%80%81%E8%AE%BF%E9%97%AE%E7%9B%AE%E6%A0%87%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83-%E5%BF%AB%E8%A1%A8%E5%91%BD%E4%B8%AD%E5%88%99%E9%9C%80%E8%A6%81%E4%B8%80%E6%AC%A1%E8%AE%BF%E5%AD%98%EF%BC%9B%E5%BF%AB%E8%A1%A8%E6%9C%AA%E5%91%BD%E4%B8%AD%E5%88%99%E9%9C%80%E8%A6%81%E4%B8%A4%E6%AC%A1%E8%AE%BF%E5%AD%98"><span class="toc-number">1.38.</span> <span class="toc-text">|具有快表的地址变换机构|1、算页号、页内偏移量；2、检查页号合法性；3、查快表，若命中，即可知道页面存放的内存块号，可直接进行5、若未命中则进行4；4、查页表，找到页面存放的内存块号，并且将页表项复制到快表中；5、根据内存块号和页内偏移量得到物理地址；6、访问目标内存单元|快表命中则需要一次访存；快表未命中则需要两次访存|</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E5%9C%A8%E6%89%A7%E8%A1%8Cmalloc%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">34、在执行malloc申请内存的时候，操作系统是怎么做的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.40.</span> <span class="toc-text">35、守护进程、僵尸进程和孤儿进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.41.</span> <span class="toc-text">36、如何避免僵尸进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B0%86%E6%AD%A4%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%BE%E4%B8%BA%E5%BF%BD%E7%95%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E5%86%85%E6%A0%B8%E6%8A%8A%E5%83%B5%E5%B0%B8%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%BD%AC%E4%BA%A4%E7%BB%99init%E8%BF%9B%E7%A8%8B%E5%8E%BB%E5%A4%84%E7%90%86%EF%BC%8C%E7%9C%81%E5%8E%BB%E4%BA%86%E5%A4%A7%E9%87%8F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E3%80%82"><span class="toc-number">1.42.</span> <span class="toc-text">如果将此信号的处理方式设为忽略，可以让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%B8%A4%E5%A4%A7%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">37、局部性原理？主要有哪两大局部性原理？是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.44.</span> <span class="toc-text">38、父进程、子进程、进程组、作业和会话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E9%9B%86%E4%B8%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">1.45.</span> <span class="toc-text">39.进程终止的集中方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81Linux%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.46.</span> <span class="toc-text">40、Linux中异常和中断的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81Windows-%E5%92%8C-Linux-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-number">1.47.</span> <span class="toc-text">41、Windows 和 Linux 环境下内存分布情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81%E4%B8%80%E4%B8%AA%E7%94%B1C-x2F-C-%E7%BC%96%E8%AF%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-number">1.48.</span> <span class="toc-text">42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-x2F-Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.49.</span> <span class="toc-text">43、一般情况下在Linux&#x2F;Windows平台下栈空间的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%A0%86%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8A%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-number">1.50.</span> <span class="toc-text">44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.51.</span> <span class="toc-text">45、几种常见的磁盘调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.52.</span> <span class="toc-text">46、交换空间和虚拟内存的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.53.</span> <span class="toc-text">47、抖动（颠簸）是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BA%86%E7%A0%94%E7%A9%B6%E5%BA%94%E8%AF%A5%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%89%A9%E7%90%86%E5%9D%97%EF%BC%8CDenning%E6%8F%90%E5%87%BA%E4%BA%86%E8%BF%9B%E7%A8%8B%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.54.</span> <span class="toc-text">为了研究应该为每个进程分配多少个物理块，Denning提出了进程工作集的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E4%BB%8E%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%E5%93%AA%E4%B8%AA%E5%BF%AB%EF%BC%9F%EF%BC%88%E8%80%83%E5%AF%9F%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%EF%BC%89"><span class="toc-number">1.55.</span> <span class="toc-text">48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.56.</span> <span class="toc-text">49、常见的内存分配方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="toc-number">1.57.</span> <span class="toc-text">50、常见内存分配内存错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%B8%AD%EF%BC%8C%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.58.</span> <span class="toc-text">51、内存交换中，被换出的进程保存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%B9%8B%EF%BC%8C%E5%AF%B9%E6%8D%A2%E5%8C%BA%E7%9A%84I-x2F-O%E9%80%9F%E5%BA%A6%E6%AF%94%E6%96%87%E4%BB%B6%E5%8C%BA%E6%9B%B4%E5%BF%AB%E3%80%82"><span class="toc-number">1.59.</span> <span class="toc-text">总之，对换区的I&#x2F;O速度比文件区更快。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81%E5%9C%A8%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%97%B6%EF%BC%8C%E6%9C%89%E4%BA%9B%E8%BF%9B%E7%A8%8B%E6%98%AF%E8%A2%AB%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%9A%84%EF%BC%9F"><span class="toc-number">1.60.</span> <span class="toc-text">52、在发生内存交换时，有些进程是被优先考虑的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81ASCII%E3%80%81Unicode%E5%92%8CUTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.61.</span> <span class="toc-text">53、ASCII、Unicode和UTF-8编码的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.62.</span> <span class="toc-text">54、原子操作是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.63.</span> <span class="toc-text">56、系统并发和并行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.64.</span> <span class="toc-text">57、页面置换算法总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E5%85%B1%E4%BA%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.65.</span> <span class="toc-text">58.共享是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90%E7%A7%B0%E4%B8%BA%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%89%93%E5%8D%B0%E6%9C%BA%E7%AD%89%EF%BC%8C%E5%9C%A8%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E7%94%A8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-number">1.66.</span> <span class="toc-text">互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59%E3%80%81%E6%AD%BB%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.67.</span> <span class="toc-text">59、死锁相关问题总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E8%80%8C%E6%97%A0%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%9C%89%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E4%B8%8D%E4%BC%9A%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F"><span class="toc-number">1.68.</span> <span class="toc-text">60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片不会有外部碎片？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E3%80%81%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E4%B8%8E%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87"><span class="toc-number">1.69.</span> <span class="toc-text">61、内部碎片与外部碎片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E3%80%81%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E7%A2%8E%E7%89%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.70.</span> <span class="toc-text">62、如何消除碎片文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E3%80%81%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">1.71.</span> <span class="toc-text">63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8D%A2%E5%8F%A5%E8%AF%9D%E8%AF%B4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.72.</span> <span class="toc-text">64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">1.73.</span> <span class="toc-text">65、服务器高并发的解决方案？</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <h1 id="一、进程-线程-协程"><a href="#一、进程-线程-协程" class="headerlink" title="一、进程-线程-协程"></a>一、进程-线程-协程</h1><h2 id="1、进程、线程和协程的区别和联系"><a href="#1、进程、线程和协程的区别和联系" class="headerlink" title="1、进程、线程和协程的区别和联系"></a>1、进程、线程和协程的区别和联系</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">进程</th>
<th align="left">线程</th>
<th align="left">协程</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义</td>
<td align="left">资源分配和拥有的基本单位</td>
<td align="left">程序执行的基本单位</td>
<td align="left">用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td align="left">切换情况</td>
<td align="left">进程CPU环境（栈、寄存器、页表和文件句柄等）的保存以及新调度CPU环境设置</td>
<td align="left">保存和设置程序计数器、少量寄存器和栈的内容</td>
<td align="left">先将寄存器上下文和栈保存，等切换回来时进行恢复</td>
</tr>
<tr>
<td align="left">切换者</td>
<td align="left">操作系统</td>
<td align="left">操作系统</td>
<td align="left">用户</td>
</tr>
<tr>
<td align="left">切换过程</td>
<td align="left">用户-&gt;内核-&gt;用户</td>
<td align="left">用户-&gt;内核-&gt;用户</td>
<td align="left">用户（不陷入内核态）</td>
</tr>
<tr>
<td align="left">调用栈</td>
<td align="left">内核栈</td>
<td align="left">内核栈</td>
<td align="left">用户栈</td>
</tr>
<tr>
<td align="left">拥有资源</td>
<td align="left">CPU资源、内存、文件、句柄等</td>
<td align="left">PC、寄存器、栈和状态字</td>
<td align="left">自己的寄存器上下文和栈</td>
</tr>
<tr>
<td align="left">并发性</td>
<td align="left">不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td align="left">一个进程内部多个线程并发执行</td>
<td align="left">同一时间只能运行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr>
<td align="left">系统开销</td>
<td align="left">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td align="left">切换时只需保存和设置少量寄存器内容，开销很小</td>
<td align="left">直接操作栈，则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr>
<td align="left">通信方面</td>
<td align="left">进程间通信需要借助操作系统</td>
<td align="left">线程间可以直接读写进程数据段（如全局变量）来进行通信</td>
<td align="left">共享内存、消息队列</td>
</tr>
</tbody></table>
<ol>
<li>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序【动态和静态】</li>
<li>线程是程序执行的基本单位，是轻量级的进程。每个进程都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。</li>
<li>协程是用户态的轻量级线程，线程内部调度的基本单位</li>
</ol>
<h2 id="2、线程和新城的比较"><a href="#2、线程和新城的比较" class="headerlink" title="2、线程和新城的比较"></a>2、线程和新城的比较</h2><ol>
<li>线程启动速度快，轻量级</li>
<li>线程的系统开销小</li>
<li>线程使用有一定难度，需要处理数据一致性问题【需要用到线程通信】</li>
<li>同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，<b>而独自占有栈</b></li>
</ol>
<h2 id="3、一个进程可以创建出多少线程，和什么有关？"><a href="#3、一个进程可以创建出多少线程，和什么有关？" class="headerlink" title="3、一个进程可以创建出多少线程，和什么有关？"></a>3、一个进程可以创建出多少线程，和什么有关？</h2><p>理论上，一个进程可用虚拟空间是 2G，默认情况下，线程栈大小是1MB，理论上可以创建2048个线程，如果要多余2048，则必须修改编译器设置。<br>因此，一个进程可以创建的线程数由<b>可用虚拟空间和线程栈大小</b>共同决定，只要虚拟空间足够，则新线程的建立就会成功。<br>按照上述限制，如果要创建超过2K个线程，减少线程栈即可。</p>
<blockquote>
<p>过多的线程会导致大量时间浪费在线程切换上，给程序运行效率带来负面影响。</p>
</blockquote>
<h2 id="4、外中断和异常区别"><a href="#4、外中断和异常区别" class="headerlink" title="4、外中断和异常区别"></a>4、外中断和异常区别</h2><p><code>外中断</code>：由CPU执行指令以外的事件引起，如I&#x2F;O完成中断、时钟中断、控制台中断等。（I&#x2F;O完成意味着处理器可以进行别的I&#x2F;O操作）<br><code>异常</code>：由CPU执行指令时的一些事件引起，如非法操作码、除0、地址越界、算术溢出、缺页等。</p>
<h2 id="5、进程线程模型"><a href="#5、进程线程模型" class="headerlink" title="5、进程线程模型"></a>5、进程线程模型</h2><p>核心意义不仅仅是“线程是调度基本单位，进程资源分配基本单位”那么简单</p>
<ul>
<li><p>多线程<br>讨论用户态的多线程模型，同一个进程内部有多个线程，所有线程共享同一个进程的内存空间<br>进程中定义的全局变量会被所有线程共享，例如全局变量int i &#x3D; 10，这一进程中所有并发运行的线程都可以读取和修改这个 i 的值<br>而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其要注意安全。</p>
<p>我们必须知道，<b>做一次简单的i &#x3D; i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节</b><br>线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果</p>
<p>但是，虽然线程在安全性方面会引入很多新挑战，但是线程也带来了许多好处</p>
<ol>
<li><p>原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（任务最好不相关）<br>比如QQ可以一个线程处理聊天；一个线程处理上传文件，两个线程互不干扰</p>
<p>对于线程需要了解：</p>
<ul>
<li><p>线程之间有无先后访问顺序（线程依赖关系）</p>
</li>
<li><p>多个线程共享访问同一变量（同步互斥关系）</p>
</li>
</ul>
</li>
<li><p>我们通常只会去说统一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及<br>除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。</p>
<p>作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p>
</li>
</ol>
<p>线程相关接口不少，主要需要了解各个参数意义和返回值意义</p>
<ol>
<li><p>线程创建和结束<br>* 背景知识：<br> 在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行<br> 但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方法就是采用多线程策略。</p>
<p> 在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等</p>
</li>
</ol>
<pre><code>* 相关接口：
  * 创建线程：int pthread_create(pthread_t tidp, const pthread_attr_t attr, void (*start_rtn)(void), void *arg);
    创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。
    * pthread：用来返回线程的tid，*pthread即为tid，类型pthread_t == unsigned long int.

    * attr：指向线程属性结构体的指针，用于改变所创建线程的属性，填NULL使用默认值
    * start_routine：线程执行函数的首地址，传入函数指针
    * arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以转变为任意类型变量地址，在被传入函数中强制转换即可

  * 获得线程ID：pthread_t pthread_self();
    调用时，会打印线程ID

  * 等待线程结束：int pthread_join(pthread_t tid, void** retval);
    主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞

    * tid：创建线程时通过指针得到tid值
    * retval：指向返回值的指针。

  * 结束线程：pthread_exit(void *retval);
    子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可以通过pthread_join获得。

  * 分离线程：int pthread_detach(pthread_t tid);
    主线程、子线程均可调用。
    主线程中pthread_detach(tid),子线程中pthread_detach(pthread_self()),调用后和主线程分离，子线程结束时自己立即回收资源。

    * tid：同上
</code></pre>
<ol start="2">
<li>线程属性值修改<br>* 背景知识：<br> 线程属性对象类型为pthread_attr_t，结构体定义如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> etachstate; <span class="comment">// 线程分离的状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy;    <span class="comment">// 线程调度策略</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> schedparam;  <span class="comment">// 线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched;   <span class="comment">// 线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope;      <span class="comment">// 线程的作用域</span></span><br><span class="line">    <span class="comment">// 以下为线程栈的设置</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;   <span class="comment">// 线程栈末尾警戒缓冲大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set;  <span class="comment">// 线程的栈设置</span></span><br><span class="line">    <span class="type">void</span> * stackaddr;   <span class="comment">// 线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize;   <span class="comment">// 线程栈的大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<pre><code>* 相关接口：
  对上述结构体中各参数大多有：pthread_attr_get()和pthread_attr_set()系统调用函数来设置和获取。
  不意义罗列。
</code></pre>
</li>
</ul>
<ol start="2">
<li><p>多进程<br>每一个进程是资源分配的基本单位。</p>
<p>进程结构由一下几个部分组成：代码段、堆栈段、数据段。</p>
<p>代码段是静态的二进制代码，多个程序可以共享。<br>实际上在父进程创建子进程之后，父、子进程除了pid以外，其他所有部分几乎一样。</p>
<p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，<br>子进程在读写数据时会通过写时赋值机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p>
<p>如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p>
<p>我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p>
<ol>
<li><p>进程创建与结束<br>* 背景知识：<br> 进程有两种创建方式：一种是操作系统创建；一种是父进程创建。</p>
<p> 从计算机启动到终端执行程序的过程为：<br>   0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。<br> 所以我们在命令行中通过 .&#x2F;program执行可执行文件时，所有创建的进程都是shell进程的子进程。</p>
<p> 这样就是为什么shell进程一关闭，在shell中执行的进程都自动被关闭的原因。<br> 从shell进程到创建其他子进程需要通过以下接口：</p>
</li>
</ol>
<pre><code>* 相关接口：
  * 创建进程：pid_t fork(void);
    返回值：出错返回 -1；父进程中返回 pid &gt; 0；子进程中pid == 0

  * 结束进程：void exit(int status);
    * status是退出状态，保存在全局变量中，通常0表示正常退出。

  * 获得PID：pid_t getpid(void);
    返回调用者pid

  * 获得父进程PID：pid_t getppid(void);
    返回父进程pid

* 其他补充：
  * 正常退出方式：exit()、_exit()、return（在main中）
    exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作
      最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。

    return 和 exit()的区别：exit()是函数，但有参数，执行完之后控制权交给系统。
      return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。

  * 异常退出方式：abort()、终止信号。
</code></pre>
<ol start="2">
<li><p>Linux进程控制<br>* 进程地址空间（地址空间）<br> 虚拟存储器为每个进程提供了独占系统地址空间的假象</p>
<p> 尽管每个进程地址空间内容不尽相同，但是他们都有相似的结构。<br> X86中Linux进程的地址空间底部都是保留给用户进程的，包括文本、数据、堆、栈等<br> 其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。</p>
<p> 有一些“敏感”的地址需要注意一下：<br>   对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间<br>   通常情况下代码运行在用户态（使用0x00000000~0xBFFFFFFF的用户地址空间）<br>   当发生系统调用、进程切换等操作时，CPU寄存器设置模式位，进入内核模式<br>   在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令</p>
<p> 也就是说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3~4G的地址空间则只有进入内核态才行。</p>
</li>
</ol>
<pre><code>* 进程控制块（处理机）【PCB数据结构】
  进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。

* 上下文切换
  内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。
  每一次进程调度就是一次&lt;b&gt;上下文切换&lt;/b&gt;，所谓的上下文切换本质上就是当前运行状态
  主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。

  进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成
  当调度器选择了某个进程时称为进程被调度，该过程通过上下文切换来改变当前状态。

  一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到而切换到内核态执行内核指令
  完成上下文切换后回到用户态，此时已经切换到进程B。
</code></pre>
</li>
</ol>
<hr>
<h2 id="6、进程调度算法？"><a href="#6、进程调度算法？" class="headerlink" title="6、进程调度算法？"></a>6、进程调度算法？</h2><ol>
<li>先来先服务（FCFS：First-Come First-Serverd）<br>  非抢占式的调度算法，按照请求的顺序进行调度。</li>
</ol>
<p>  有利于长作业，但不利于短作业，因为短作业必须一致等待前面的长作业执行完毕才能执行<br>  而长作业又要执行很长时间，造成了短作业等待时间过长。</p>
<ol start="2">
<li>短作业优先（SJF：Shortest Job First）<br>  非抢占式的调度算法，按照估计运行时间最短的顺序进行调度。</li>
</ol>
<p>  长作业有可能会饿死，处于一直等待短作业执行完毕的状态。<br>  因为如果一直有短作业到来，那么长作业将永远得不到调度。</p>
<ol start="3">
<li>最短剩余时间优先（SRTN：Shortest Remaining Time Next）<br>  最短作业优先的抢占式版本，按照剩余运行时间的顺序进行调度。<br>  当一个新的作业到达时，其整个运行时间与当前进程的剩余时间进行比较。</li>
</ol>
<p>  如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<ol start="4">
<li>时间片轮转<br>  将所有就绪进程按照FCFS的原则排程一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。</li>
</ol>
<p>  当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。</p>
<p>  时间片轮转算法的效率和时间片的大小很有关系：<br>    * 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。<br>    * 如果时间片过长，则实时性就不能得到保证【无限大的话，退化成为FCFS】<br>  <img src="/2022/02/28/OperatingSystem/RoundTimeSchedule.png" class=""></p>
<ol start="5">
<li>优先级调度<br>  为每个进程分配一个优先级，按照优先级进行调度。</li>
</ol>
<p>  为了防止低优先级的进程永远得不到调度，可以随着时间的推移增加等待进程的优先级【高响应比优先调度算法】<br>  否则，低优先级的进程会饿死</p>
<ol start="6">
<li>多级反馈队列<br>  一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次</li>
</ol>
<p>  多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如1,2,4,8…。<br>  进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p>  这种方式下，之前的进程只需要交换7次。<br>  每个队列优先权也不同，最上面的优先权最高，因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>  可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合体。<br>  </p>
<hr>
<h2 id="7、Linux下进程间通信方式？"><a href="#7、Linux下进程间通信方式？" class="headerlink" title="7、Linux下进程间通信方式？"></a>7、Linux下进程间通信方式？</h2><ul>
<li><p>管道：</p>
<ul>
<li><p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。<br>                进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li><p>有名管道（FIFO文件，借助文件系统）：有名管段也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p>
</li>
</ul>
</li>
<li><p>共享内存：<br>共享内存就是映射一段能被其他进程所访问的内存，这段内存由一个进程创建，但可以供多个进程访问。</p>
<p>共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的，<br>它往往与信号量配合使用来实现进程间的同步和通信。</p>
</li>
<li><p>消息队列：<br>消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。<br>消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p>套接字：<br>适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p>
</li>
<li><p>信号：<br>用于通知接收进程某个事件已经发生，比如按下Ctrl + C就是信号</p>
</li>
<li><p>信号量：<br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为一种锁机制，实现进程、线程对临界区的同步及互斥访问。</p>
</li>
</ul>
<hr>
<h2 id="8、Linux下同步机制？"><a href="#8、Linux下同步机制？" class="headerlink" title="8、Linux下同步机制？"></a>8、Linux下同步机制？</h2><ul>
<li><p>POSIX信号量：可用于进程同步，也可用于线程同步</p>
</li>
<li><p>POSIX互斥锁 + 条件变量：只能用于线程同步</p>
</li>
</ul>
<ol>
<li>线程和进程的区别</li>
</ol>
<ul>
<li><p>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；<br> 进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）</p>
</li>
<li><p>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发</p>
</li>
<li><p>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；<br>     进程是拥有资源的独立单位。</p>
</li>
<li><p>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；<br>     进程创建和销毁需要重新分配及销毁task_struct结构。</p>
</li>
</ul>
<hr>
<h2 id="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#9、如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</h2><blockquote>
<ol>
<li><p>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号和快表中的所有页号进行比较</p>
</li>
<li><p>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址<br>最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
</li>
<li><p>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，<br>最后，访问该物理地址对应的内存单元。<br>因此，若快表未命中，则访问某个逻辑地址需要两次访存（注：在找到页表项后，应将其同时存入快表，以便后面可能的访问，注意替换策略）<br>【其实若页表也没命中，还需要执行缺页操作】</p>
</li>
</ol>
</blockquote>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。<br>因为局部性原理，一般来说快表的命中率可以达到90%以上。</p>
<p>例如：<br>某系统使用了基本分页存储管理，并采用了具有快表的地址变换机构，访问一次快表耗时1us，访问一次内存耗时100us。<br>若快表命中率为90%，那么访问一个逻辑地址的平均耗时为：(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 &#x3D; 111us<br>【注意逻辑地址转变物理地址还要去内存里面找数据】<br>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是（1 + 100）* 0.9 + (100 + 100) * 0.1 &#x3D; 110.9us</p>
<h2 id="若未采用快表机制，则访问一个逻辑地址需要100-100-x3D-200us，显然，引入快表机制后，访问一个逻辑地址的速度快多了。"><a href="#若未采用快表机制，则访问一个逻辑地址需要100-100-x3D-200us，显然，引入快表机制后，访问一个逻辑地址的速度快多了。" class="headerlink" title="若未采用快表机制，则访问一个逻辑地址需要100+100&#x3D;200us，显然，引入快表机制后，访问一个逻辑地址的速度快多了。"></a>若未采用快表机制，则访问一个逻辑地址需要100+100&#x3D;200us，显然，引入快表机制后，访问一个逻辑地址的速度快多了。</h2><h2 id="10、内存交换和覆盖有什么区别？"><a href="#10、内存交换和覆盖有什么区别？" class="headerlink" title="10、内存交换和覆盖有什么区别？"></a>10、内存交换和覆盖有什么区别？</h2><p>交换技术主要是在不同进程（或作业）之间进行<br>覆盖则用于同一程序或进程中</p>
<hr>
<h2 id="11、动态分区分配算法有哪几种？分别说说？"><a href="#11、动态分区分配算法有哪几种？分别说说？" class="headerlink" title="11、动态分区分配算法有哪几种？分别说说？"></a>11、动态分区分配算法有哪几种？分别说说？</h2><ol>
<li><p>首次适应算法<br>  算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<br>  如何实现：空闲分区以<b>地址递增</b>的次序排列。<br>    每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。<br>  <b>缺点</b>：每次都从链头开始查找，每次都需要检索低地址小分区，查询效率受影响<br>  <b>优点</b>：优先使用较小分区，高地址部分较大分区会被留下来</p>
</li>
<li><p>最佳适应算法<br>  算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。<br>     因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即：优先使用更小的空闲区。</p>
</li>
</ol>
<p>  如何实现：空闲分区按<b>容量递增</b>的次序链接。<br>           每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p>  <b>缺点</b>：每次都使用最小的分区进行匹配，越来越多的难以利用的小内存会被保留下来，因此这种方法会产生很多外部碎片</p>
<ol start="3">
<li>最坏适应算法（最大适应算法）<br>  算法思想：为了解决最佳适应算法的问题 —— 即留下太多难以利用的小碎片，<br>    可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</li>
</ol>
<p>  如何实现：空闲分区按<b>容量递减</b>的次序链接。<br>           每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p>  <b>缺点</b>：每次都选用最大的分区进行匹配，虽然可以让分配后留下的空闲区更大，可利用，<br>               但这种方式会导致较大的连续空闲区被迅速用完，如果之后有“大进程”到达，就没有内存可以利用了。</p>
<ol start="4">
<li>邻近适应算法<br>  算法思想：首次适应算法每次都从链头开始查找。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因而增加查找开销。<br>    如果每次都从上次查找结束的位置开始搜索，就能解决上述问题。</li>
</ol>
<p>  如何实现：空闲分区以<b>地址递增</b>的顺序排列（可链接成一个循环链表）。<br>           每次分配内存时从上次结束查找的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p>  <b>缺点</b>：高地址、低地址都有相同的概率被使用，高地址部分的大分区被划分为小分区，最后导致无大分区可用。</p>
<ol start="5">
<li>总结：<br>  首次适应不仅最简单，通常也是最好最快<br>  不过首次使用算法会使内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此增加了查找的开销。<br>  临近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果差。</li>
</ol>
<p>  最佳适应导致大量碎片，最坏适应导致没有大的空间。</p>
<p>  实验结果：首次适应比最佳适应好，但他们都比最坏适应好。</p>
<blockquote>
<p>综合考虑：四种算法中，首次适应算法的效果最佳。</p>
</blockquote>
<p>|算法|算法思想|分区排列顺序|优点|缺点|<br>|首次适应|从头到尾找到适合的分区|空闲分区以地址递增次序排列|综合性能最好。<b>算法开销小</b>回收分区一般不需要对空闲分区队列重新排序|低地址部分小空间遍历增加复杂度|<br>|最佳适应|优先使用更小的分区，以保留更多大分区|空闲分区以容量递增次序排列|会有更多大分区被保留下来，更能满足大进程需求|会产生很多太小的、难以利用的碎片；<b>算法开销大</b>回收分区后可能要对空闲分区队列重新排序|<br>|最坏适应|优先使用更大的分区，以防止产生太小的不可用的碎片|空间分区以递减次序排列|可以减少难以利用的小碎片|大分区容易用完，不利于后续大进程，<b>算法开销大</b>，（需要排序）|</p>
<h2 id="邻近适应-由首次适应演变而来，每次从上次查找结束位置开始查找-空闲分区以地址递增次序排列（可循环链表）-不用每次都从低地址的小分区开始检索。算法开销小，不需要排序-会使高地址空间大分区被用完"><a href="#邻近适应-由首次适应演变而来，每次从上次查找结束位置开始查找-空闲分区以地址递增次序排列（可循环链表）-不用每次都从低地址的小分区开始检索。算法开销小，不需要排序-会使高地址空间大分区被用完" class="headerlink" title="|邻近适应|由首次适应演变而来，每次从上次查找结束位置开始查找|空闲分区以地址递增次序排列（可循环链表）|不用每次都从低地址的小分区开始检索。算法开销小，不需要排序|会使高地址空间大分区被用完|"></a>|邻近适应|由首次适应演变而来，每次从上次查找结束位置开始查找|空闲分区以地址递增次序排列（可循环链表）|不用每次都从低地址的小分区开始检索。<b>算法开销小</b>，不需要排序|会使高地址空间大分区被用完|</h2><h2 id="12、虚拟技术？"><a href="#12、虚拟技术？" class="headerlink" title="12、虚拟技术？"></a>12、虚拟技术？</h2><p>虚拟技术把一个物理实体转换成多个逻辑实体</p>
<p>主要有两个虚拟技术：<br>  时分复用技术（时间）；空分复用技术（空间）</p>
<p>多进程与多线程：<br>  多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存：<br>  使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。<br>  地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存中的页时，执行页面置换算法，将该页置换到内存中。</p>
<hr>
<h2 id="13、进程状态的切换？"><a href="#13、进程状态的切换？" class="headerlink" title="13、进程状态的切换？"></a>13、进程状态的切换？</h2><img src="/2022/02/28/OperatingSystem/ProcessState.png" class="">

<ul>
<li><p>就绪状态(ready)：等待被调度</p>
</li>
<li><p>运行状态(running)</p>
</li>
<li><p>阻塞状态(waiting)：等待资源</p>
</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li><p>只有就绪态和运行态可以相互转换，其他的都是单向转换。<br>就绪状态和进程通过调度算法从而获得CPU时间，转为运行状态；<br>而运行状态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。</p>
</li>
<li><p>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间<br>缺少CPU时间就会从运行态转换为就绪态。</p>
</li>
</ul>
<hr>
<h2 id="14、一个程序从开始运行到结束的完整过程？"><a href="#14、一个程序从开始运行到结束的完整过程？" class="headerlink" title="14、一个程序从开始运行到结束的完整过程？"></a>14、一个程序从开始运行到结束的完整过程？</h2><p>四个过程：</p>
<ol>
<li><p>预编译<br>  主要处理源代码文件中的以”#”开头的预编译指令。处理规则如下：</p>
</li>
<li><p>删除所有的#define，展开所有的宏定义。</p>
</li>
<li><p>处理所有的条件预编译指令，如”#if”、”#endif”、”#ifdef”、”#elif”和”#else”</p>
</li>
<li><p>处理”#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
</li>
<li><p>删除所有的注释，”&#x2F;&#x2F;“和”&#x2F;**&#x2F;“</p>
</li>
<li><p>保留所有的#pragma编译器指令，编译器需要用到他们<br>例如：#pragma once是为了防止有文件被重复引用</p>
</li>
<li><p>添加行号和文件标识，以便编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时能产生行号。</p>
</li>
<li><p>编译<br>  把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
</li>
<li><p>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的序号</p>
</li>
<li><p>词法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。<br>     由语法分析器输出的语法树是一种以表达式为结点的树</p>
</li>
<li><p>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，<br>     其分析的语义是静态语义 —— 在编译器能分期的语义，想对应的动态语义是在运行期才能确定的语义。</p>
</li>
<li><p>优化：源代码级别的一个优化过程</p>
</li>
<li><p>目标代码生成：由代码生成器将中间代码转换为目标机器代码，生成一系列的代码序列 —— 汇编语言表示。</p>
</li>
<li><p>目标代码优化：目标代码优化器对上述的机器代码进行优化：<br>         寻找合适的寻址方式、使用移位来代替乘法运算、删除多余指令等。</p>
</li>
<li><p>汇编<br>  将汇编代码转变成机器可执行的指令（机器码文件）<br>  汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法和语义、更不用做指令优化<br>  只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器完成。</p>
</li>
</ol>
<p>  经汇编之后，产生目标文件（与可执行文件格式就一样）xxx.o（Linux下）、xxx.obj（Windows下）</p>
<ol start="4">
<li>链接<br>  将不同的源文件产生的目标文件进行链接，从而形成一个可执行的程序。链接分为静态链接和动态链接：<ol>
<li><p>静态链接：<br>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译连接可执行文件时，链接器从库中复制这些函数和数据并把他们和应用程序的其他模块组合起来创建最终的可执行文件。<br>缺点：</p>
<ul>
<li>空间浪费：因为每个可执行程序中对所有需要的目标文件都有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存中存在多个副本；</li>
<li>更新困难：每当库函数的代码修改了，这个时候就要重新编译链接形成可执行程序。</li>
</ul>
<p>优点：</p>
<ul>
<li>运行速度快：静态链接的优点是，在可执行程序中已经具备了所有执行程序所需的任何东西，执行时候速度快。</li>
</ul>
</li>
<li><p>动态链接：<br>动态链接的基本思想是把程序按照魔铠拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<ul>
<li><p>特点：</p>
<ul>
<li>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是多个程序在执行时共享同一个副本；</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="15、通过例子讲解逻辑地址转换为物理地址的基本过程"><a href="#15、通过例子讲解逻辑地址转换为物理地址的基本过程" class="headerlink" title="15、通过例子讲解逻辑地址转换为物理地址的基本过程"></a>15、通过例子讲解逻辑地址转换为物理地址的基本过程</h2><p>可以借助进程的页表将逻辑地址转换为物理地址</p>
<p>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。<br>程序未进行时，页表的起始地址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中。</p>
<p>注意：页面的大小是2的整数次幂，设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p>
<img src="/2022/02/28/OperatingSystem/LA2PA.png" class="">

<p>例：<br>若页面大小L为1K字节，页号2对应的是内存块号b&#x3D;8，将逻辑地址A&#x3D;2500转换为物理地址E。</p>
<p>某系统按字节寻址，逻辑地址结构中，页内偏移量占10位（说明一个页面的大小为2^10B &#x3D; 1KB）<br>页号2对应的内存块号b &#x3D; 8，将逻辑地址A &#x3D; 2500转换为物理地址E。</p>
<blockquote>
<ol>
<li><p>计算页号、页内偏移量：页号P &#x3D; A &#x2F; L &#x3D; 2500 &#x2F; 1024 &#x3D; 2; 页内偏移量W &#x3D; A % L &#x3D; 2500 % 1024 &#x3D; 452</p>
</li>
<li><p>根据题中条件可知，页号2没有越界，其存放的内存块号b &#x3D; 8;</p>
</li>
<li><p>物理地址E &#x3D; b * L + W &#x3D; 8 * 1024 + 425 &#x3D; 8644;</p>
</li>
</ol>
<p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了<br>因此，页式管理中的地址是一位的，即只要给出一个逻辑地址，系统就可以自动算出页号、页内偏移量<br>并不需要显式告诉系统这个逻辑地址中，页内偏移量占多少位</p>
</blockquote>
<hr>
<h2 id="16、进程同步的四种方法？"><a href="#16、进程同步的四种方法？" class="headerlink" title="16、进程同步的四种方法？"></a>16、进程同步的四种方法？</h2><ol>
<li>临界区<br>  对临界资源进行访问的那段代码称为临界区。</li>
</ol>
<p>  为了互斥访问临界资源，每个进程在进入临界区之前都需要进行检查<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>同步与互斥</li>
</ol>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系</li>
<li>互斥：多个进程在同一时刻只能有一个进程进入临界区。</li>
</ul>
<ol start="3">
<li>信号量<br>  信号量（Semaphore）是一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作。</li>
</ol>
<ul>
<li><p>down：如果信号量大于0，执行-1操作；如果信号量等于 0，则进程等待，等到信号量大于0</p>
</li>
<li><p>up：对信号量执行+1操作，唤醒等待的进程让其完成down操作</p>
</li>
</ul>
<p>  down和up操作需要被设计成为原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>  如果信号量的取值只能为0或1，则成为了<b>互斥量（Mutex）</b>，0表示临界区已经加锁，1表示临界区解锁。<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">  <span class="comment">// 临界区</span></span><br><span class="line">  <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">  <span class="comment">// 临界区</span></span><br><span class="line">  <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>使用信号量实现生产者-消费者问题</b><br>问题描述：用一个缓冲区保存物品，只要缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量Mutex来控制对缓冲区的互斥访问。<br>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里要使用两个信号量：<br>empty —— 记录空缓冲区的数量<br>full  —— 记录满缓冲区的数量</p>
<p>其中，<br>empty信号量是在生产者进程中使用，当empty不为0时候，生产者才可以放入物品；<br>full信号量是在消费者进程中使用，当full不为0的时候，消费者才可以取走物品。</p>
<p>注意：<br>不能先对缓冲区进行加锁，再测试信号量。<br>也就是说，不能先执行down(&amp;mutex)再执行down(&amp;empty)</p>
<p>注意如下情况：生产者对缓冲区加锁后，执行down(empty)操作，发现empty &#x3D; 0，此时生产者阻塞。<br>与此同时，由于缓冲区加锁，消费者无法执行up(empty)操作，empty永远都为0，导致死锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 实现缓冲区互斥</span></span><br><span class="line">semaphore empty = N;  <span class="comment">// 实现生产者消费者同步</span></span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">int</span> item = <span class="built_in">produce_item</span>();</span><br><span class="line">    <span class="built_in">down</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">insert_item</span>(item);</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">up</span>(&amp;full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;full);</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    <span class="type">int</span> item = <span class="built_in">remove_item</span>();</span><br><span class="line">    <span class="built_in">consume_item</span>(item);</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">up</span>(&amp;empty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>管程<br>使用信号量机制实现的生产者-消费者问题需要客户端代码进行很多控制，而管程把用于控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li>
</ol>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。<br>示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">  integer i;</span><br><span class="line">  condition c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>

<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。<br>进程在无法继续执行的时候不能一直占用管程，否则其他进程永远不能使用管程。</p>
<p>管程引入了<b>条件变量</b>以及相关的操作：wait() 和 signal() 来实现同步操作。<br>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有；<br>signal() 操作用于唤醒被阻塞的进程。</p>
<p><b>使用管程实现生产者-消费者问题</b></p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerComsumer</span><br><span class="line">  condition full, empty;</span><br><span class="line">  integer count := <span class="number">0</span>;</span><br><span class="line">  condition c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">    insert_item(item);</span><br><span class="line">    count := count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">    remove = remove_item;</span><br><span class="line">    count := count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> count = N - <span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">  <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">  <span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">    ProducerConsumer.insert(item);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">  <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">  <span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">    consume_item(item);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="17、操作系统在对内存进行管理的时候需要做些什么？"><a href="#17、操作系统在对内存进行管理的时候需要做些什么？" class="headerlink" title="17、操作系统在对内存进行管理的时候需要做些什么？"></a>17、操作系统在对内存进行管理的时候需要做些什么？</h2><ul>
<li><p>操作系统负责内存空间的分配与回收。</p>
</li>
<li><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</p>
</li>
<li><p>操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址转换。</p>
</li>
<li><p>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。</p>
</li>
</ul>
<hr>
<h2 id="18、进程通信方法（Linux和Windows下），线程通信方法（Linux和Windows下）"><a href="#18、进程通信方法（Linux和Windows下），线程通信方法（Linux和Windows下）" class="headerlink" title="18、进程通信方法（Linux和Windows下），线程通信方法（Linux和Windows下）"></a>18、进程通信方法（Linux和Windows下），线程通信方法（Linux和Windows下）</h2><ul>
<li><p>进程通信方法</p>
<img src="/2022/02/28/OperatingSystem/ProcessCommunicate.png" class="">

<ul>
<li>名称及方式<br>|管道(pipe)|允许一个进程和另一个与它有共同祖先的进程之间相互通信|<br>|命名管道(FIFO)|类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo创建|<br>|消息队列(MQ)|消息队列是消息的连接表，包括POSIX消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流即缓冲区大小受限等缺点|<br>|信号量(semaphore)|信号量主要作为进程间以及同进程不同线程之间的同步手段|<br>|共享内存(shared memory)|它使得多个进程可以访问同一块内存空间，<b>是最快的可用IPC形式</b>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，例如信号量结合使用，以达到进程间的同步及互斥|<br>|信号量(signal)|信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身|<br>|内存映射(mapped memory)|内存映射允许多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它|<br>|Socket|它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信|</li>
</ul>
</li>
<li><p>线程通信方法</p>
<img src="/2022/02/28/OperatingSystem/ThreadCommunicate.png" class="">

<ul>
<li>名称及含义<br>|Linux||<br>|信号|类似进程间的信号处理|<br>|锁机制|互斥锁、读写锁和自旋锁|<br>|条件变量|使用通知的方式解锁，与互斥锁配合使用|<br>|信号量|包括无名线程信号量和命名线程信号量|<br>|Windows||<br>|全局变量|需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防止编译器对此变量进行优化|<br>|Message消息机制|常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为进程向主窗口发送消息；PostThreadMessage是任意两个线程之间的通信接口|<br>|CEvent对象|CEvent为MFC中的一个对象，可以通过CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。|</li>
</ul>
</li>
</ul>
<hr>
<h2 id="19、进程间通信有哪几种形式？"><a href="#19、进程间通信有哪几种形式？" class="headerlink" title="19、进程间通信有哪几种形式？"></a>19、进程间通信有哪几种形式？</h2><p>Linux几乎支持全部Unix进程间通信方法<br>包括：管道（有名管道和无名管道）、消息队列、共享内存、信号量、套接字等。</p>
<p>其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p>
<ol>
<li>管道</li>
</ol>
<ul>
<li><p>无名管道</p>
<ul>
<li>无名管道特点<ul>
<li><p>无名管道是一种特殊的文件，这种文件只存在于内存中</p>
</li>
<li><p>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间通信</p>
</li>
<li><p>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据则需要两个管道</p>
</li>
</ul>
</li>
<li>相关接口<ul>
<li>int pipe(int fd[2 ]);<ul>
<li>fd[2 ]:管道两端用fd[0 ]和fd[1 ]来描述，读的一段用f[0 ]表示，写的一端用fd[1 ]表示。<br>通信双方的进程中写数据的一方要把fd[0 ]先close掉，读的一方要先把fd[1 ]给close掉。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有名管道：</p>
<ul>
<li>有名管道特点：<ul>
<li><p>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</p>
</li>
<li><p>有名管道可以在不具有亲缘关系的进程间通信</p>
</li>
</ul>
</li>
<li>相关接口：<ul>
<li>int mkfifo(const char* pathname, mode_t mode);<ul>
<li><p>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</p>
</li>
<li><p>mode：和open()中的参数相同。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>消息队列<br>  相比于FIFO，消息队列具有以下优点：</p>
<ul>
<li><p>消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道打开和关闭时可能产生的困难</p>
</li>
<li><p>避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。</p>
</li>
<li><p>读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收。</p>
</li>
</ul>
</li>
<li><p>共享内存<br>  进程可以将同一段共享内存连接到他们自己的地址空间，所有进程都可以访问共享内存中的地址<br>  如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p>
</li>
</ol>
<ul>
<li><p>相关接口：</p>
<ul>
<li><p>创建共享内存：int shmget(key_t key, int size, int flag);<br>成功时返回一个和key相关的共享内存标识符，失败返回-1</p>
<ul>
<li>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key</li>
<li>size：共享内存容量</li>
<li>flag：权限标志位，和open的mode参数一样</li>
</ul>
</li>
<li><p>连接到共享内存地址空间：void* shmat(int shmid, void *addr, int flag);<br>返回值即共享内存实际地址</p>
<ul>
<li>shmid：shmget()返回的标识。</li>
<li>addr：决定以什么方式连接地址。</li>
<li>flag：访问模式</li>
</ul>
</li>
<li><p>从共享内存分离：int shmdt(const void *shmaddr);<br>调用成功返回0，失败返回-1</p>
<ul>
<li>shmaddr：是shmat()返回的地址指针。</li>
</ul>
</li>
</ul>
</li>
<li><p>其他补充<br>共享内存方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，<br>这就导致了在多进程并发下，最终结果是不可预测的，所以对这块临界区的访问需要通过信号量进行进程同步。</p>
<p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系<br>其次，共享内存的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射的内存地址直接读写数据即可。</p>
</li>
</ul>
<ol start="5">
<li>信号量<br>  在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。<br>  所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。</li>
</ol>
<p>  多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。</p>
<ul>
<li>相关接口：<ul>
<li><p>创建信号量：int semget(key_t key, int nsems, int semflag);<br>创建成功返回信号量标识符，失败返回-1</p>
<ul>
<li><p>key：进程pid</p>
</li>
<li><p>nsems：创建信号量的个数</p>
</li>
<li><p>semflag：指定信号量读写权限</p>
</li>
</ul>
</li>
<li><p>改变信号量值：int semop(int semid, struct sembuf *sops, unsigned npos);<br>我们所需要做的主要工作就是将创建sembuf变量设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p>
<p>struct sembuf结构体定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span>&#123;</span><br><span class="line">  <span class="type">short</span> sem_num;</span><br><span class="line">  <span class="type">short</span> sem_op;</span><br><span class="line">  <span class="type">short</span> sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成功返回信号量标识符，失败返回-1</p>
<ul>
<li><p>semid：信号量标识符，由semget()函数返回</p>
</li>
<li><p>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</p>
</li>
<li><p>nsops：进行操作信号量的个数，即sops结构变量的个数，需要大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</p>
</li>
</ul>
</li>
<li><p>直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);</p>
<ul>
<li><p>semid：信号量集标识符</p>
</li>
<li><p>semnum：信号量集数组上的下标，表示某一个信号量。</p>
</li>
<li><p>arg：union semun类型</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="6">
<li><p>辅助命令<br>  ipcs命令用于报告共享内存、信号量和消息队列信息。</p>
<ul>
<li><p>ipcs -a：列出共享内存、信号量和消息队列信息</p>
</li>
<li><p>ipcs -l：列出系统限额</p>
</li>
<li><p>ipcs -u：列出当前使用情况</p>
</li>
</ul>
</li>
<li><p>套接字<br>  与其他通信机制不同的是，它可以用于不同机器间的进程通信</p>
</li>
</ol>
<hr>
<h2 id="20、虚拟内存的目的？"><a href="#20、虚拟内存的目的？" class="headerlink" title="20、虚拟内存的目的？"></a>20、虚拟内存的目的？</h2><p>虚拟内存的目的是为了让物理内存扩充成为更大的逻辑内存，从而让程序获得更多的可用内存</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块成为一页。</p>
<p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有也都必须在物理内存中。<br>当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。【缺页】</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用讲地址空间中的每一页都映射到物理内存，也就是说一个程序不需要完全调入内存中就可以运行<br>这使得有限内存运行大程序成为可能。</p>
<p>例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64K【2^16】<br>该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。</p>
<img src="/2022/02/28/OperatingSystem/VMemory.png" class="">
<hr>
<h2 id="21、说一下理解中的内存，有什么用？"><a href="#21、说一下理解中的内存，有什么用？" class="headerlink" title="21、说一下理解中的内存，有什么用？"></a>21、说一下理解中的内存，有什么用？</h2><img src="/2022/02/28/OperatingSystem/Memory.png" class="">
<ol>
<li><p>程序执行前需要先放到内存中才能被CPU处理</p>
</li>
<li><p>存储单元、编址方式【按字节编址、按字编址，不同字不同位，一般为8的倍数】</p>
</li>
</ol>
<hr>
<h2 id="22、操作系统经典问题-哲学家进餐"><a href="#22、操作系统经典问题-哲学家进餐" class="headerlink" title="22、操作系统经典问题 - 哲学家进餐"></a>22、操作系统经典问题 - 哲学家进餐</h2><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。<br>哲学家的生活有两种交替活动：吃饭和思考。<br>当一个哲学家吃饭时，需要先拿起自己左右两边的筷子，并且一次只能拿起一根筷子。</p>
<ol>
<li>错误解法：所有哲学家先拿起左边的筷子，则可能出现所有哲学家在等其他哲学家放下筷子，从而导致死锁</li>
</ol>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li><p>必须同时拿起左右两根筷子</p>
</li>
<li><p>只有在两个邻居都没有进餐的情况下才允许进餐</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT (i + N - 1) % N  <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT (i + 1) % N     <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> state[N]; <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line"></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 临界区的互斥，临界区是state数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];       <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="built_in">think</span>(i);</span><br><span class="line">    <span class="built_in">take_two</span>(i);</span><br><span class="line">    <span class="built_in">eat</span>(i);</span><br><span class="line">    <span class="built_in">put_two</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">take_two</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">  state[i] = HUNGRY;</span><br><span class="line">  <span class="built_in">check</span>(i);</span><br><span class="line">  <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">  <span class="built_in">down</span>(&amp;s[i]);  <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put_two</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">  state[i] = THINKING;</span><br><span class="line">  <span class="built_in">check</span>(LEFT);  <span class="comment">// 尝试通知左右邻居，自己已经吃完了，你们可以开始吃了</span></span><br><span class="line">  <span class="built_in">check</span>(RIGHT);</span><br><span class="line">  <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">  state[i] = EATING;</span><br><span class="line">  <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就up(&amp;s[i])，使得down(&amp;s[i])能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING)&#123;</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    <span class="built_in">up</span>(&amp;s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="23、操作系统经典问题-读者写者问题"><a href="#23、操作系统经典问题-读者写者问题" class="headerlink" title="23、操作系统经典问题 - 读者写者问题"></a>23、操作系统经典问题 - 读者写者问题</h2><p>允许多个进程同时对数据进行操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量count记录在对数据进行读操作的进程数量<br>一个互斥类count_mutex用于对count加锁<br>一个互斥量data_mutex用于对读写的数据加锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"></span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;count_mutex);</span><br><span class="line">    count ++;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>)  <span class="built_in">down</span>(&amp;data_mutex);  <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;count_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">down</span>(&amp;count_mutex);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)  <span class="built_in">up</span>(&amp;data_mutex);  <span class="comment">// 最后一个读者要对数据进行解锁，防止写进程无法访问</span></span><br><span class="line">    <span class="built_in">up</span>(&amp;count_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;data_mutex);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="built_in">up</span>(&amp;data_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24、介绍一下几种典型的锁？"><a href="#24、介绍一下几种典型的锁？" class="headerlink" title="24、介绍一下几种典型的锁？"></a>24、介绍一下几种典型的锁？</h2><ol>
<li>读写锁</li>
</ol>
<ul>
<li><p>多个读者可以同时进行读</p>
</li>
<li><p>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</p>
</li>
<li><p>写者优先于读者（一旦有写者，则后续读者必须瞪大，唤醒时优先考虑写者）</p>
</li>
</ul>
<ol start="2">
<li>互斥锁【想象成互斥信号量】<br>  一次只能一个线程拥有互斥锁，其他线程只能等待</li>
</ol>
<p>  互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒<br>  而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的进程或线程，需要把所交给操作系统管理，所以互斥锁在加锁操作时涉及上下文切换。<br>  【上下文切换是指，当得不到互斥变量时，需要移交CPU使用权】</p>
<p>  互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能实现是先自旋一段时间，【说不好瞬间可以使用了】<br>  当自旋的时间超过阈值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。</p>
<ol start="3">
<li>条件变量<br>  互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。</li>
</ol>
<p>  而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。【锁住同步信号量】<br>  当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。<br>  一旦其他的某个线程改变了条件变量，他讲通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。</p>
<p>  总的来说，<b>互斥锁是线程间互斥的机制，条件变量则是同步的机制</b></p>
<ol start="4">
<li>自旋锁<br>  如果进线程无法取得锁，进线程不会立即放弃CPU时间片，而是一直循环尝试获取锁，直到获取位置。</li>
</ol>
<p>  如果别的线程长时间占有锁，那么自旋锁就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高</p>
<hr>
<h2 id="24-1、哪几种线程锁"><a href="#24-1、哪几种线程锁" class="headerlink" title="24-1、哪几种线程锁"></a>24-1、哪几种线程锁</h2><ol>
<li>互斥锁（mutex）<br>  互斥锁属于 sleep-waiting 类型的锁，<br>  例如在一个双核的机器上有两个线程A和B，他们分别运行在 core 0 和 core 1 上。<br>  假设线程 A 想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正在被线程 B 所持有</li>
</ol>
<p>  那么线程 A 就会被阻塞，此时会通过上下文切换将线程 A 置于等待队列中，此时 core 0 就可以运行其他的任务（如线程C）</p>
<ol start="2">
<li><p>条件变量（cond）</p>
</li>
<li><p>自旋锁（spin）</p>
</li>
</ol>
<ul>
<li><p>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B持有，<br>那么线程A就会一直在core 0上进行忙等并不停进行锁请求，检查该自旋锁是否已经被B释放，直到得到这个锁为止。</p>
<p>因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。【不会引发上下文切换】</p>
</li>
<li><p>虽然效率比互斥锁高，但也有不足之处</p>
<ul>
<li><p>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU<br>如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</p>
</li>
<li><p>在用自旋锁时有可能造成死锁，当递归调用时可能造成死锁。</p>
</li>
</ul>
</li>
<li><p>自旋锁只有在内核可抢占式或 SMP（对称多处理） 的情况下才真正需要<br>在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。<br>自旋锁适用于锁使用者保持锁时间比较短的情况下。</p>
</li>
</ul>
<hr>
<h2 id="25、逻辑地址-VS-物理地址"><a href="#25、逻辑地址-VS-物理地址" class="headerlink" title="25、逻辑地址 VS 物理地址"></a>25、逻辑地址 VS 物理地址</h2><p>编译时只需确定变量x存放的相对地址是100（也就是说对于进程在内存中的起始地址而言的地址）<br>CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址 + 100即可。</p>
<h2 id="相对地址又称逻辑地址，绝对地址又称物理地址。"><a href="#相对地址又称逻辑地址，绝对地址又称物理地址。" class="headerlink" title="相对地址又称逻辑地址，绝对地址又称物理地址。"></a>相对地址又称逻辑地址，绝对地址又称物理地址。</h2><h2 id="26、怎么回收线程？有哪几种方法？"><a href="#26、怎么回收线程？有哪几种方法？" class="headerlink" title="26、怎么回收线程？有哪几种方法？"></a>26、怎么回收线程？有哪几种方法？</h2><ul>
<li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);<br>主线程调用，等待子线程退出并回收其资源，类似于进程中wait&#x2F;waitpid回收僵尸进程，调用pthread_join的线程会被阻塞</p>
<ul>
<li><p>tid：创建线程时通过指针得到的tid值</p>
</li>
<li><p>retval：指向返回值的指针</p>
</li>
</ul>
</li>
<li><p>结束线程：pthread_exit(void* retval);<br>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可以通过pthread_join获得。</p>
<ul>
<li>retval：同上</li>
</ul>
</li>
<li><p>分离线程：int pthread_detach(pthread_t tid);<br>主线程、子线程均可调用。<br>主线程中pthread_detach(tid)<br>子线程中pthread_detach(pthread_self())</p>
<p>调用后和主线程分离，子线程结束时自己立即回收资源。</p>
<ul>
<li>tid：同上。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="27、内存的覆盖是什么？有什么特点？"><a href="#27、内存的覆盖是什么？有什么特点？" class="headerlink" title="27、内存的覆盖是什么？有什么特点？"></a>27、内存的覆盖是什么？有什么特点？</h2><p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序）<br>因此可以把用户空间分成一个固定区和若干个覆盖区。</p>
<p>将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中<br>在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点：<br>  打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行<br>  再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。</p>
<blockquote>
<p>覆盖：<br>  针对一个程序而言，内存放不下完整的一个程序，则需要覆盖，将磁盘的覆盖区换入内存中</p>
</blockquote>
<hr>
<h2 id="28、内存交换是什么？有什么特点？"><a href="#28、内存交换是什么？有什么特点？" class="headerlink" title="28、内存交换是什么？有什么特点？"></a>28、内存交换是什么？有什么特点？</h2><p><b>交换（对换）技术的设计思想：</b><br>  内存空间紧张时，系统将内存中某些进程暂时换出外存，把内存中某些已具备运行条件的进程还如内存（进程在内存和磁盘间动态调度）</p>
<p>换入：<br>  把准备好竞争CPU运行的程序从辅存移到内存。</p>
<p>换出：<br>  把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。</p>
<blockquote>
<p>内存交换：<br>  多用于多道程序设计环境下</p>
</blockquote>
<hr>
<h2 id="29、什么时候会进行内存交换？"><a href="#29、什么时候会进行内存交换？" class="headerlink" title="29、什么时候会进行内存交换？"></a>29、什么时候会进行内存交换？</h2><p>内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。</p>
<p>例如：<br>  在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；<br>  如果缺页率明显下降，就可以暂停换出。</p>
<hr>
<h2 id="30、终端退出，终端运行的进程会怎样？"><a href="#30、终端退出，终端运行的进程会怎样？" class="headerlink" title="30、终端退出，终端运行的进程会怎样？"></a>30、终端退出，终端运行的进程会怎样？</h2><p>终端在退出时会发送 SIGHUP 给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，<br>如果程序没有对 SIGHUP 信号作特殊处理，那么进程就会随着终端关闭而退出</p>
<hr>
<h2 id="31、如何让进程后台运行"><a href="#31、如何让进程后台运行" class="headerlink" title="31、如何让进程后台运行"></a>31、如何让进程后台运行</h2><ol>
<li><p>命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p>
</li>
<li><p>ctrl + z 挂起进程，使用jobs查看序号，在使用 bg % 序号后台运行进程</p>
</li>
<li><p>nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</p>
</li>
<li><p>运行指令前面 + setsid，使其父进程变成 init 进程，不受 HUP 信号影响</p>
</li>
<li><p>将 命令+&amp; 放在()括号中，也可以使进程不受HUP信号的影响</p>
</li>
</ol>
<hr>
<h2 id="32、什么是快表，知道多少关于快表的知识？"><a href="#32、什么是快表，知道多少关于快表的知识？" class="headerlink" title="32、什么是快表，知道多少关于快表的知识？"></a>32、什么是快表，知道多少关于快表的知识？</h2><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器<br>用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>
<img src="/2022/02/28/OperatingSystem/TLB.png" class="">
<hr>
<h2 id="33、地址变换中，有快表和没快表有什么区别？"><a href="#33、地址变换中，有快表和没快表有什么区别？" class="headerlink" title="33、地址变换中，有快表和没快表有什么区别？"></a>33、地址变换中，有快表和没快表有什么区别？</h2><p>||地址变换过程|访问一个逻辑地址的访存次数|<br>|基本地址变换机构|1、算页号、页内偏移量；2、检查页号合法性；3、查页表，找到页面存放的内存块号；4、根据内存块号和页内偏移得到物理地址；5、访问目标内存单元|两次访存|</p>
<h2 id="具有快表的地址变换机构-1、算页号、页内偏移量；2、检查页号合法性；3、查快表，若命中，即可知道页面存放的内存块号，可直接进行5、若未命中则进行4；4、查页表，找到页面存放的内存块号，并且将页表项复制到快表中；5、根据内存块号和页内偏移量得到物理地址；6、访问目标内存单元-快表命中则需要一次访存；快表未命中则需要两次访存"><a href="#具有快表的地址变换机构-1、算页号、页内偏移量；2、检查页号合法性；3、查快表，若命中，即可知道页面存放的内存块号，可直接进行5、若未命中则进行4；4、查页表，找到页面存放的内存块号，并且将页表项复制到快表中；5、根据内存块号和页内偏移量得到物理地址；6、访问目标内存单元-快表命中则需要一次访存；快表未命中则需要两次访存" class="headerlink" title="|具有快表的地址变换机构|1、算页号、页内偏移量；2、检查页号合法性；3、查快表，若命中，即可知道页面存放的内存块号，可直接进行5、若未命中则进行4；4、查页表，找到页面存放的内存块号，并且将页表项复制到快表中；5、根据内存块号和页内偏移量得到物理地址；6、访问目标内存单元|快表命中则需要一次访存；快表未命中则需要两次访存|"></a>|具有快表的地址变换机构|1、算页号、页内偏移量；2、检查页号合法性；3、查快表，若命中，即可知道页面存放的内存块号，可直接进行5、若未命中则进行4；4、查页表，找到页面存放的内存块号，并且将页表项复制到快表中；5、根据内存块号和页内偏移量得到物理地址；6、访问目标内存单元|快表命中则需要一次访存；快表未命中则需要两次访存|</h2><h2 id="34、在执行malloc申请内存的时候，操作系统是怎么做的？"><a href="#34、在执行malloc申请内存的时候，操作系统是怎么做的？" class="headerlink" title="34、在执行malloc申请内存的时候，操作系统是怎么做的？"></a>34、在执行malloc申请内存的时候，操作系统是怎么做的？</h2><p>从操作系统层面上看，malloc是通过两个系统调用来实现的：brk和mmap</p>
<ul>
<li><p>brk：将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</p>
</li>
<li><p>mmap：在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</p>
</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存；大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址<br>在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<hr>
<h2 id="35、守护进程、僵尸进程和孤儿进程"><a href="#35、守护进程、僵尸进程和孤儿进程" class="headerlink" title="35、守护进程、僵尸进程和孤儿进程"></a>35、守护进程、僵尸进程和孤儿进程</h2><ul>
<li><p>守护进程<br>指在后台运行的，没有控制终端与之相连的进程。它独立与控制终端，周期性地执行某种任务。<br>Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等。</p>
<p>创建守护进程要点：</p>
<ol>
<li><p>让程序在后台执行，方法是调用fork()产生一个子进程，然后使父进程退出。</p>
</li>
<li><p>调用setsid() 创建一个新对话器。控制中断、登录会话和进程组通常是从父进程继承下来的<br>守护进程要摆脱他们，不受他们的影响，方法是调用setsid()使进程成为一个会话组长。<br>setsid() 调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。</p>
</li>
<li><p>禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。<br>为了避免这种情况发生，可以通过使进程不再是会话组长来实现。<br>再一次通过fork()创建新的子进程，使调用fork的进程退出。</p>
</li>
<li><p>关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。<br>如不关闭，则会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误<br>首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符</p>
</li>
<li><p>将当前目录更改为根目录。</p>
</li>
<li><p>子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为了防止这一点，使用unmask(0)将屏蔽字清零。</p>
</li>
<li><p>处理 SIGCHLD 信号。对于服务器进程，在请求到来时往往生成子进程处理请求。<br>如果子进程等待父进程捕获状态，则子进程将成为僵尸进程(zombie)，从而占用系统资源。<br>如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。<br>在Linux下可以简单地将 SIGCHLD 信号的操作设为 SIG_IGN。这样子进程结束时不会产生僵尸进程。</p>
</li>
</ol>
</li>
<li><p>孤儿进程<br>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。<br>（注意：任何一个进程都必须有父进程）</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。<br>孤儿进程将被init进程（进程号为1）收养，并由init进程对它们完成状态收集工作。</p>
</li>
<li><p>僵尸进程<br>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则此时子进程就变成了僵尸进程。</p>
<p>设置<b>僵尸进程</b>的目的是维护子进程的信息，以便父进程在以后某个时候获取。<br>这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间</p>
<p>所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。</p>
<p>如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）<br>继承这些子进程的init进程将清理他们（也就是说init进程将wait它们，从而去除他们的僵尸状态）</p>
</li>
</ul>
<hr>
<h2 id="36、如何避免僵尸进程？"><a href="#36、如何避免僵尸进程？" class="headerlink" title="36、如何避免僵尸进程？"></a>36、如何避免僵尸进程？</h2><ul>
<li><p>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核收回。<br>如果不想让父进程挂起，可以在父进程中加入一条语句:signal(SIGCHLD, SIG_IGN);<br>表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p>
</li>
<li><p>父进程调用wait&#x2F;waitpid等函数等待子进程结束，如果尚无子进程退出，wait会导致父进程阻塞，waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p>
</li>
<li><p>如果父进程很慢可以使用signal注册信号处理函数，在信号处理函数调用wait&#x2F;waitpid等待子进程退出。</p>
</li>
<li><p>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。<br>这样子进程退出后会被父进程等待回收，然而对于孙子进程，其父进程已经退出，使得孙进程变成一个孤儿进程。<br>孤儿进程由init进程接管，孙进程结束后，init会等待回收。</p>
</li>
</ul>
<p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧。<br>因为并发服务器通常fork许多子进程，子进程结束之后需要服务器进程去wait清理资源。</p>
<h2 id="如果将此信号的处理方式设为忽略，可以让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。"><a href="#如果将此信号的处理方式设为忽略，可以让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。" class="headerlink" title="如果将此信号的处理方式设为忽略，可以让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。"></a>如果将此信号的处理方式设为忽略，可以让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</h2><h2 id="37、局部性原理？主要有哪两大局部性原理？是什么？"><a href="#37、局部性原理？主要有哪两大局部性原理？是什么？" class="headerlink" title="37、局部性原理？主要有哪两大局部性原理？是什么？"></a>37、局部性原理？主要有哪两大局部性原理？是什么？</h2><p>主要分为<b>时间局部性</b>和<b>空间局部性</b></p>
<ul>
<li><p>时间局部性：<br>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；<br>如果某个数据被访问过，不久之后该数据很有可能再次被访问。（因为程序中存在大量循环）</p>
</li>
<li><p>空间局部性：<br>一旦程序访问了某个内存单元，在不就之后，其附近的存储单元也很有可能被访问<br>（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p>
</li>
</ul>
<img src="/2022/02/28/OperatingSystem/Local.png" class="">
<hr>
<h2 id="38、父进程、子进程、进程组、作业和会话"><a href="#38、父进程、子进程、进程组、作业和会话" class="headerlink" title="38、父进程、子进程、进程组、作业和会话"></a>38、父进程、子进程、进程组、作业和会话</h2><ul>
<li><p>父进程<br>已创建一个或者多个子进程的进程</p>
</li>
<li><p>子进程<br>由fork创建的新进程被称为子进程（child process）<br>该函数被调用一次，但返回两次。两次返回的区别是，子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程id。</p>
<p>将子进程id返回给父进程的理由是：<br>  因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。</p>
<p>对于子进程来说：<br>  之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid;<br>  也可以调用getppid()来获取其父进程的id。<br>  (进程id 0 总是由交换进程使用，所以一个子进程的进程id不可能为0)</p>
<p>fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在OS看来，他们更像是兄弟关系。<br>这2个进程共享代码空间，但是数据空间是相互独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，<br>子进程拥有父进程当前运行到的位置（两个进程的程序计数器PC值相同，也就是说，子进程是从fork返回处开始执行的）</p>
<p>但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p>
<p>子进程从父进程继承的有：</p>
<ol>
<li><p>进程的资格（真实(real)&#x2F;有效(effective)&#x2F;已保存(saved)&#x2F;用户号(UIDs)&#x2F;组号(GIDs))</p>
</li>
<li><p>环境(environment)</p>
</li>
<li><p>堆栈</p>
</li>
<li><p>内存</p>
</li>
<li><p>进程组号</p>
</li>
</ol>
<p>独有：</p>
<ol>
<li><p>进程号</p>
</li>
<li><p>不同的父进程号（即：子进程的父进程号与父进程的父进程号不同，父进程号可以由getppid函数获得）</p>
</li>
<li><p>资源使用(resource utilizations)设定为0</p>
</li>
</ol>
</li>
<li><p>进程组<br>进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。<br>只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。</p>
</li>
<li><p>作业<br>shell分前后台来控制的不是进程而是作业(job) 或者 进程组(Process Group)</p>
<p>一个前台作业可以由多个进程组成，一个后台作业也可以由多个进程组成。<br>shell可以运行一个前台作业和任意多个后台作业，这称为作业控制。</p>
<p><b>为什么只能运行一个前台作业？</b><br>  答：当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。<br>  但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。<br>  作业和进程组的区别：<br>如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。<br><br>一旦作业运行结束，shell就把自己提到前台（子进程还在，但是子进程不属于作业）<br>如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组。</p>
</li>
<li><p>会话<br>会话（Session）是一个或多个进程组的集合。<br>一个会话可以有一个控制终端，在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p>
</li>
</ul>
<hr>
<h2 id="39-进程终止的集中方式"><a href="#39-进程终止的集中方式" class="headerlink" title="39.进程终止的集中方式"></a>39.进程终止的集中方式</h2><ol>
<li><p>main函数的自然返回， <code>return</code></p>
</li>
<li><p>调用<code>exit()</code>函数， 属于c的函数库</p>
</li>
<li><p>调用<code>_exit()</code>函数，属于系统调用</p>
</li>
<li><p>调用<code>abort()</code>函数，程序异常终止，同时发送SIGABRT信号给调用进程。</p>
</li>
<li><p>接收能导致进程终止的信号：<code>ctrl + C(^C)</code>、<code>SIGINT(SIGINT中断进程)</code></p>
</li>
</ol>
<img src="/2022/02/28/OperatingSystem/exitAND_exit.png" class="">
<hr>
<h2 id="40、Linux中异常和中断的区别"><a href="#40、Linux中异常和中断的区别" class="headerlink" title="40、Linux中异常和中断的区别"></a>40、Linux中异常和中断的区别</h2><ul>
<li><p>中断（外中断）<br>大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断。</p>
<p>所以，我们需要知道：中断是由硬件设备产生的，而他们从物理上说就是电信号，之后，他们通过中断控制器发送给CPU<br>接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。</p>
<p>中断处理流程：</p>
<img src="/2022/02/28/OperatingSystem/Interrupt.png" class="">
</li>
<li><p>异常（内中断）<br>我们在学习《计算机组成原理》时会知道两个概念，CPU处理程序时一旦程序不在内存中，会产生缺页异常；<br>当运行除法程序时，当除数为0时，又会产生除0异常。<br>所以，需要记住的是：<b>异常是由CPU产生的，同时它会发送给内核，要求内核处理这些异常</b></p>
<p>下面这张图显示了异常处理的流程：</p>
<img src="/2022/02/28/OperatingSystem/exception.png" class="">
</li>
<li><p>相同点：</p>
<ul>
<li><p>最后都是由 CPU 发送给内核，由内核去处理</p>
</li>
<li><p>处理程序的流程设计上是相似的</p>
</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><p>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的。</p>
</li>
<li><p>内核需要根据是异常还是中断，调用不同的处理程序。</p>
</li>
<li><p>中断不是时钟同步的，这意味着中断可能随时到来；<br>异常由于是CPU产生的，所以他是时钟同步的</p>
</li>
<li><p>当处理中断时，处于中断上下文中；<br>当处理异常时，处于进程上下文中</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="41、Windows-和-Linux-环境下内存分布情况"><a href="#41、Windows-和-Linux-环境下内存分布情况" class="headerlink" title="41、Windows 和 Linux 环境下内存分布情况"></a>41、Windows 和 Linux 环境下内存分布情况</h2><img src="/2022/02/28/OperatingSystem/WLMemory.png" class="">

<p>通过这张图可以看到，用户空间内存，从<b>低到高</b>分别是7中不同的内存段</p>
<ul>
<li><p>程序文件段：包括二进制可执行代码；</p>
</li>
<li><p>已初始化数据段：包括静态常量；</p>
</li>
<li><p>未初始化数据段：包括未初始化的静态变量；</p>
</li>
<li><p>堆段：包括动态分配的内存，从低地址开始向上增长；</p>
</li>
<li><p>文件映射段：包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</p>
</li>
<li><p>栈段：包括局部变量和函数调用的上下文等，栈的大小是固定的，一般是<code>8MB</code>。当然系统也提供了参数，供自定义大小；</p>
</li>
</ul>
<hr>
<h2 id="42、一个由C-x2F-C-编译的程序占用的内存分为哪几个部分？"><a href="#42、一个由C-x2F-C-编译的程序占用的内存分为哪几个部分？" class="headerlink" title="42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？"></a>42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？</h2><ol>
<li><p>栈区（stack）：地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。<br>其操作方式类似于数据结构中的队列，先进后出。</p>
</li>
<li><p>堆区（heap）：地址向上增长，一般有程序员分配释放，若程序员不释放，程序结束时可能由OS回收。<br>注意，它与数据结构中的堆是两回事，分配方式类似链表。</p>
</li>
<li><p>全局区（静态区）(static)：全局变量和静态变量的存储是放在一块的<br>初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域<br>程序结束后有系统释放</p>
</li>
<li><p>文字常量区：常量字符串就是放在这里的，<br>程序结束后由系统释放</p>
</li>
<li><p>程序代码区（text）：存放函数体的二进制代码</p>
</li>
</ol>
<hr>
<h2 id="43、一般情况下在Linux-x2F-Windows平台下栈空间的大小"><a href="#43、一般情况下在Linux-x2F-Windows平台下栈空间的大小" class="headerlink" title="43、一般情况下在Linux&#x2F;Windows平台下栈空间的大小"></a>43、一般情况下在Linux&#x2F;Windows平台下栈空间的大小</h2><p>Linux环境下有操作系统决定，一般是8MB，8192KB，通过ulimit命令查看以及修改</p>
<p>Windows环境下由编译器决定，VC++6.0一般是1MB；</p>
<ul>
<li><p>Linux<br>Linux下非编译器决定栈大小，而是由操作系统环境决定，默认是8192KB（8M）；<br>在Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置）<br>即：Windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p>
<p>在Linux下通过如下命令可查看和设置栈的大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -a <span class="comment"># 显示当前栈的大小（ulimit为系统命令，非编译器命令）</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -s 32768 <span class="comment"># 设置当前栈的大小为32MB</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows<br>Windows下程序栈空间的大小，VC++6.0默认的栈空间是1MB</p>
<p>VC6.0中修改堆栈大小的方法：</p>
<ul>
<li><p>选择”Project -&gt; Setting”</p>
</li>
<li><p>选择”Link”</p>
</li>
<li><p>选择”Category”中的”Output”</p>
</li>
<li><p>在”Stack allocations”中的”Reserve:”中输入栈的大小</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"><a href="#44、程序从堆中动态分配内存时，虚拟内存上怎么操作的" class="headerlink" title="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"></a>44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</h2><p>页表：是一个存放在物理内存中的数据结构，它记录了虚拟页和物理页的映射关系</p>
<p>在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间。<br>并更新到页表（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。</p>
<hr>
<h2 id="45、几种常见的磁盘调度算法"><a href="#45、几种常见的磁盘调度算法" class="headerlink" title="45、几种常见的磁盘调度算法"></a>45、几种常见的磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴旋转盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长（物理层面），因此，磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<ol>
<li>先来先服务（FCFS）<br>  按照磁盘请求的顺序进行调度</li>
</ol>
<p>  优点：<br>    公平和简单<br>  缺点：<br>    未对寻道做任何优化，使平均寻道时间可能较长</p>
<ol start="2">
<li>最短寻道时间优先（SSTF）<br>  优先调度与当前磁头所在磁道距离最近的磁道</li>
</ol>
<p>  虽然平均寻道时间比较低，但是不够公平。<br>  如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。</p>
<p>  具体来说：两端的磁道请求更容易出现饥饿现象。<br>  <img src="/2022/02/28/OperatingSystem/ShortPath.png" class=""></p>
<ol start="3">
<li><p>电梯扫描算法<br>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按照一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了SSTF的饥饿问题</p>
<img src="/2022/02/28/OperatingSystem/Scan.png" class=""></li>
</ol>
<hr>
<h2 id="46、交换空间和虚拟内存的关系"><a href="#46、交换空间和虚拟内存的关系" class="headerlink" title="46、交换空间和虚拟内存的关系"></a>46、交换空间和虚拟内存的关系</h2><ul>
<li><p>交换空间<br>Linux中的交换空间（Swap space）在<b>物理内存（RAM）</b>被充满时使用。<br>如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。</p>
<p>虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是内存的取代。</p>
<p>交换空间位于硬盘驱动器上，它比进入物理内存要慢。<br>交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。</p>
<p>交换空间的总大小应该相当于计算机内存的2倍和32MB两个值较大的一个，但是不能超过2048MB（2GB）</p>
</li>
<li><p>虚拟内存<br>虚拟内存是文件数据交叉链接的活动文件。<br>是Windows目录下的一个”WIN 386.SWP” 文件，这个文件会不断地扩大和自动缩小。</p>
<p>就速度方面而言，CPU的L1和L2缓存最快，内存次之，硬盘再次。</p>
<p>但是<b>虚拟内存使用的是硬盘的空间</b>，为什么我们要使用速度最慢的硬盘来做虚拟内存？<br>因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致我们只有少量内存消耗殆尽。</p>
<p>而硬盘空间动辄很多GB，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。</p>
</li>
</ul>
<hr>
<h2 id="47、抖动（颠簸）是什么？"><a href="#47、抖动（颠簸）是什么？" class="headerlink" title="47、抖动（颠簸）是什么？"></a>47、抖动（颠簸）是什么？</h2><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存。</p>
<p>这种频繁的页面调度行为称为抖动，或称颠簸。<br>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块数不够）</p>
<p>为进程分配的物理块太少，会使进程发生抖动现象。<br>为进程分配的物理块太多，又会降低系统整体的并发度，从而降低了某些资源的利用率。</p>
<h2 id="为了研究应该为每个进程分配多少个物理块，Denning提出了进程工作集的概念"><a href="#为了研究应该为每个进程分配多少个物理块，Denning提出了进程工作集的概念" class="headerlink" title="为了研究应该为每个进程分配多少个物理块，Denning提出了进程工作集的概念"></a>为了研究应该为每个进程分配多少个物理块，Denning提出了<code>进程工作集</code>的概念</h2><h2 id="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"><a href="#48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）" class="headerlink" title="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"></a>48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</h2><p>从两方面来考虑：</p>
<ul>
<li><p>分配和释放：<br>堆在分配和释放时都要调用函数（malloc, free），比如分配时会到堆空间中去寻找足够大小的空间（因为多次分配释放后会造成内存碎片）</p>
<p>这些都会花费一定的时间，具体可以看malloc和free的源代码，函数做了很多额外的工作。</p>
<p>然而，栈不需要这些操作</p>
</li>
<li><p>访问时间：<br>访问堆的一个具体单元，需要两次访问内存，第一次取得指针，第二次才是真正的数据；<br>访问栈的一个具体单元，只需要一次访存，因为栈顶已知，偏移量已知，直接可以算出来。</p>
<p>另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</p>
</li>
</ul>
<hr>
<h2 id="49、常见的内存分配方式有哪些？"><a href="#49、常见的内存分配方式有哪些？" class="headerlink" title="49、常见的内存分配方式有哪些？"></a>49、常见的内存分配方式有哪些？</h2><p>内存分配方式：</p>
<ol>
<li><p>从静态存储区域分配：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量，static变量。</p>
</li>
<li><p>在栈上分配：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。<br>栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
</li>
<li><p>在堆上分配：也称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责何时使用free或delete释放内存。<br>动态内存的生存期由程序员决定，使用非常灵活，但问题最多。</p>
</li>
</ol>
<hr>
<h2 id="50、常见内存分配内存错误"><a href="#50、常见内存分配内存错误" class="headerlink" title="50、常见内存分配内存错误"></a>50、常见内存分配内存错误</h2><ol>
<li><p>内存分配未成功，却使用了它</p>
<p>编程新手常犯的错误，因为他们没有意识到内存分配会不成功。<br>常用解决办法：在使用内存之前检查指针是否为NULL，如果指针p是函数的参数，那么在函数的入口处用assert(p!&#x3D;NULL)进行检查</p>
<p>如果是用malloc或new来申请内存，应该用if(p &#x3D;&#x3D; NULL) 或 if(p !&#x3D; NULL) 进行防错处理</p>
</li>
<li><p>内存分配虽然成功，但是尚未初始化就引用它<br>犯这种错误主要有两个起因：</p>
<ol>
<li>是没有初始化的观念；</li>
<li>是误以为内存的缺省初值全为0，导致引用初值错误（例如数组）</li>
</ol>
<p>内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，宁可信其无不可信其有。<br>所以无论用和种方式创建数组，都别忘记赋初值，即使是赋零值也不可省略，不要嫌麻烦。</p>
</li>
<li><p>内存分配成功并且已经初始化，但操作越过了内存的边界<br>例如在使用数组时经常发生下标“多1”或“少1”的情况。<br>特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p>
</li>
<li><p>忘记释放内存，造成内存泄漏<br>含有这种错误的函数每被调用一次就丢失一块内存。<br>刚开始时系统的内存充足，看不到有错误。</p>
<p>终有一次程序突然挂掉，系统出现提示：内存耗尽。</p>
<p>动态内存的申请和释放必须配对，程序中malloc和free的使用次数一定要相同，否则肯定有错误（new和delete同理）</p>
</li>
<li><p>释放了内存却继续使用，常见一下三种情况</p>
<ul>
<li><p>程序中的对象调用关系过于复杂，是在难以搞清楚某个对象究竟是否已经释放了内存<br>此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p>
</li>
<li><p>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或“引用”<br>因为该内存在函数体结束时被自动销毁</p>
</li>
<li><p>使用free或delete释放了内存后，没有将指针设置为NULL，导致产生“野指针”。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="51、内存交换中，被换出的进程保存在哪里？"><a href="#51、内存交换中，被换出的进程保存在哪里？" class="headerlink" title="51、内存交换中，被换出的进程保存在哪里？"></a>51、内存交换中，被换出的进程保存在哪里？</h2><p>保存在磁盘中，也就是外存中。<br>具有对换功能的操作系统中，通常把磁盘空间分为文件去和对换区两部分。</p>
<p>文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；<br>对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。</p>
<p>由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度。<br>因此通常对换区采用连续分配方式（学过文件管理章节可理解）</p>
<h2 id="总之，对换区的I-x2F-O速度比文件区更快。"><a href="#总之，对换区的I-x2F-O速度比文件区更快。" class="headerlink" title="总之，对换区的I&#x2F;O速度比文件区更快。"></a>总之，对换区的I&#x2F;O速度比文件区更快。</h2><h2 id="52、在发生内存交换时，有些进程是被优先考虑的？"><a href="#52、在发生内存交换时，有些进程是被优先考虑的？" class="headerlink" title="52、在发生内存交换时，有些进程是被优先考虑的？"></a>52、在发生内存交换时，有些进程是被优先考虑的？</h2><ol>
<li><p>可优先换出阻塞进程；</p>
</li>
<li><p>可换出优先级低进程</p>
</li>
<li><p>为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间（PCB常驻内存，不会被换出外存）</p>
</li>
</ol>
<hr>
<h2 id="53、ASCII、Unicode和UTF-8编码的区别？"><a href="#53、ASCII、Unicode和UTF-8编码的区别？" class="headerlink" title="53、ASCII、Unicode和UTF-8编码的区别？"></a>53、ASCII、Unicode和UTF-8编码的区别？</h2><ul>
<li><p>ASCII<br>ASCII 只有 127 个字符，表示英文字母大小写、数字和一些符号<br>但由于其他语言用ASCII编码表示字节不够<br>例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</p>
</li>
<li><p>Unicode<br>由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，Unicode应运而生。<br>Unicode就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，ASCII是一个字节表示一个字符。</p>
<p>这样如果编译的文本是纯英文的，用Unicode编码比ASCII编码要多一倍的存储空间，在存储和传输上十分不划算。</p>
</li>
<li><p>UTF-8<br>为了解决上述问题，又出现了把Unicode编码转化为<b>“可变长编码”</b> UTF-8编码<br>UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码为三个字节。</p>
<p>如果编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</p>
</li>
<li><p>三者之间的练习<br>搞清楚了 ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>
<ol>
<li><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或需要传输时，转换为UTF-8编码。<br>【Unicode编码不乱码，保存的东西多，存储时需要存储为多个国家共用的语言】</p>
</li>
<li><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换成Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p>
<img src="/2022/02/28/OperatingSystem/ToFile.png" class="">
</li>
<li><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p>
<img src="/2022/02/28/OperatingSystem/ToBrowser.png" class=""></li>
</ol>
</li>
</ul>
<hr>
<h2 id="54、原子操作是如何实现的？"><a href="#54、原子操作是如何实现的？" class="headerlink" title="54、原子操作是如何实现的？"></a>54、原子操作是如何实现的？</h2><p><b>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作</b></p>
<p>首先处理器会自动保证基本的内存操作的原子性。<br>处理器保证从系统内存中读取或写入一个字节是原子的，意思就是当一个处理器读取一个字节时，其他处理器不能访问该字节的内存地址。</p>
<p>Pentium 6和最新的处理器能自动保证单处理器对同一个缓存里进行16&#x2F;32&#x2F;64位的操作是原子的。<br>但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表访问。</p>
<p>但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<ol>
<li>使用总线锁保证原子性：<br>  第一个机制是通过总线锁保证原子性。<br>  如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作）<br>  那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。</li>
</ol>
<p>  举例：i &#x3D; 1，进行两次 i ++ 操作，我们期望的结果是3，但有可能是2<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU1 CPU2</span><br><span class="line">i=<span class="number">1</span>  i=<span class="number">1</span></span><br><span class="line">i+<span class="number">1</span>  i+<span class="number">1</span></span><br><span class="line">i=<span class="number">2</span>  i=<span class="number">2</span></span><br></pre></td></tr></table></figure><br>  原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行+1操作，然后分别写入系统内存中。<br>  那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>  处理器使用总线锁就是来解决这个问题的。<br>  <b>所谓总线锁就是使用处理器提供一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，则该处理器可以独占共享内存</b></p>
<ol start="2">
<li>使用缓存锁保证原子性：<br>  第二个机制是使用缓存锁来保证原子性。<br>  在同一个时刻，我们只需保证对某个内存地址的操作是原子性即可，但<b>总线锁定把CPU和内存之间的通信锁住了</b></li>
</ol>
<p>  这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大<br>  目前处理器在某些场合下使用缓存锁定代替总线锁定来优化。</p>
<p>  频繁使用的内存会缓存在处理器的L1&#x2F;L2和L3高速缓存里；<br>  那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。</p>
<p>  在Pentium 6 和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性</p>
<p>  所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，<br>  处理器不在总线上声明LOCK#信号，而是修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性。</p>
<p>  因为<b>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已经被锁定的缓存行的数据时，会使缓存行无效，<br>  在上图所示例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时使用缓存i的缓存行。</b></p>
<p>  但是有两种情况下处理器不会使用缓存锁定：<br>    1. 操作的数据不能被缓存在处理器内部，或操作的数据跨越多个缓存行（cache line）时，处理器会调用总线锁定。</p>
<pre><code>2. 有些处理器不支持缓存锁定，对于Intel 486 和 Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。
</code></pre>
<hr>
<h2 id="56、系统并发和并行？"><a href="#56、系统并发和并行？" class="headerlink" title="56、系统并发和并行？"></a>56、系统并发和并行？</h2><ul>
<li><p>并发<br>并发是指宏观上在一段时间内能同时运行多个程序，但是同一时刻只能运行一条指令</p>
<p>操作系统通过进入进程和线程，使程序能并发运行。</p>
</li>
<li><p>并行<br>同一时刻能运行多个指令</p>
<p>需要硬件支持：如多流水线、多核处理器或者分布式计算系统</p>
</li>
</ul>
<hr>
<h2 id="57、页面置换算法总结"><a href="#57、页面置换算法总结" class="headerlink" title="57、页面置换算法总结"></a>57、页面置换算法总结</h2><ol>
<li>最佳置换算法（OPT）<br>  最佳置换算法（OPT，Optimal）：<br> 每次选择淘汰的页面将是以后永不使用，或在最长时间内不再被访问的页面，这样可以保证最低的缺页率</li>
</ol>
  <img src="/2022/02/28/OperatingSystem/Optimal.png" class="">

<p>  最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到哪个页面。<br>  操作系统无法提前预判页面访问序列；<br>  因此，<b>最佳置换算法是无法实现的</b></p>
<ol start="2">
<li>先进先出置换算法（FIFO）<br>  先进先出置换算法（FIFO）：<br> 每次选择淘汰的页面是最早进入内存的页面。</li>
</ol>
<p>  实现方法：<br>    把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。</p>
  <img src="/2022/02/28/OperatingSystem/FIFO_3.png" class="">

  <img src="/2022/02/28/OperatingSystem/FIFO_4.png" class="">

<p>  Belady异常：当为进程分配的物理块数增大的时候，缺页次数不减反增的异常现象。</p>
<p>  只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。<br>  另外FIFO算法虽然实现简单，但是该算法与进程实际运行时候的规律不适应，因此先进入的页面也有可能最经常被访问。<br>  因此，算法性能差。</p>
<p>  FIFO的性能较差，因为较早调入的页面往往是最经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady异常现象。</p>
<p>  Belady异常现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配页面数增多但缺页率反而提高的异常现象。</p>
<ol start="3">
<li>最近最久未使用置换算法（LRU）<br>  最近最久未使用置换算法（LRU，least recently used）：<br> 每次淘汰的页面是最近最久未使用的页面。</li>
</ol>
<p>  实现方法：<br>    赋予每个页面对应的页表项中，用访问字段记录该页面，从上次被访问以来所经历的时间t（该算法的实现需要专门硬件支持，虽然性能好，但实现困难，开销大）。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p>  LRU性能较好，但需要寄存器和栈的硬件支持。<br>  LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</p>
  <img src="/2022/02/28/OperatingSystem/LRU.png" class="">

<p>  在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。<br>  在逆向扫描过程中最后出现的页号就是要淘汰的页面。</p>
<ol start="4">
<li>时钟置换算法（CLOCK）<br>  最佳置换算法（OPT）性能最好，但无法实现；<br>  先进先出算法（FIFO）实现简单，但算法性能差；<br>  最近最久未使用算法（LRU）性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</li>
</ol>
<p>  所以 OS 的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。<br>  因为算法要循环扫描缓冲区像时钟一样转动，所以叫做CLOCK算法。</p>
<p>  时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，Not Recently User）</p>
<p>  简单的CLOCK算法实现方法：<br>    为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。<br>    当某页被访问时，其访问位置为1；<br>    当需要淘汰一个页面时，只需检查页的访问位，若是0，就选择该页换出；若是1，则将它置0，暂不换出，继续检查下一个页面。</p>
<pre><code>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，在进行第二轮扫描
（第二轮扫描中一定会有访问为为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多需要经过两轮扫描）
</code></pre>
  <img src="/2022/02/28/OperatingSystem/CLOCK.png" class="">

<ol start="5">
<li>改进的时钟置换算法<br>  简单的时钟置换算法仅考虑到一个页面最近是否被访问过。<br>  事实上，如果被淘汰页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</li>
</ol>
<p>  因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应该考虑页面是否被修改过。<br>  在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。<br>  这就是改进型的时钟置换算法思想。<br>  修改位 &#x3D; 0，说明页面最近没有被修改过；修改位 &#x3D; 1，说明页面最近被修改过。</p>
<p>  为了方便讨论，用（访问位，修改位）的形式表示各页面状态。<br>  例如：（1,1）表示最近一个页面最近被访问过，且被修改过。</p>
<p>  改进型的CLOCK算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。<br>  在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。</p>
<p>  访问位A和修改位M可以组成以下四种类型的页面</p>
<p>  算法规则：将所有可能被置换的页面排成一个循环队列。</p>
<blockquote>
<p>第一轮：<br>  从当前位置开始扫描到第一个（A&#x3D;0，M&#x3D;0）的帧用于替换。表明该页面最近既没有被访问，也没有被修改，是最佳淘汰页<br>第二轮：<br>  若第一轮扫描失败，则重新扫描，查找第一个（A&#x3D;0，M&#x3D;1）的帧用于替换。<br>  本轮将所有扫描过的帧访问位设置为0。表明该页面最近未被访问，但已被修改，并不是很好的淘汰页。<br>第三轮：<br>  若第二轮扫描失败，则重新扫描，查找第一个（A&#x3D;1，M&#x3D;0）的帧用于替换。<br>  本轮扫描不修改任何标志位。表明该页面最近已被访问，但未被修改。<br>第四轮：<br>  若第三轮扫描失败，则重新扫描，查找第一个（A&#x3D;1，M&#x3D;1）的帧用于替换。<br>  表明该页面最近已被访问也被修改，该页可能再被访问。</p>
</blockquote>
<p>由于第二轮已将所有帧的访问位置为0，因此经过第三轮、第四轮扫描一定会有一个帧选中<br>因此改进型CLOCK置换算法选择一个淘汰页，最多会进行四轮扫描。</p>
  <img src="/2022/02/28/OperatingSystem/CLOCK_pro.png" class="">

<blockquote>
<p>算法规则：将所有可能被置换的页面排成一个循环队列<br>第一轮：<br>  从当前位置开始扫描第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位（第一优先级：最近未访问、最近未修改的页面）<br>第二轮：<br>  若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0（第二优先级：最近没访问，但修改过的页面）<br>第三轮：<br>  若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮不修改任何标志位（第三优先级：最近被访问，但没修改过的页面）<br>第四轮：<br>  若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。（第四优先级：最近访问过，且修改过的页面）<br>由于<code>第二轮已将所有帧的访问位置为0</code>，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多四轮扫描。</p>
</blockquote>
<ol start="6">
<li>总结<br>||算法规则|优缺点|<br>|OPT|优先淘汰最长时间内不会被访问的页面|缺页率最小，性能最好，但无法实现|<br>|FIFO|优先淘汰最先进入内存的页面|实现简单；性能很差，可能出现Belady异常|<br>|LRU|优先淘汰最近最近没访问的页面|性能最好；但是需要硬件支持，算法开销大|<br>|CLOCK（NRU）|循环扫描各页面，第一轮淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1，若第一轮没选中，则进行第二轮扫描|实现简单，算法开销小；但未考虑页面是否被修改|<br>|改进型CLOCK（改进型NRU）|若用（访问位，修改位）的形式表示，则第一轮淘汰（0,0）；第二轮（0,1），并将扫描过的页面全部置为0；第三轮：（0,0）；第四轮：（0,1）|算法开销小，性能也不错；同时减少了磁盘IO|</li>
</ol>
<hr>
<h2 id="58-共享是什么？"><a href="#58-共享是什么？" class="headerlink" title="58.共享是什么？"></a>58.共享是什么？</h2><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享</p>
<h2 id="互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。"><a href="#互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。" class="headerlink" title="互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。"></a>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</h2><h2 id="59、死锁相关问题总结"><a href="#59、死锁相关问题总结" class="headerlink" title="59、死锁相关问题总结"></a>59、死锁相关问题总结</h2><p><b>死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去</b></p>
<ol>
<li><p>死锁产生原因<br>  举例：<br> 两个线程A和B，两个数据1和2。<br> 线程A在执行过程中，首先对资源1加锁，然后在去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁；<br> 切换到线程B之，线程B首先对资源2加锁，然后再去给资源1加锁，由于资源1已被线程A加锁，因此线程B无法加锁成功；</p>
<p> 当线程切换回A时，A也无法成功对资源2加锁，因此就造成了线程AB双方互相对一个已加锁的资源的等待，死锁产生</p>
</li>
</ol>
<p>  理论上死锁的四个必要条件，缺一不可：<br>    1. 互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</p>
<pre><code>2. 不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。
3. 请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
4. 循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。【循环等待】
</code></pre>
<ol start="2">
<li>死锁演示<br>  通过代码的形式进行演示，需要两个线程和两个互斥量。</li>
</ol>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>    <span class="comment">// 引入互斥量头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 插入消息，模拟消息不断产生</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insertMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i)&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;插入一条消息：&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      my_mutex1.<span class="built_in">lock</span>(); <span class="comment">// 语句1</span></span><br><span class="line">      my_mutex2.<span class="built_in">lock</span>(); <span class="comment">// 语句2</span></span><br><span class="line">      Msg.<span class="built_in">push_back</span>(i);</span><br><span class="line">      my_mutex2.<span class="built_in">unlock</span>(); </span><br><span class="line">      my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取消息</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">readMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> MsgCom;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i)&#123;</span><br><span class="line">      MsgCom = <span class="built_in">MsgLULProc</span>(i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">MsgLULProc</span>(MsgCom))&#123;</span><br><span class="line">        <span class="comment">// 读出消息了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;消息已读出&quot;</span> &lt;&lt; MsgCom &lt;&lt; endl;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 消息暂时为空</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;消息为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加解锁代码</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">MsgLULProc</span><span class="params">(<span class="type">int</span> &amp;command)</span></span>&#123;</span><br><span class="line">      <span class="type">int</span> curMsg;</span><br><span class="line">      my_mutex2.<span class="built_in">lock</span>(); <span class="comment">// 语句3</span></span><br><span class="line">      my_mutex1.<span class="built_in">lock</span>(); <span class="comment">// 语句4</span></span><br><span class="line">      <span class="keyword">if</span>(!Msg.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">// 读取消息，读完删除</span></span><br><span class="line">        command = Msg.<span class="built_in">front</span>();</span><br><span class="line">        Msg.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">        my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      my_mutex1.<span class="built_in">unlock</span>();</span><br><span class="line">      my_mutex2.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::list&lt;<span class="type">int</span>&gt; Msg; <span class="comment">// 消息变量</span></span><br><span class="line">  std::mutex my_mutex1; <span class="comment">// 互斥量对象1</span></span><br><span class="line">  std::mutex mu_mutex2; <span class="comment">// 互斥量对象2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="comment">// 创建一个插入消息进程</span></span><br><span class="line">  <span class="function">std::thread <span class="title">insertTd</span><span class="params">(&amp;A::insertMsg, &amp;a)</span></span>;  <span class="comment">// 这里要传入引用保证是同一个对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个读取消息进程</span></span><br><span class="line">  <span class="function">std::thread <span class="title">readTd</span><span class="params">(&amp;A::readMsg, &amp;a)</span></span>;  <span class="comment">// 这里要传入引用保证是同一个对象</span></span><br><span class="line"></span><br><span class="line">  insertTd.<span class="built_in">join</span>();</span><br><span class="line">  readTd.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  语句1和语句2表示线程A先锁资源1，再锁资源2；语句3和语句4表示线程B先锁资源2再锁资源1，具备死锁产生的条件。</p>
<ol start="3">
<li>死锁的解决方案</li>
</ol>
<p>  保证上锁的顺序一致。</p>
<ol start="4">
<li>死锁必要条件</li>
</ol>
<ul>
<li><p>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</p>
</li>
<li><p>不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</p>
</li>
<li><p>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源的时候，由该进程继续占有。</p>
</li>
<li><p>循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</p>
</li>
</ul>
<ol start="5">
<li><p>处理方法：<br>  主要有一下四种方法：</p>
<ul>
<li><p>鸵鸟策略</p>
</li>
<li><p>死锁检测和死锁恢复</p>
</li>
<li><p>死锁预防</p>
</li>
<li><p>死锁避免</p>
</li>
</ul>
</li>
<li><p>鸵鸟策略<br>假装根本没有发生问题。</p>
</li>
</ol>
<pre><code>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任何措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大的影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括Unix、Linux和Windows，处理死锁问题的办法仅仅是忽略它。
</code></pre>
<ol start="2">
<li>死锁检测和死锁恢复<br>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</li>
</ol>
<pre><code>1. 每种类型一个资源的死锁检测
&#123;% asset_img DLdetect.png %&#125; 

上图为资源分配图，其中方框表示资源，圆圈表示进程。
资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图A中可以抽取出环，如图B，它满足了链式等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向边是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，
如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。
</code></pre>
<ol start="2">
<li>每种类型多个资源的死锁检测<br><img src="/2022/02/28/OperatingSystem/DLdetect2.png" class=""></li>
</ol>
<pre><code>上图中，有三个进程四种资源，每个数据代表的含义如下：
  * E向量：资源总量

  * A向量：资源剩余量
  * C矩阵：每个进程所拥有的资源数量，每一行都表示一个进程拥有资源的数量
  * R矩阵：每个进程请求的资源数量

进程P_1和P_2所请求的资源都得不到满足，只有进程P_3可以，让P_3执行，之后释放P_3拥有的资源，此时A = (2 2 2 0)
P_2可以执行，执行后释放P_2拥有的资源，此时A = (4, 2, 2, 1)，P_1也可以执行，所有进程都可以顺利执行。没有死锁

算法总结如下：
  每个进程最开始时都不被标记，执行过程中有可能被标记。
  当算法结束时，任何没有被标记的进程都是死锁进程。

  1. 寻找一个没有标记的进程P_i，它所请求的资源小于等于A。
  
  2. 如果找到了这样一个进程，那么C矩阵的第i行向量加到A中，标记该进程，并转回1。【相当于把资源释放了】
  3. 如果没有这样一个进程，算法终止。

3. 死锁恢复
  * 利用抢占恢复

  * 利用回滚恢复
  * 通过杀死进程恢复
</code></pre>
<ol start="3">
<li>死锁预防<br>在程序运行之前预防发生死锁。<br>1. 破坏互斥条件。<br> 例如：假脱机技术SPOOLing，允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</li>
</ol>
<pre><code>2. 破坏请求和保持条件
  一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

3. 破坏不剥夺条件
  允许抢占资源

4. 破坏循环等待条件
  给资源统一编号，进程只能按照编号顺序来请求资源。
</code></pre>
<ol start="4">
<li>死锁避免<br>在程序运行时避免发生死锁。</li>
</ol>
<pre><code>1. 安全状态
&#123;% asset_img avoidDL.png %&#125;

图a的第二列Has表示已经拥有的资源数，第三列Max表示总共需要的资源数，Free表示还可以使用的资源数【此处是单个资源】

从图a开始出发，先让B拥有所需的所有资源（图b），运行结束后释放B，此时Free变为5（图c）；
接着以同样的方式运行C和A，使得所有进程都能成功运行，因此可以称图A所示的状态是安全的。

定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度顺序使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测和死锁的检测类似，因为安全状态必须要求不能发生死锁。
下面的银行家算法和死锁检测算法非常类似，可以结合参考对比

2. 单个资源的银行家算法
  一个小城镇的银行家，向一群客户分别承诺了一定的带宽额度，算法要做的是判断该请求的满足是否会进入不安全状态，如果是，则拒绝请求；否则分配。
  &#123;% asset_img BankerSingle.png %&#125;

  上图c为不安全状态，因此算法会拒绝之前的请求，从而避免进入图c的状态。

3. 多个资源的银行家算法
  &#123;% asset_img BankerMulti.png %&#125;
  上图中有五个进程，四个资源。
  左边的图表表示已经分配的资源，右边的图标表示还需要分配的资源。
  最右边的E/P以及A分别表示：总资源、已分配资源和可用资源；注意三者为向量，不是具体数值
  例如A=（1020），表示四个资源分别剩下1/0/2/0

4. 检查一个状态是否安全的算法：
  * 查找右边的矩阵是否存在一行小于等于向量A，如果不存在这样的行，那么系统就会发生死锁，状态是不安全的。

  * 假若找到这样一行，就将该进程标记为终止，并将其已分配资源添加到A中【当前可用资源】
  * 重复以上两步，直到所有进程都标记为终止，则状态是安全的。

  如果一个状态不是安全的，需要拒绝进入这个状态。
</code></pre>
<h2 id="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片不会有外部碎片？"><a href="#60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片不会有外部碎片？" class="headerlink" title="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片不会有外部碎片？"></a>60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片不会有外部碎片？</h2><p>  分段式分配是按需分配；<br>  固定分配是固定分配的方式；</p>
<h2 id="61、内部碎片与外部碎片"><a href="#61、内部碎片与外部碎片" class="headerlink" title="61、内部碎片与外部碎片"></a>61、内部碎片与外部碎片</h2><ul>
<li><p>内部碎片：<br>分配给某些进程的内存区域中有部分没用上，常见于固定分配方式。</p>
<p>内存总量相同，100M；</p>
<ul>
<li><p>固定分配：将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块用了5M，剩下的5M就是内部碎片。</p>
</li>
<li><p>分段式分配：按需分配，一个程序需要45M，就给分配45M，剩下的55M供其他进程使用，不存在内部碎片。</p>
</li>
</ul>
</li>
<li><p>外部碎片：<br>内存中某些空闲区因为比较小，而难利用上，一般出现在内存动态分配方式中</p>
<ul>
<li>分段式分配：<br>内存总量相同，100M，例如：内存依次分配5M、15M、50M、25M，程序运行一段内时间之后，5M、15M的程序运行完毕，释放内存，其他程序还在运行<br>再次分配一个10M的内存供其他程序使用，只能从头开始分配，这样，就会存在10M + 5M的外部碎片</li>
</ul>
</li>
</ul>
<h2 id="62、如何消除碎片文件"><a href="#62、如何消除碎片文件" class="headerlink" title="62、如何消除碎片文件"></a>62、如何消除碎片文件</h2><ul>
<li><p>对于外部碎片：<br>通过<b>紧凑技术</b>消除，就是操作系统不时地对进程进行移动和整理。<br>但是这需要动态重定位寄存器地支持，且相对费时。<br>紧凑地过程实际上类似于Windows系统中磁盘整理程序，只不过后者是对外存空间的紧凑。</p>
</li>
<li><p>对于外部内存碎片的问题：<br>内存交换</p>
</li>
</ul>
<p>  可以把音乐程序占用的那256M内存写到硬盘上，然后再从硬盘上读回到内存里。<br>  不过再读回的时候，不能装载到原来的位置，而是紧紧跟着那已经被占用的512MB内存后面。<br>  这样就能空缺处连续256MB空间，于是新的200MB程序就可以装载进来。</p>
<p>  回收内存时要尽可能地将相邻的空闲空间合并。</p>
<h2 id="63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h2><ul>
<li><p>存储器：内存</p>
</li>
<li><p>控制器：南桥北桥</p>
</li>
<li><p>运算器：CPU</p>
</li>
<li><p>输入设备：键盘等</p>
</li>
<li><p>输出设备：显示器、网卡等</p>
</li>
</ul>
<h2 id="64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？"><a href="#64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？" class="headerlink" title="64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？"></a>64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</h2><ul>
<li><p>频繁修改：需要频繁创建和销毁的优先使用<b>多线程</b></p>
</li>
<li><p>计算量：需要大量计算的优先使用<b>多线程</b>，因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</p>
</li>
<li><p>相关性：任务间相关性比较强的用<b>多线程</b>，相关性较弱的用<b>多进程</b>。因为线程之间的数据共享和同步比较简单。</p>
</li>
<li><p>多分布：可能要扩展到多机分布的用<b>多进程</b>，多核分布的用<b>多线程</b></p>
</li>
</ul>
<p>实际中常见的是进程+线程的方式，不是非此即彼的。</p>
<h2 id="65、服务器高并发的解决方案？"><a href="#65、服务器高并发的解决方案？" class="headerlink" title="65、服务器高并发的解决方案？"></a>65、服务器高并发的解决方案？</h2><ul>
<li><p>应用数据和静态资源分离：<br>将静态资源（图片，视频，js，CSS等）单独保存到专门的静态资源服务器中<br>在客户端访问的时候从静态资源服务器中返回静态资源，主服务器返回应用数据。</p>
</li>
<li><p>客户端缓存：<br>效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态来实现，在页面过期或有数据更新后再将页面重新缓存。<br>或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li><p>集群和分布式：<br>集群：所有服务器都有相同的功能，请求哪台都可以，主要起分流作用<br>分布式：不同的业务放到不同的服务器中，处理一个请求可能用到多台服务器，起到加快请求处理的速度。</p>
<p>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。<br>同时加快请求处理的速度。</p>
</li>
<li><p>反向代理：<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
</li>
</ul>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/02/28/OperatingSystem/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/02/28/OperatingSystem/";
            const title         = "「操作系统」";
            const excerpt       = `操作系统`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-04-12</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" LeetCode-Tips" href="/2022/02/26/LeetCode-Tips/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" courseraWED" href="/2022/03/01/courseraWED/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/Ru.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">人间归离复归离，借一浮生逃浮生</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B"><span class="toc-text">一、进程-线程-协程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">1、进程、线程和协程的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%96%B0%E5%9F%8E%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">2、线程和新城的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%87%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%EF%BC%9F"><span class="toc-text">3、一个进程可以创建出多少线程，和什么有关？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%8C%BA%E5%88%AB"><span class="toc-text">4、外中断和异常区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">5、进程线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">6、进程调度算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">7、Linux下进程间通信方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Linux%E4%B8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">8、Linux下同步机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%A6%82%E6%9E%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%90%8E%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BA%86%EF%BC%9F"><span class="toc-text">9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8B%A5%E6%9C%AA%E9%87%87%E7%94%A8%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%88%99%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E9%9C%80%E8%A6%81100-100-x3D-200us%EF%BC%8C%E6%98%BE%E7%84%B6%EF%BC%8C%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%E6%9C%BA%E5%88%B6%E5%90%8E%EF%BC%8C%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E9%80%9F%E5%BA%A6%E5%BF%AB%E5%A4%9A%E4%BA%86%E3%80%82"><span class="toc-text">若未采用快表机制，则访问一个逻辑地址需要100+100&#x3D;200us，显然，引入快表机制后，访问一个逻辑地址的速度快多了。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%A6%86%E7%9B%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">10、内存交换和覆盖有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%88%86%E5%88%AB%E8%AF%B4%E8%AF%B4%EF%BC%9F"><span class="toc-text">11、动态分区分配算法有哪几种？分别说说？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94-%E7%94%B1%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E6%BC%94%E5%8F%98%E8%80%8C%E6%9D%A5%EF%BC%8C%E6%AF%8F%E6%AC%A1%E4%BB%8E%E4%B8%8A%E6%AC%A1%E6%9F%A5%E6%89%BE%E7%BB%93%E6%9D%9F%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B%E6%9F%A5%E6%89%BE-%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E4%BB%A5%E5%9C%B0%E5%9D%80%E9%80%92%E5%A2%9E%E6%AC%A1%E5%BA%8F%E6%8E%92%E5%88%97%EF%BC%88%E5%8F%AF%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%89-%E4%B8%8D%E7%94%A8%E6%AF%8F%E6%AC%A1%E9%83%BD%E4%BB%8E%E4%BD%8E%E5%9C%B0%E5%9D%80%E7%9A%84%E5%B0%8F%E5%88%86%E5%8C%BA%E5%BC%80%E5%A7%8B%E6%A3%80%E7%B4%A2%E3%80%82%E7%AE%97%E6%B3%95%E5%BC%80%E9%94%80%E5%B0%8F%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8E%92%E5%BA%8F-%E4%BC%9A%E4%BD%BF%E9%AB%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%88%86%E5%8C%BA%E8%A2%AB%E7%94%A8%E5%AE%8C"><span class="toc-text">|邻近适应|由首次适应演变而来，每次从上次查找结束位置开始查找|空闲分区以地址递增次序排列（可循环链表）|不用每次都从低地址的小分区开始检索。算法开销小，不需要排序|会使高地址空间大分区被用完|</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="toc-text">12、虚拟技术？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">13、进程状态的切换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%E5%88%B0%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">14、一个程序从开始运行到结束的完整过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E9%80%9A%E8%BF%87%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%A7%A3%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-text">15、通过例子讲解逻辑地址转换为物理地址的基本过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">16、进程同步的四种方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%AF%B9%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">17、操作系统在对内存进行管理的时候需要做些什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8CWindows%E4%B8%8B%EF%BC%89%EF%BC%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8CWindows%E4%B8%8B%EF%BC%89"><span class="toc-text">18、进程通信方法（Linux和Windows下），线程通信方法（Linux和Windows下）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="toc-text">19、进程间通信有哪几种形式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%9B%AE%E7%9A%84%EF%BC%9F"><span class="toc-text">20、虚拟内存的目的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">21、说一下理解中的内存，有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90"><span class="toc-text">22、操作系统经典问题 - 哲学家进餐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">23、操作系统经典问题 - 读者写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">24、介绍一下几种典型的锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-1%E3%80%81%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-text">24-1、哪几种线程锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-VS-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-text">25、逻辑地址 VS 物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%9C%B0%E5%9D%80%E5%8F%88%E7%A7%B0%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%E5%8F%88%E7%A7%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E3%80%82"><span class="toc-text">相对地址又称逻辑地址，绝对地址又称物理地址。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E6%80%8E%E4%B9%88%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">26、怎么回收线程？有哪几种方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">27、内存的覆盖是什么？有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">28、内存交换是什么？有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%EF%BC%9F"><span class="toc-text">29、什么时候会进行内存交换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E7%BB%88%E7%AB%AF%E9%80%80%E5%87%BA%EF%BC%8C%E7%BB%88%E7%AB%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-text">30、终端退出，终端运行的进程会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-text">31、如何让进程后台运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E8%A1%A8%EF%BC%8C%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%E5%85%B3%E4%BA%8E%E5%BF%AB%E8%A1%A8%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%9F"><span class="toc-text">32、什么是快表，知道多少关于快表的知识？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%92%8C%E6%B2%A1%E5%BF%AB%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">33、地址变换中，有快表和没快表有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-1%E3%80%81%E7%AE%97%E9%A1%B5%E5%8F%B7%E3%80%81%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%9B2%E3%80%81%E6%A3%80%E6%9F%A5%E9%A1%B5%E5%8F%B7%E5%90%88%E6%B3%95%E6%80%A7%EF%BC%9B3%E3%80%81%E6%9F%A5%E5%BF%AB%E8%A1%A8%EF%BC%8C%E8%8B%A5%E5%91%BD%E4%B8%AD%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9F%A5%E9%81%93%E9%A1%B5%E9%9D%A2%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E5%8F%B7%EF%BC%8C%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C5%E3%80%81%E8%8B%A5%E6%9C%AA%E5%91%BD%E4%B8%AD%E5%88%99%E8%BF%9B%E8%A1%8C4%EF%BC%9B4%E3%80%81%E6%9F%A5%E9%A1%B5%E8%A1%A8%EF%BC%8C%E6%89%BE%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%AD%98%E6%94%BE%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E5%8F%B7%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%86%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%A4%8D%E5%88%B6%E5%88%B0%E5%BF%AB%E8%A1%A8%E4%B8%AD%EF%BC%9B5%E3%80%81%E6%A0%B9%E6%8D%AE%E5%86%85%E5%AD%98%E5%9D%97%E5%8F%B7%E5%92%8C%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E9%87%8F%E5%BE%97%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%9B6%E3%80%81%E8%AE%BF%E9%97%AE%E7%9B%AE%E6%A0%87%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83-%E5%BF%AB%E8%A1%A8%E5%91%BD%E4%B8%AD%E5%88%99%E9%9C%80%E8%A6%81%E4%B8%80%E6%AC%A1%E8%AE%BF%E5%AD%98%EF%BC%9B%E5%BF%AB%E8%A1%A8%E6%9C%AA%E5%91%BD%E4%B8%AD%E5%88%99%E9%9C%80%E8%A6%81%E4%B8%A4%E6%AC%A1%E8%AE%BF%E5%AD%98"><span class="toc-text">|具有快表的地址变换机构|1、算页号、页内偏移量；2、检查页号合法性；3、查快表，若命中，即可知道页面存放的内存块号，可直接进行5、若未命中则进行4；4、查页表，找到页面存放的内存块号，并且将页表项复制到快表中；5、根据内存块号和页内偏移量得到物理地址；6、访问目标内存单元|快表命中则需要一次访存；快表未命中则需要两次访存|</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E5%9C%A8%E6%89%A7%E8%A1%8Cmalloc%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">34、在执行malloc申请内存的时候，操作系统是怎么做的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">35、守护进程、僵尸进程和孤儿进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">36、如何避免僵尸进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B0%86%E6%AD%A4%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%BE%E4%B8%BA%E5%BF%BD%E7%95%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%A9%E5%86%85%E6%A0%B8%E6%8A%8A%E5%83%B5%E5%B0%B8%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%BD%AC%E4%BA%A4%E7%BB%99init%E8%BF%9B%E7%A8%8B%E5%8E%BB%E5%A4%84%E7%90%86%EF%BC%8C%E7%9C%81%E5%8E%BB%E4%BA%86%E5%A4%A7%E9%87%8F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E3%80%82"><span class="toc-text">如果将此信号的处理方式设为忽略，可以让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%B8%A4%E5%A4%A7%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">37、局部性原理？主要有哪两大局部性原理？是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-text">38、父进程、子进程、进程组、作业和会话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E9%9B%86%E4%B8%AD%E6%96%B9%E5%BC%8F"><span class="toc-text">39.进程终止的集中方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81Linux%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">40、Linux中异常和中断的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81Windows-%E5%92%8C-Linux-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-text">41、Windows 和 Linux 环境下内存分布情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81%E4%B8%80%E4%B8%AA%E7%94%B1C-x2F-C-%E7%BC%96%E8%AF%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-text">42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-x2F-Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">43、一般情况下在Linux&#x2F;Windows平台下栈空间的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%A0%86%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8A%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-text">44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">45、几种常见的磁盘调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">46、交换空间和虚拟内存的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">47、抖动（颠簸）是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BA%86%E7%A0%94%E7%A9%B6%E5%BA%94%E8%AF%A5%E4%B8%BA%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%89%A9%E7%90%86%E5%9D%97%EF%BC%8CDenning%E6%8F%90%E5%87%BA%E4%BA%86%E8%BF%9B%E7%A8%8B%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">为了研究应该为每个进程分配多少个物理块，Denning提出了进程工作集的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E4%BB%8E%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%E5%93%AA%E4%B8%AA%E5%BF%AB%EF%BC%9F%EF%BC%88%E8%80%83%E5%AF%9F%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%EF%BC%89"><span class="toc-text">48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">49、常见的内存分配方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="toc-text">50、常见内存分配内存错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%B8%AD%EF%BC%8C%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">51、内存交换中，被换出的进程保存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%B9%8B%EF%BC%8C%E5%AF%B9%E6%8D%A2%E5%8C%BA%E7%9A%84I-x2F-O%E9%80%9F%E5%BA%A6%E6%AF%94%E6%96%87%E4%BB%B6%E5%8C%BA%E6%9B%B4%E5%BF%AB%E3%80%82"><span class="toc-text">总之，对换区的I&#x2F;O速度比文件区更快。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81%E5%9C%A8%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%97%B6%EF%BC%8C%E6%9C%89%E4%BA%9B%E8%BF%9B%E7%A8%8B%E6%98%AF%E8%A2%AB%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%9A%84%EF%BC%9F"><span class="toc-text">52、在发生内存交换时，有些进程是被优先考虑的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81ASCII%E3%80%81Unicode%E5%92%8CUTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">53、ASCII、Unicode和UTF-8编码的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">54、原子操作是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%9F"><span class="toc-text">56、系统并发和并行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">57、页面置换算法总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E5%85%B1%E4%BA%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">58.共享是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90%E7%A7%B0%E4%B8%BA%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%89%93%E5%8D%B0%E6%9C%BA%E7%AD%89%EF%BC%8C%E5%9C%A8%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%EF%BC%8C%E9%9C%80%E8%A6%81%E7%94%A8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-text">互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59%E3%80%81%E6%AD%BB%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text">59、死锁相关问题总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E8%80%8C%E6%97%A0%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%9C%89%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E4%B8%8D%E4%BC%9A%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F"><span class="toc-text">60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片不会有外部碎片？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E3%80%81%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E4%B8%8E%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87"><span class="toc-text">61、内部碎片与外部碎片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E3%80%81%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E7%A2%8E%E7%89%87%E6%96%87%E4%BB%B6"><span class="toc-text">62、如何消除碎片文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E3%80%81%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-text">63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8D%A2%E5%8F%A5%E8%AF%9D%E8%AF%B4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">65、服务器高并发的解决方案？</span></a></li></ol></li></ol>
    </div>
</aside>
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.6em;">动态规划</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.8em;">数据库</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.6em;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.6em;">计算机网络</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/03/30/Git/"><i class="fa  fa-book"></i> Git</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/28/cppRest/"><i class="fa  fa-book"></i> cppRest</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/27/cpp11/"><i class="fa  fa-book"></i> cpp11</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/26/cppMemory/"><i class="fa  fa-book"></i> cppMemory</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/24/STL/"><i class="fa  fa-book"></i> STL</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/ReisenU"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@ReisenU"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/ReisenUx"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 月战老兵月球基地 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by ReisenU.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>




    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="7292006123"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>