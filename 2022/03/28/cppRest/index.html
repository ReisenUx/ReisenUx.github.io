<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>cppRest | 月战老兵月球基地</title>
  <meta name="author" content="ReisenU" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="Cpp 其余问题1、C++的多态性C++的多态性，一言以蔽之即：在基类的函数前加上virtual关键字，在派生类中重写该函数运行时将会根据所指对象的实际类型来调用相应的函数如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。 举例：      C++多态性              12345678910111213141516171819202122232425262">
<meta property="og:type" content="article">
<meta property="og:title" content="cppRest">
<meta property="og:url" content="http://example.com/2022/03/28/cppRest/index.html">
<meta property="og:site_name" content="月战老兵月球基地">
<meta property="og:description" content="Cpp 其余问题1、C++的多态性C++的多态性，一言以蔽之即：在基类的函数前加上virtual关键字，在派生类中重写该函数运行时将会根据所指对象的实际类型来调用相应的函数如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。 举例：      C++多态性              12345678910111213141516171819202122232425262">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2022-03-28T05:19:53.000Z">
<meta property="article:modified_time" content="2022-03-30T08:42:56.222Z">
<meta property="article:author" content="ReisenU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li><a href="/"><i class="fa fa-link"></i>链接</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">月战老兵月球基地</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>月战老兵月球基地</h2> <br />
                        <span>Lunar Capital</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">cppRest</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-03-28</li>
                <li><i class="fa fa-user"></i> 作者 ReisenU</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~22.52K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1648629776222"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Cpp-%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Cpp 其余问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81C-%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">1、C++的多态性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E6%8C%87%E5%90%91%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%B1%BB%E6%8C%87%E9%92%88%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E6%83%85%E5%86%B5%E5%8A%A8%E6%80%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E6%80%A7%E3%80%82"><span class="toc-number">1.2.</span> <span class="toc-text">这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态进行调用，从而实现多态性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">2、为什么析构函数一般写成虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">3、构造函数能否声明为虚函数或者纯虚函数，析构函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88vptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">5、模板函数和模板类的特例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">6、构造函数、析构函数、虚函数可否声明为内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81C-%E6%A8%A1%E6%9D%BF%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%81%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">7、C++模板是什么、底层如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%EF%BC%8C%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%8F%91%E7%94%9F%EF%BC%8CC-%E4%B8%AD%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BA%94%E9%87%87%E7%94%A8virtual%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">1.10.</span> <span class="toc-text">  所以，为了防止这种情况发生，C++中基类的析构函数应采用virtual虚析构函数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">9、析构函数的作用，如何起作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">10、构造函数和析构函数可以调用虚函数吗，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%86%85%E9%83%A8%E9%83%BD%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">11、构造函数、构造函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">12、虚析构函数的作用、父类的析构函数是否要设置为虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">13、构造函数析构函数可否抛出异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.16.</span> <span class="toc-text">14、构造函数一般不定义为虚函数的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%9E%90%E6%9E%84%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">15、类什么时候会析构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">16、构造函数或者析构函数中可以调用虚函数吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%94%B9%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E5%A4%9A%E4%B8%80%E4%B8%AAA-Function"><span class="toc-number">1.19.</span> <span class="toc-text">如果析构函数改为虚函数，则可以多一个A::Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.20.</span> <span class="toc-text">17、构造函数的几种关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text">18、构造函数、拷贝构造函数和赋值操作符的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">19、拷贝构造函数和赋值运算符重载的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E7%B1%BB%E4%B8%AD%E6%9C%89%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%97%B6%E8%A6%81%E9%87%8D%E5%86%99%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%82"><span class="toc-number">1.23.</span> <span class="toc-text">注意：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.24.</span> <span class="toc-text">20、什么是虚拟继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.25.</span> <span class="toc-text">21、什么情况会自动生成默认构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">22、抽象基类为什么不能创建对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.27.</span> <span class="toc-text">23、模板类和模板函数的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%BF%85%E9%A1%BB%E5%8A%A0%EF%BC%8C%E8%80%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8D%E5%BF%85%E5%8A%A0%E3%80%82"><span class="toc-number">1.28.</span> <span class="toc-text">在使用时类模板必须加，而函数模板不必加。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%8C%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%BC%80%E5%8F%91%E8%80%85%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.29.</span> <span class="toc-text">24、多继承的优点，作为一个开发者怎么看待多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">25、模板和实现可不可以不写在一个文件里？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9Dhello-world%E2%80%9D%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E6%89%93%E5%8D%B0%E5%88%B0%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">26、将字符串”hello world”从开始到打印到屏幕上的全过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC"><span class="toc-number">1.32.</span> <span class="toc-text">27、为什么拷贝构造函数必须传引用不能传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E8%83%BD%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E5%B8%B8%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">28、静态函数能定义为虚函数吗？常函数呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">29、虚函数的代价？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.35.</span> <span class="toc-text">30、说一说移动构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%90%88%E6%88%90%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">31、什么情况下会合成构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.37.</span> <span class="toc-text">32、什么时候需要合成拷贝构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">33、构造函数的执行顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%85%A8%E9%83%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">34、一个类中全部构造函数的扩展过程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">35、哪些函数不能是虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">1.41.</span> <span class="toc-text">36、什么是纯虚函数，与虚函数区别</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <h1 id="Cpp-其余问题"><a href="#Cpp-其余问题" class="headerlink" title="Cpp 其余问题"></a>Cpp 其余问题</h1><h2 id="1、C-的多态性"><a href="#1、C-的多态性" class="headerlink" title="1、C++的多态性"></a>1、C++的多态性</h2><p>C++的多态性，一言以蔽之即：<br>在基类的函数前加上virtual关键字，在派生类中重写该函数<br>运行时将会根据所指对象的实际类型来调用相应的函数<br>如果对象类型是派生类，就调用派生类的函数；<br>如果对象类型是基类，就调用基类的函数。</p>
<p>举例：</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>C++多态性</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son1::func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> Son1;</span><br><span class="line">    base-&gt;<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">    base = <span class="keyword">new</span> Son2;</span><br><span class="line">    base-&gt;<span class="built_in">fun</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    base = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// Son1::func()</span></span><br><span class="line"><span class="comment">// Base::func()</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<p>例子中，Base为基类，其中的函数为虚函数。<br>子类1继承并重写了基类的函数，子类2继承基类但并没有重写基类的函数，从结果分析，子类体现了多态性。</p>
<ul>
<li>多态性和底层原理？</li>
</ul>
<ol>
<li><p>虚表<br>  虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。</p>
</li>
<li><p>虚表指针<br>  在含有虚函数的类实例化对象时，对象地址的前四个字节存储指向虚表的指针。</p>
</li>
</ol>
<img src="/2022/03/28/cppRest/vptr.png" class="">

<p><b>上图展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：</b></p>
<ol>
<li><p>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里面保存了虚函数的入口地址。</p>
</li>
<li><p>编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。<br>在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。</p>
</li>
<li><p>所谓合适时机，在派生类<b>定义</b>对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。<br>在构造子类对象时，会先调用父类的构造函数，此时，编译器只”看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；<br>当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。</p>
</li>
<li><p>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；<br>当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；<br>当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面。</p>
</li>
</ol>
<h2 id="这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态进行调用，从而实现多态性。"><a href="#这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态进行调用，从而实现多态性。" class="headerlink" title="这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态进行调用，从而实现多态性。"></a>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态进行调用，从而实现多态性。</h2><h2 id="2、为什么析构函数一般写成虚函数"><a href="#2、为什么析构函数一般写成虚函数" class="headerlink" title="2、为什么析构函数一般写成虚函数"></a>2、为什么析构函数一般写成虚函数</h2><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数。<br>而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p>
<p>如果析构函数不被声明称虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数<br>从而导致派生类对象析构不完全，造成内存泄漏.</p>
<p>所以将析构函数声明为虚函数是十分必要的。<br>在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的情况发生，要将基类的析构函数声明为虚函数。</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>析构函数不是虚函数</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parent constructor function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Parent</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parent destructor function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son constructor function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son destructor function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// Parent constructor function</span></span><br><span class="line"><span class="comment">// Son constructor function</span></span><br><span class="line"><span class="comment">// Parent destrctor function</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<p>将基类的析构函数声明为虚函数：</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>析构函数是虚函数</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Parent</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parent constructor function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Parent</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parent destructor function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son constructor funtion&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Son</span>() <span class="keyword">override</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son destructor function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// Parent constructor function</span></span><br><span class="line"><span class="comment">// Son constructor function</span></span><br><span class="line"><span class="comment">// Son destructor function</span></span><br><span class="line"><span class="comment">// Parent destructor function</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<p>但存在一种特例，在<code>CRTP</code>【编译时绑定】模板中，不应该将析构函数声明为虚函数<br>理论上所有的父类函数都不应该声明为虚函数，因为这种继承方式，不需要虚函数表。</p>
<hr>
<h2 id="3、构造函数能否声明为虚函数或者纯虚函数，析构函数？"><a href="#3、构造函数能否声明为虚函数或者纯虚函数，析构函数？" class="headerlink" title="3、构造函数能否声明为虚函数或者纯虚函数，析构函数？"></a>3、构造函数能否声明为虚函数或者纯虚函数，析构函数？</h2><ul>
<li><p>析构函数：</p>
<ul>
<li><p>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数</p>
</li>
<li><p>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，<br>才会精准调用派生类的析构函数（从该级向上调用虚函数），才能准确销毁数据</p>
</li>
<li><p><b>析构函数可以是纯虚函数</b>，含有纯虚函数的类是抽象类，此时不能被实例化。<br>但派生类可以根据自身需求重新改写基类中的纯虚函数。</p>
</li>
</ul>
</li>
<li><p>构造函数：</p>
<ul>
<li><p>构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而非子类虚函数<br>因为此时子类尚未构造好。</p>
</li>
<li><p>虚函数对应一个vtable（虚函数表），类中存储一个vptr指向这个vtable。<br>如果构造函数是虚函数，就要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。<br>【只有在构造函数之后，才有虚函数表，只有虚函数表，才能调用虚函数】</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h2><p>首先整理虚函数表的特征：</p>
<ul>
<li><p>虚函数表是全局共享的元素，即全局只有一个，在<code>编译时就构造完成</code>。</p>
</li>
<li><p>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段。</p>
</li>
<li><p>虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定<br>即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中。</p>
</li>
</ul>
<p>根据以上特征，虚函数表类似于类中静态成员变量。<br>静态成员变量也是全局共享，大小确定，因此最有可能存在<code>全局数据区</code>，测试结果显示：</p>
<p>虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段中（rodata）<br>这与MS的编译器将虚函数表存放在常量段存在一些差别</p>
<p>由于虚表指针vptr和虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类<br>对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。</p>
<p>一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区。</p>
<p>C++中<code>虚函数表</code>位于只读数据段（.rodata），也就是C++内存模型中的常量区；<br>而<code>虚函数</code>位于代码段（.text），也就是C++内存模型中的代码区。</p>
<hr>
<h2 id="5、模板函数和模板类的特例化"><a href="#5、模板函数和模板类的特例化" class="headerlink" title="5、模板函数和模板类的特例化"></a>5、模板函数和模板类的特例化</h2><ul>
<li><p>引入原因：<br>编写单一的模板，能适应多种类型的需求，使每种类型都具有相同的功能<br>但对于某种特定的类型，如果要实现其特有的功能，单一模板就无法做到，此时需要模板特例化</p>
</li>
<li><p>定义：<br>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
</li>
</ul>
<ol>
<li>模板函数特例化<br>  必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一对空尖括号<br>  表明将原模板的所有模板参数提供实参<br>  举例：  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>特例化模板函数</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 模板函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;    <span class="comment">// 模板特例化，满足针对字符串特定的比较，要提供所有实参，此处只有一个T</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v1, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(v1, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></li>
</ol>
<ul>
<li><p>本质<br>特例化的本质是实例化一个模板，而非重载它。<br>特例化不影响参数匹配。参数匹配都以最佳匹配为原则。<br>例如：此处如果是compare(3, 5)，则调用普通的模板，若为compare(“hi”, “haha”)则调用<b>特例化版本</b>（因为const char*相对于T，更匹配实参类型）</p>
<p>注意二者函数体的语句不同，实现不同功能。</p>
</li>
<li><p>注意<br>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
</li>
</ul>
<ol start="2">
<li>类模板特例化<br>  原理类似函数模板，<br>  不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。<br>  对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>特例化类模板</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;sales_data&gt;&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(sales_data&amp; s)</span></span>;</span><br><span class="line">    <span class="comment">// 里面左右的T都换成特例化类型版本 sales_data</span></span><br><span class="line">    <span class="comment">// 按照最佳匹配原则，若T != sales_data，就用普通类模板，否则就使用含有特定功能的特例化版本。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></li>
</ol>
<ul>
<li><p>类模板的部分实例化<br>不必为所有模板参数提供实参，可以<b>指定一部分而非所有模板参数</b><br>一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参<br>（特例化时类名一定要和原来的模板相同，只是参数类型不同，按照最佳匹配原则，哪个最匹配，就调用相应的模板）</p>
</li>
<li><p>特例化类中的部分成员<br><b>可以特例化类中的部分成员函数而非整个类，举例：</b></p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>特例化部分成员</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Barst</span><span class="params">(T a)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()&#123;</span><br><span class="line">    <span class="comment">// 进行int类型的特例化处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int类型特例化&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;  <span class="comment">// 使用特例化</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();     <span class="comment">// 使用普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();     <span class="comment">// 特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">// Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></li>
</ul>
<hr>
<h2 id="6、构造函数、析构函数、虚函数可否声明为内联函数"><a href="#6、构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="6、构造函数、析构函数、虚函数可否声明为内联函数"></a>6、构造函数、析构函数、虚函数可否声明为内联函数</h2><p>首先，将这些函数声明为内联函数，在语法上没有错误。<br>因为inline和register一样，只是个建议，编译器并不一定内联。</p>
<blockquote>
<p>register关键字：这个关键字请求编译器尽可能将变量存在CPU内部寄存器中，而不是通过内存寻址，可以提高效率。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inline constructor()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inline destructor()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">virtualFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;inline virtual function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">virtualFun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// inline constructor()</span></span><br><span class="line"><span class="comment">// inline virtual function</span></span><br><span class="line"><span class="comment">// inline destructor()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数和析构函数声明为内联函数是没有意义的<br>《Effective C++》中阐述的是：<br>将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作<br>因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等）<br>导致构造函数&#x2F;析构函数并不像看上去的那么精简。</li>
</ul>
<p>其次，class中的函数默认是inline型的，编译器也只是有选择地inline<br>将构造函数和析构函数声明为内联函数是没什么意义的。</p>
<ul>
<li><p>将虚函数声明为inline，要分情况讨论。<br>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，理由是：inline是编译期决定的，虚函数是运行期决定的<br>即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p>
<p>上述观点看似正确，实则不然<br>如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数？<br>即对象调用虚函数（此时不具有多态性）时，就内联展开。</p>
<p>综上：<br>  当是指向派生类指针（具有多态性）调用声明为inline的虚函数时，不会内联展开；<br>  当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下；【不用指针时】</p>
</li>
</ul>
<hr>
<h2 id="7、C-模板是什么、底层如何实现？"><a href="#7、C-模板是什么、底层如何实现？" class="headerlink" title="7、C++模板是什么、底层如何实现？"></a>7、C++模板是什么、底层如何实现？</h2><ol>
<li><p>编译器并不是把函数模板处理成能够处理任意类的函数<br>编译器从函数模板通过具体类型产生不同的函数；<br>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替代后的代码进行编译。</p>
</li>
<li><p>这是因为函数模板要<code>被实例化后</code>才能成为真正的函数，<br>在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，则编译器无法实例化该模板，最终导致链接错误，</p>
</li>
</ol>
<hr>
<h2 id="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><a href="#8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？" class="headerlink" title="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"></a>8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</h2><ol>
<li>从存储空间角度<br>  虚函数需要一个指向vtable虚函数表的指针，但该指针事实上是存储在对象的内存空间的。</li>
</ol>
<p>  假设构造函数是虚函数，就必须要用vtable来调用，但对象还没有实例化，也就是说内存空间还没有，如何找到vtable？<br>  所以<code>构造函数不能是虚函数</code>。</p>
<ol start="2">
<li>从使用角度<br>  虚函数主要用于在信息不全情况下，能使重载的函数得到相应的调用。【指针指向不明确】</li>
</ol>
<p>  构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。</p>
<p>  所以构造函数没有必要是虚函数，虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的成员函数。<br>  而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<ol start="3">
<li>构造函数不需要是虚函数，也不同意是虚函数<br>  由于创建一个对象时我们总是要明白指定对象的类型，虽然我们可能通过基类指针或引用去访问它但析构函数不一定</li>
</ol>
<p>  我们往往通过基类的指针去销毁对象。<br>  此时假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p>
<ol start="4">
<li>从实现上看<br>  vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数</li>
</ol>
<p>  从实际意义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调用父类的构造函数）</p>
<p>  并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。</p>
<ol start="5">
<li>当一个构造函数被调用时，它要做的首要的事情其中一个就是初始化vptr<br>  因此，它仅仅能够知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。</li>
</ol>
<p>  当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码 —— 既不是基类，也不是它的派生类（由于类不知道谁继承他）<br>  所以它使用的vptr必须是对应这个类的vtable。【构造函数值对应自己】</p>
<p>  并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命周期内，vptr将保存被初始化为指向这个vtable，<br>  但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置vptr指向它的vtable…等。直到最后的构造函数结束。</p>
<p>  vptr的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还一个理由。</p>
<p>  可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置vptr指向它自己的vtable。<br>  假设函数调用使用虚函数机制，它将仅仅产生通过它自己的table调用，而不是最后的vtable（全部构造函数被调用后才有最后的vtable）</p>
<p>  因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了在不完全了解细节的情况下也能正确处理对象。<br>  另外，virtual函数是在不同类型的对象产生不同的动作，而现在对象还没有产生，如何使用virtual函数实现想要的动作？</p>
<p>  直白的讲：C++中基类采用的virtual虚析构函数是为了<b>防止内存泄漏</b></p>
<p>  具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。<br>  假设基类中采用的是非析构函数，当删除基类指针指向的派生类对象时，就<b>不会产生动态绑定</b>，因而只会调用基类的析构函数，而不是派生类析构函数。</p>
<p>  这种情况下，派生类中申请的空间就会因为得不到释放而产生内存泄漏</p>
<h2 id="所以，为了防止这种情况发生，C-中基类的析构函数应采用virtual虚析构函数。"><a href="#所以，为了防止这种情况发生，C-中基类的析构函数应采用virtual虚析构函数。" class="headerlink" title="  所以，为了防止这种情况发生，C++中基类的析构函数应采用virtual虚析构函数。"></a>  所以，为了防止这种情况发生，C++中基类的析构函数应采用virtual虚析构函数。</h2><h2 id="9、析构函数的作用，如何起作用？"><a href="#9、析构函数的作用，如何起作用？" class="headerlink" title="9、析构函数的作用，如何起作用？"></a>9、析构函数的作用，如何起作用？</h2><ol>
<li><p>构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里有值了</p>
<p>规则：只要你一实例化对象，系统自动回调一个构造函数；尽管不写，编译器也自动调用一次</p>
</li>
<li><p>析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；<br>特点：析构函数与构造函数同名，但该函数面前加~</p>
<p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。<br>当撤销对象时，编译器也会自动调用析构函数。</p>
<p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。<br>一般析构函数定义为类的公有成员。</p>
</li>
</ol>
<hr>
<h2 id="10、构造函数和析构函数可以调用虚函数吗，为什么？"><a href="#10、构造函数和析构函数可以调用虚函数吗，为什么？" class="headerlink" title="10、构造函数和析构函数可以调用虚函数吗，为什么？"></a>10、构造函数和析构函数可以调用虚函数吗，为什么？</h2><ol>
<li><p>在C++中，不提倡在构造函数和析构函数中调用虚函数；</p>
</li>
<li><p>构造函数和析构函数调用虚函数时都不使用动态联编，<br>如果在构造函数和析构函数中调用虚函数，则运行的是构造函数或析构函数自身类型定义的版本。</p>
</li>
<li><p>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全，因此C++不会进行动态联编</p>
</li>
<li><p>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。<br>所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义</p>
</li>
</ol>
<hr>
<h2 id="11、构造函数、构造函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#11、构造函数、构造函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="11、构造函数、构造函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>11、构造函数、构造函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h2><ol>
<li><p>构造函数顺序</p>
</li>
<li><p>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类<code>派生表中出现的顺序</code>，而非在成员初始化表中的顺序</p>
</li>
<li><p>成员类对象构造函数，如果有多个成员类对象，则构造函数的调用顺序是对象在类中<code>被声明的顺序</code>，而非在成员初始化表中的顺序</p>
</li>
<li><p>派生类构造函数</p>
</li>
<li><p>析构函数顺序</p>
</li>
<li><p>调用派生类的析构函数</p>
</li>
<li><p>调用成员类对象的析构函数</p>
</li>
<li><p>调用基类的析构函数</p>
</li>
</ol>
<hr>
<h2 id="12、虚析构函数的作用、父类的析构函数是否要设置为虚函数？"><a href="#12、虚析构函数的作用、父类的析构函数是否要设置为虚函数？" class="headerlink" title="12、虚析构函数的作用、父类的析构函数是否要设置为虚函数？"></a>12、虚析构函数的作用、父类的析构函数是否要设置为虚函数？</h2><ol>
<li>C++中基类采用virtual虚析构函数是为了防止内存泄漏<br>  具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</li>
</ol>
<p>  假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。</p>
<p>  那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p>
<p>  所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>
<ol start="2">
<li>纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。</li>
</ol>
<p>  因此，缺乏任何一个基类析构函数的定义，就会导致链接失败<br>  最好不要把虚析构函数定义为纯虚析构函数。</p>
<hr>
<h2 id="13、构造函数析构函数可否抛出异常？"><a href="#13、构造函数析构函数可否抛出异常？" class="headerlink" title="13、构造函数析构函数可否抛出异常？"></a>13、构造函数析构函数可否抛出异常？</h2><ol>
<li><p>C++只会析构已经完成的对象，对象只有在其析构函数执行完毕才算是完全构造妥当。<br>在构造函数中发生异常，控制权转出构造函数之外。</p>
<p>因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。</p>
</li>
<li><p>用auto_ptr对象来取代指针<b>类成员</b>，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不在要在析构函数中手动释放资源。</p>
</li>
<li><p>如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束。</p>
</li>
<li><p>如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p>
</li>
</ol>
<hr>
<h2 id="14、构造函数一般不定义为虚函数的原因"><a href="#14、构造函数一般不定义为虚函数的原因" class="headerlink" title="14、构造函数一般不定义为虚函数的原因"></a>14、构造函数一般不定义为虚函数的原因</h2><ol>
<li><p>创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。<br>在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型。</p>
</li>
<li><p>虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中<br>若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚析构函数了</p>
</li>
<li><p>虚函数的作用在于通过父类的指针或者引用调用它时能变成调用相应子类的成员函数。<br>而构造函数是在创建对象时自动调用的，不可能通过父类或引用去调用，因此就规定构造函数不能是虚函数。</p>
</li>
<li><p>析构函数一般都要声明为虚函数，不再赘述。</p>
</li>
</ol>
<hr>
<h2 id="15、类什么时候会析构？"><a href="#15、类什么时候会析构？" class="headerlink" title="15、类什么时候会析构？"></a>15、类什么时候会析构？</h2><ol>
<li><p>对象生命周期结束，被销毁时</p>
</li>
<li><p>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时</p>
</li>
<li><p>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用</p>
</li>
</ol>
<hr>
<h2 id="16、构造函数或者析构函数中可以调用虚函数吗？"><a href="#16、构造函数或者析构函数中可以调用虚函数吗？" class="headerlink" title="16、构造函数或者析构函数中可以调用虚函数吗？"></a>16、构造函数或者析构函数中可以调用虚函数吗？</h2><p>简要结论：</p>
<ul>
<li><p>从语法上讲，没有问题</p>
</li>
<li><p>从效果上将，往往不能达到需要的目的。</p>
</li>
</ul>
<blockquote>
<p>《Effective C++》的解释：派生类对象构造期间进入基类的构造函数时<br>对象类型变成了基类类型，而非派生类类型；进入基类析构函数时，对象也是基类类型。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>()&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::Function&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">Base</span>()&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A::Function&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">A</span>()&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Base *a = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">  <span class="keyword">delete</span> a;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  Base *b = <span class="keyword">new</span> <span class="built_in">A</span>();  <span class="comment">// 语句1</span></span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// Base::Function</span></span><br><span class="line"><span class="comment">// Base::Function</span></span><br><span class="line"><span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">// Base::Function</span></span><br><span class="line"><span class="comment">// A::Function</span></span><br><span class="line"><span class="comment">// Base::Function</span></span><br></pre></td></tr></table></figure>

<p>语句1，理论上应该体现多态性，执行类A中的构造和析构函数<br>从实验结果来看，语句1并没有体现，执行流程是先构造基类，所以先调用基类的构造函数，构造完成再执行A自己的构造函数<br>析构时也是调用基类的析构函数，也就是说构造和析构中调用虚函数并不能达到目的，应该避免。【没有实现动态绑定，只是和指针相关类对应的虚函数】</p>
<h2 id="如果析构函数改为虚函数，则可以多一个A-Function"><a href="#如果析构函数改为虚函数，则可以多一个A-Function" class="headerlink" title="如果析构函数改为虚函数，则可以多一个A::Function"></a>如果析构函数改为虚函数，则可以多一个A::Function</h2><h2 id="17、构造函数的几种关键字"><a href="#17、构造函数的几种关键字" class="headerlink" title="17、构造函数的几种关键字"></a>17、构造函数的几种关键字</h2><ul>
<li><p>default<br>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CString</span>() = <span class="keyword">default</span>;  <span class="comment">// 语句1</span></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="built_in">CString</span>(<span class="type">const</span> <span class="type">char</span>* pstr) : _str(pstr)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> t)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 这样不允许使用new关键字</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">// 语句2</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>如果没有语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题</p>
</li>
<li><p>detele<br>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用时会得到提示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;  <span class="comment">// 这样不允许使用new关键字</span></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">// 语句1</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误<br>因此使用delete关键字可以更加人性化的删除一些默认方法。</p>
</li>
<li><p>0<br>将虚函数定义为纯虚函数，纯虚函数无需定义，&#x3D;0只能出现在类内部虚函数的声明语句处<br>当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。</p>
</li>
</ul>
<hr>
<h2 id="18、构造函数、拷贝构造函数和赋值操作符的区别"><a href="#18、构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="18、构造函数、拷贝构造函数和赋值操作符的区别"></a>18、构造函数、拷贝构造函数和赋值操作符的区别</h2><ul>
<li><p>构造函数<br>对象不存在，没用别的对象初始化，在创建一个对象时调用构造函数</p>
</li>
<li><p>拷贝构造函数<br>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
</li>
<li><p>赋值运算符<br>对象存在，用别的对象给它赋值，这属于重载“&#x3D;”号运算符的范畴，“&#x3D;”两侧的对象都是已经存在的。</p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A&amp; <span class="keyword">operator</span>= (A&amp; a)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;赋值操作符&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a1; <span class="comment">// 调用普通构造函数</span></span><br><span class="line">  A a2 = a1;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">  a2 = a1;  <span class="comment">// 调用赋值操作符</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 普通构造函数</span></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="comment">// 赋值操作符</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="19、拷贝构造函数和赋值运算符重载的区别？"><a href="#19、拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="19、拷贝构造函数和赋值运算符重载的区别？"></a>19、拷贝构造函数和赋值运算符重载的区别？</h2><ul>
<li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p>
</li>
<li><p>拷贝构造函数会生成新的类对象，赋值运算符不生成新的对象</p>
</li>
<li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化之前不需要检查源对象和新建对象是否相同<br>赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉</p>
</li>
<li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数）<br>但并不是所有出现”&#x3D;”的地方都是使用赋值运算符，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = s; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Student s2; </span><br><span class="line">s2 = s; <span class="comment">//赋值运算符操作</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。"><a href="#注意：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。" class="headerlink" title="注意：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。"></a>注意：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。</h2><h2 id="20、什么是虚拟继承"><a href="#20、什么是虚拟继承" class="headerlink" title="20、什么是虚拟继承"></a>20、什么是虚拟继承</h2><p>由于C++支持多继承，除了Public、Protected、Private三种继承方式外，还支持虚拟（virtual）继承<br>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;  <span class="comment">// 1，空对象，只有一个占位</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof(B):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl;  <span class="comment">// 4，一个bptr指针，省去占位，不需要对齐</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof(C):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; endl;  <span class="comment">// 4，一个bptr指针，省去占位，不需要对齐</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof(D):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; endl;  <span class="comment">// 8，两个bptr指针，省去占位，不需要对齐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码所体现的关系是：<br>B和C虚拟继承A，D又公有继承B和C，<br>这种方式是一种<b>菱形继承或钻石继承</b>，可以用下图来表示</p>
<img src="/2022/03/28/cppRest/diamondDerive.png" class="">

<img src="/2022/03/28/cppRest/vDerive.png" class="">

<p><b>虚拟继承情况下，无论基类被继承多少次，只会存在一个实体</b>。<br>虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；<br>表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针又称为bptr，如上图所示。</p>
<p>如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。</p>
<blockquote>
<p>补充：虚继承中，B和C不再保存A中的内容，保存了一份偏移地址，将A的数据保存在一个公共位置处，降低数据冗余性。</p>
</blockquote>
<hr>
<h2 id="21、什么情况会自动生成默认构造函数？"><a href="#21、什么情况会自动生成默认构造函数？" class="headerlink" title="21、什么情况会自动生成默认构造函数？"></a>21、什么情况会自动生成默认构造函数？</h2><ol>
<li><p>带有默认构造函数的类成员对象<br>如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器为该类合成出一个默认构造函数。</p>
<p>不过这个合成操作只有在构造函数真正被需要的时候才会发生。</p>
<p>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行。</p>
</li>
<li><p>带有默认构造函数的基类<br>如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数</p>
</li>
<li><p>带有一个虚函数的类【生成vptr】</p>
</li>
<li><p>带有一个虚基类的类【生成bptr】</p>
</li>
<li><p>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。<br>其他所有的非静态数据成员都不会被初始化。【仅初始化类】</p>
</li>
</ol>
<hr>
<h2 id="22、抽象基类为什么不能创建对象？"><a href="#22、抽象基类为什么不能创建对象？" class="headerlink" title="22、抽象基类为什么不能创建对象？"></a>22、抽象基类为什么不能创建对象？</h2><p>抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层。</p>
<ol>
<li><p>抽象类的定义：称带有纯虚函数的类为抽象类</p>
</li>
<li><p>抽象类的作用：<br>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根<br>派生类将<code>具体实现</code>在其基类中作为接口的操作。</p>
<p>所以派生类实际上刻画了一组子类的操作接口通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
</li>
<li><p>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。<br>如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。<br>如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>抽象类是不能定义对象的，一个纯虚函数不需要（但是可以）被定义。</p>
</li>
<li><p>纯虚函数定义：纯虚函数是一种特殊的虚函数，它的一般格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt; &#123;</span><br><span class="line">  <span class="keyword">virtual</span> &lt;类型&gt; &lt;函数名&gt; ( &lt;参数表&gt; ) = <span class="number">0</span>;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。<br>纯虚函数可以让类现有一个操作名称，但没有操作内容，让派生类在继承时具体地给出定义。</p>
<p>凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。<br>除非在派生类中完全实现基类中所有的纯虚函数，否则，派生类变成了抽象类，也不能实例化对象。</p>
</li>
<li><p>纯虚函数引入原因：</p>
<ol>
<li><p>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p>
</li>
<li><p>在很多情况下，基类本身生成对象是不合情理的。<br>例如：动物作为一个基类可以派生出猫狗等子类，但动物本身生成对象明显不合理。<br>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function() &#x3D; 0）</p>
<p>若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。<br>同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。</p>
<p>例如：绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等<br>如果要求面积总和的话，那可以使用一个shape *的数组，只要一次调用派生类的area()函数了。</p>
<p>如果不用接口就没法定义成数组，因为既可以是circle，也可以是square，而且以后还可能加上rectangle等等。</p>
</li>
</ol>
</li>
<li><p>相似概念</p>
<ol>
<li><p>多态性<br>指相同对象收到不同消息或不同对象收到相同消息时产生的不同实现动作<br>C++支持两种多态性：编译时多态性、运行时多态性。</p>
<ol>
<li>编译时多态性：通过重载函数、模板实现。</li>
<li>运行时多态性：通过虚函数实现。</li>
</ol>
</li>
<li><p>虚函数<br>虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。</p>
</li>
<li><p>抽象类<br>包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</p>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="23、模板类和模板函数的区别是什么？"><a href="#23、模板类和模板函数的区别是什么？" class="headerlink" title="23、模板类和模板函数的区别是什么？"></a>23、模板类和模板函数的区别是什么？</h2><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。</p>
<p>即函数模板允许隐式调用和显式调用<br>而类模板只允许显式调用。</p>
<h2 id="在使用时类模板必须加，而函数模板不必加。"><a href="#在使用时类模板必须加，而函数模板不必加。" class="headerlink" title="在使用时类模板必须加，而函数模板不必加。"></a>在使用时类模板必须加，而函数模板不必加。</h2><h2 id="24、多继承的优点，作为一个开发者怎么看待多继承"><a href="#24、多继承的优点，作为一个开发者怎么看待多继承" class="headerlink" title="24、多继承的优点，作为一个开发者怎么看待多继承"></a>24、多继承的优点，作为一个开发者怎么看待多继承</h2><ol>
<li><p>C++允许一个派生类指定多个基类，这样的继承结构被称为多继承。</p>
</li>
<li><p>多重继承的优点很明显，就是对象可以调用多个基类中的接口</p>
</li>
<li><p>如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性。</p>
</li>
<li><p>加上全局符确定调用哪一份拷贝，比如pa.Author::eat()调用属于Author的拷贝</p>
</li>
<li><p>使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝</p>
</li>
</ol>
<hr>
<h2 id="25、模板和实现可不可以不写在一个文件里？为什么？"><a href="#25、模板和实现可不可以不写在一个文件里？为什么？" class="headerlink" title="25、模板和实现可不可以不写在一个文件里？为什么？"></a>25、模板和实现可不可以不写在一个文件里？为什么？</h2><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译<code>调用模板类或函数的CPP文件</code>时才会去找对应的模板声明和实现</p>
<p>在这种情况下编译器是不知道<code>实现模板类或函数的cpp文件所在，所以只能找到模板类或函数的声明而找不到实现</code>，而只好创建一个符号寄希望于链接程序找地址。</p>
<p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。</p>
<p>《C++编程思想》第15章（300页）说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间。<br>它一直处于等待状态直到被一个模板实例告知。<br>在编译器和链接器的某一处，有一个机制能去掉指定模板的多重定义。<br>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<blockquote>
<p>即，不能不写在一个文件里，因为由template处理的任何东西都意味着编译器在当时不分配存储空间</p>
</blockquote>
<hr>
<h2 id="26、将字符串”hello-world”从开始到打印到屏幕上的全过程？"><a href="#26、将字符串”hello-world”从开始到打印到屏幕上的全过程？" class="headerlink" title="26、将字符串”hello world”从开始到打印到屏幕上的全过程？"></a>26、将字符串”hello world”从开始到打印到屏幕上的全过程？</h2><ol>
<li><p>用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</p>
</li>
<li><p>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；<br>并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</p>
</li>
<li><p>操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</p>
</li>
<li><p>操作系统：为helloworld程序设置cpu上下文环境，并跳转到程序开始处。</p>
</li>
<li><p>执行helloworld程序的第一条指令，发生缺页异常。</p>
</li>
<li><p>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</p>
</li>
<li><p>helloworld程序执行puts函数（系统调用），在显示器上写一字符串</p>
</li>
<li><p>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以操作系统将要写的字符串送给该进程。</p>
</li>
<li><p>操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作<br>然后将字符串转换成像素，将像素写入设备的存储映像区</p>
</li>
<li><p>视频硬件将像素转换成显示器可接收和一组控制数据信号</p>
</li>
<li><p>显示器解释信号，激发液晶屏</p>
</li>
<li><p>屏幕上看到了HelloWorld</p>
</li>
</ol>
<hr>
<h2 id="27、为什么拷贝构造函数必须传引用不能传值"><a href="#27、为什么拷贝构造函数必须传引用不能传值" class="headerlink" title="27、为什么拷贝构造函数必须传引用不能传值"></a>27、为什么拷贝构造函数必须传引用不能传值</h2><ol>
<li><p>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例</p>
</li>
<li><p>参数传递过程到底发生了什么？<br>将地址传递和值传递统一起来，归根结底还是传递的是“值”（地址也是值，只不过通过它可以找到目标值）</p>
<ol>
<li>值传递：<br>  对于内置数据类型的传递时，直接赋值拷贝给形参（注意形参是函数内局部变量）；<br>  对于类类型的传递时，需要首先调用该<code>类的拷贝构造函数</code>来初始化形参（局部对象）；</li>
</ol>
<p>  如void foo(class_type obj_local){}，如果要调用foo(obj);<br>  首先class_type obj_local(obj)，这样就定义了局部变量obj_local供函数内部使用。</p>
<ol start="2">
<li>引用传递：<br>  无论对内置类型还是类类型，传递引用和指针最终都是传递的地址值<br>  而地址总是指针类型（属于简单类型），显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用（对于类类型）</li>
</ol>
<p>因此，如果拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p>
<p>拷贝构造函数用来初始化一个非引用类类型对象<br>如果用值方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归</p>
</li>
</ol>
<hr>
<h2 id="28、静态函数能定义为虚函数吗？常函数呢？"><a href="#28、静态函数能定义为虚函数吗？常函数呢？" class="headerlink" title="28、静态函数能定义为虚函数吗？常函数呢？"></a>28、静态函数能定义为虚函数吗？常函数呢？</h2><ol>
<li><p>static成员不属于任何类对象或类实例，所以即使给此函数加上virtual也是没有任何意义的。</p>
</li>
<li><p>静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。</p>
<p>虚函数依靠 vptr 和 vtable 来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员。<br>并且vptr指向保存虚函数地址的vtable，对于静态成员函数，它没有this指针，所以无法访问 vptr。</p>
</li>
</ol>
<p>这就是为何static函数不能为virtual<br>虚函数的调用关系：<br>  this-&gt;vptr-&gt;vtable-&gt;virtual function</p>
<hr>
<h2 id="29、虚函数的代价？"><a href="#29、虚函数的代价？" class="headerlink" title="29、虚函数的代价？"></a>29、虚函数的代价？</h2><ol>
<li><p>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类所占空间。</p>
</li>
<li><p>带有虚函数的每个类的每一个对象，都会有一个指向虚表的指针，会增加对象的空间大小；</p>
</li>
<li><p>不能再是内联函数，因为内联函数在编译阶段进行替代，而虚函数需要动态等待<br>在运行阶段才能确定到底是采用哪种函数，虚函数不能是内联函数。</p>
</li>
</ol>
<hr>
<h2 id="30、说一说移动构造函数？"><a href="#30、说一说移动构造函数？" class="headerlink" title="30、说一说移动构造函数？"></a>30、说一说移动构造函数？</h2><ol>
<li><p>有时候我们会遇到这样一些情况，我们用对象a初始化对象b之后，对象a就不再使用了，但对象a的空间还在（在析构之前）<br>既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，为什么不能直接使用对象a的空间？</p>
<p>这样就避免了新的空间分配，大大降低了构造成本，这就是移动构造函数设计的初衷。</p>
</li>
<li><p>拷贝构造函数中，对于指针，我们一定要使用深拷贝；<br>移动构造函数中，对于指针，我们使用浅拷贝</p>
</li>
<li><p>C++引入了移动构造函数，专门处理这种，用对象a处理对象b之后就将a析构的情况。</p>
</li>
<li><p>与拷贝类似，移动也使用一个对象的值去设置另一个对象的值。<br>但是，与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：<br>  源对象将丢失其内容，其内容被目的对象占有。移动操作发生的时候，是当移动值的对象是未命名对象的时候。</p>
<p>  这里未命名的对象就是那些临时变量，甚至都不会有名称。</p>
<p>  典型的未命名对象就是函数的返回值或类型转换的对象。<br>  使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其他使用，因为，它的值可以被移动到目的对象。</p>
<p>  做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化时，调用移动构造函数。</p>
<p>  类似的，使用未命名的变量值赋值给一个对象时，调用移动赋值函数。</p>
</li>
<li><p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Example6</span> (Example6 &amp;&amp;x) : <span class="built_in">ptr</span>(x.ptr)&#123;</span><br><span class="line">  x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move assignment</span></span><br><span class="line">Example6&amp; <span class="keyword">operator</span>= (Example6&amp;&amp; x)&#123;</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">  ptr = x.ptr;</span><br><span class="line">  x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="31、什么情况下会合成构造函数？"><a href="#31、什么情况下会合成构造函数？" class="headerlink" title="31、什么情况下会合成构造函数？"></a>31、什么情况下会合成构造函数？</h2><ol>
<li><p>如果一个类没有任何构造函数，但他含有一个<code>成员对象</code>，该成员对象含有默认构造函数<br>那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用</p>
</li>
<li><p>没有任何构造函数的类<code>派生</code>自一个带有默认构造函数的基类<br>那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用。</p>
</li>
<li><p>带有<code>虚函数</code>的类，虚函数的引入需要进入虚表，指向虚表的指针<br>该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化。【vptr】</p>
</li>
<li><p>带有一个虚基类的类</p>
</li>
</ol>
<p>还有一点需要注意的是：</p>
<ol>
<li><p>并不是任何没有构造函数的类都会合成一个构造函数</p>
</li>
<li><p>编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</p>
</li>
</ol>
<hr>
<h2 id="32、什么时候需要合成拷贝构造函数？"><a href="#32、什么时候需要合成拷贝构造函数？" class="headerlink" title="32、什么时候需要合成拷贝构造函数？"></a>32、什么时候需要合成拷贝构造函数？</h2><p>三种情况会以一个对象的内容作为另一个对象的初值：</p>
<ol>
<li><p>对一个对象做显式的初始化操作 X xx &#x3D; x;</p>
</li>
<li><p>当对象被当做参数交给某个函数时;（传值）</p>
</li>
<li><p>当函数传回一个类对象时;</p>
</li>
</ol>
<p>注意：</p>
<ol>
<li><p>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数</p>
</li>
<li><p>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数</p>
</li>
<li><p>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数</p>
</li>
<li><p>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数</p>
</li>
</ol>
<hr>
<h2 id="33、构造函数的执行顺序？"><a href="#33、构造函数的执行顺序？" class="headerlink" title="33、构造函数的执行顺序？"></a>33、构造函数的执行顺序？</h2><ol>
<li><p>在派生类构造函数中，所有虚基类及上一层基类的构造函数调用</p>
</li>
<li><p>对象vptr被初始化</p>
</li>
<li><p>如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做</p>
</li>
<li><p>执行程序员所提供的代码</p>
</li>
</ol>
<hr>
<h2 id="34、一个类中全部构造函数的扩展过程是什么？"><a href="#34、一个类中全部构造函数的扩展过程是什么？" class="headerlink" title="34、一个类中全部构造函数的扩展过程是什么？"></a>34、一个类中全部构造函数的扩展过程是什么？</h2><ol>
<li><p>记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序</p>
</li>
<li><p>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用</p>
</li>
<li><p>如果class有虚表，那么它必须被设定初值</p>
</li>
<li><p>所有上一层基类的构造函数必须被调用</p>
</li>
<li><p>所有虚基类的构造函数必须被调用</p>
</li>
</ol>
<hr>
<h2 id="35、哪些函数不能是虚函数？"><a href="#35、哪些函数不能是虚函数？" class="headerlink" title="35、哪些函数不能是虚函数？"></a>35、哪些函数不能是虚函数？</h2><ol>
<li><p>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；<br>当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化</p>
</li>
<li><p>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定<br>编译阶段和运行阶段冲突，所以内联函数不能是虚函数。</p>
</li>
<li><p>静态函数，静态函数不属于对象而属于类整体<br>静态函数没有this指针，因此静态函数设置为虚函数没有任何意义</p>
</li>
<li><p>友元函数，友元函数不属于类的成员函数，不能被继承。<br>对于没有继承特性的函数没有虚函数的说法。</p>
</li>
<li><p>普通函数，普通函数不属于类的成员函数，不具有继承特性<br>因此普通函数没有虚函数</p>
</li>
</ol>
<hr>
<h2 id="36、什么是纯虚函数，与虚函数区别"><a href="#36、什么是纯虚函数，与虚函数区别" class="headerlink" title="36、什么是纯虚函数，与虚函数区别"></a>36、什么是纯虚函数，与虚函数区别</h2><ul>
<li>虚函数和纯虚函数区别？<ul>
<li><p>虚函数是为了实现动态联编产生的，目的是通过基类类型的<b>指针</b>指向不同对象时，自动调用相应的、和基类同名的函数<br>（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）</p>
<p>虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。【返回类型，参数等要相同】<br>当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数</p>
<p>在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同.</p>
</li>
<li><p>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化</p>
</li>
</ul>
</li>
</ul>
<p>纯虚函数首先是虚函数，其次没有函数体，取而代之的是用”&#x3D;0”。</p>
<p>既然是虚函数，它的指针就会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而须有函数体的虚函数则是函数的具体地址。</p>
<p>一个类中如果有纯虚函数的话，称其为抽象类。<br>抽象类不能用于实例化对象，否则会报错。</p>
<p>抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象【否则也是接口】</p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通虚函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子类实现的纯虚函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Base *b = <span class="keyword">new</span> Son;</span><br><span class="line">  b-&gt;<span class="built_in">fun1</span>();  <span class="comment">// 普通虚函数</span></span><br><span class="line">  b-&gt;<span class="built_in">fun2</span>();  <span class="comment">// 子类实现的纯虚函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/03/28/cppRest/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/03/28/cppRest/";
            const title         = "「cppRest」";
            const excerpt       = `Cpp 其余问题1、C++的多态性C++的多态性，一言以蔽之即：在基类的函数前加上virtual关键字，在派生类中重写该函数运行时将会根据所指对象的实际类型来调用相应的函数如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-03-30</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" cpp11" href="/2022/03/27/cpp11/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" Git" href="/2022/03/30/Git/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/Ru.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">人间归离复归离，借一浮生逃浮生</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Cpp-%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98"><span class="toc-text">Cpp 其余问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81C-%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">1、C++的多态性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E6%8C%87%E5%90%91%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%B1%BB%E6%8C%87%E9%92%88%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E6%83%85%E5%86%B5%E5%8A%A8%E6%80%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E6%80%A7%E3%80%82"><span class="toc-text">这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态进行调用，从而实现多态性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">2、为什么析构函数一般写成虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">3、构造函数能否声明为虚函数或者纯虚函数，析构函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88vptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4"><span class="toc-text">4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-text">5、模板函数和模板类的特例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">6、构造函数、析构函数、虚函数可否声明为内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81C-%E6%A8%A1%E6%9D%BF%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%81%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">7、C++模板是什么、底层如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%EF%BC%8C%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%8F%91%E7%94%9F%EF%BC%8CC-%E4%B8%AD%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BA%94%E9%87%87%E7%94%A8virtual%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-text">  所以，为了防止这种情况发生，C++中基类的析构函数应采用virtual虚析构函数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">9、析构函数的作用，如何起作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">10、构造函数和析构函数可以调用虚函数吗，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%86%85%E9%83%A8%E9%83%BD%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F"><span class="toc-text">11、构造函数、构造函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">12、虚析构函数的作用、父类的析构函数是否要设置为虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-text">13、构造函数析构函数可否抛出异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">14、构造函数一般不定义为虚函数的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%9E%90%E6%9E%84%EF%BC%9F"><span class="toc-text">15、类什么时候会析构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-text">16、构造函数或者析构函数中可以调用虚函数吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%94%B9%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%99%E5%8F%AF%E4%BB%A5%E5%A4%9A%E4%B8%80%E4%B8%AAA-Function"><span class="toc-text">如果析构函数改为虚函数，则可以多一个A::Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">17、构造函数的几种关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">18、构造函数、拷贝构造函数和赋值操作符的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">19、拷贝构造函数和赋值运算符重载的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E7%B1%BB%E4%B8%AD%E6%9C%89%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%97%B6%E8%A6%81%E9%87%8D%E5%86%99%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%82"><span class="toc-text">注意：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-text">20、什么是虚拟继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">21、什么情况会自动生成默认构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">22、抽象基类为什么不能创建对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">23、模板类和模板函数的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%BF%85%E9%A1%BB%E5%8A%A0%EF%BC%8C%E8%80%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8D%E5%BF%85%E5%8A%A0%E3%80%82"><span class="toc-text">在使用时类模板必须加，而函数模板不必加。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%8C%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%BC%80%E5%8F%91%E8%80%85%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">24、多继承的优点，作为一个开发者怎么看待多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">25、模板和实现可不可以不写在一个文件里？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9Dhello-world%E2%80%9D%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E6%89%93%E5%8D%B0%E5%88%B0%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">26、将字符串”hello world”从开始到打印到屏幕上的全过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC"><span class="toc-text">27、为什么拷贝构造函数必须传引用不能传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E8%83%BD%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E5%B8%B8%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-text">28、静态函数能定义为虚函数吗？常函数呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%9F"><span class="toc-text">29、虚函数的代价？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">30、说一说移动构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%90%88%E6%88%90%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">31、什么情况下会合成构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">32、什么时候需要合成拷贝构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">33、构造函数的执行顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%85%A8%E9%83%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">34、一个类中全部构造函数的扩展过程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">35、哪些函数不能是虚函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB"><span class="toc-text">36、什么是纯虚函数，与虚函数区别</span></a></li></ol></li></ol>
    </div>
</aside>
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.6em;">动态规划</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.8em;">数据库</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.6em;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.6em;">计算机网络</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/03/30/Git/"><i class="fa  fa-book"></i> Git</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/28/cppRest/"><i class="fa  fa-book"></i> cppRest</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/27/cpp11/"><i class="fa  fa-book"></i> cpp11</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/26/cppMemory/"><i class="fa  fa-book"></i> cppMemory</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/24/STL/"><i class="fa  fa-book"></i> STL</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/ReisenU"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@ReisenU"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/ReisenUx"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 月战老兵月球基地 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by ReisenU.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>




    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="7292006123"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>