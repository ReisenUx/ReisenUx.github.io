<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>计算机网络 | 月战老兵月球基地</title>
  <meta name="author" content="ReisenU" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="计算机网络" />
  
  <meta name="description" content="计算机网络1、OSI七层模型、功能 物理层：物理标准【比特】  数据链路层：定义数据的基本格式，如何传输，如何标识【帧】  网络层：IP、分组转发【包】  传输层：TCP、UDP，端到端传输【数据段】  会话层：控制应用程序之间会话  表示层：数据格式标识  应用层：各种应用软件    2、完整的HTTP请求： 域名解析；  TCP的3次握手  建立TCP后的http请求  服务器响应http请求">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2022/02/25/network/index.html">
<meta property="og:site_name" content="月战老兵月球基地">
<meta property="og:description" content="计算机网络1、OSI七层模型、功能 物理层：物理标准【比特】  数据链路层：定义数据的基本格式，如何传输，如何标识【帧】  网络层：IP、分组转发【包】  传输层：TCP、UDP，端到端传输【数据段】  会话层：控制应用程序之间会话  表示层：数据格式标识  应用层：各种应用软件    2、完整的HTTP请求： 域名解析；  TCP的3次握手  建立TCP后的http请求  服务器响应http请求">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2022-02-25T05:52:45.000Z">
<meta property="article:modified_time" content="2022-03-30T08:28:29.560Z">
<meta property="article:author" content="ReisenU">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li><a href="/"><i class="fa fa-link"></i>链接</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">月战老兵月球基地</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>月战老兵月球基地</h2> <br />
                        <span>Lunar Capital</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">计算机网络</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-02-25</li>
                <li><i class="fa fa-user"></i> 作者 ReisenU</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~32.86K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1648628909560"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E3%80%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">1、OSI七层模型、功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">2、完整的HTTP请求：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81DNS%E3%80%90%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E3%80%91"><span class="toc-number">1.3.</span> <span class="toc-text">3、DNS【域名系统】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E5%92%8CIP%E6%98%A0%E5%B0%84%EF%BC%8C%E4%B8%8D%E5%BF%85%E8%AE%B0%E4%BD%8F%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E7%9A%84IP%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%AE%B0%E5%8A%A9%E8%AE%B0%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">域名和IP映射，不必记住目标地址的IP，而是可以记助记符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81DNS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">4、DNS工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%94%A8UDP"><span class="toc-number">1.6.</span> <span class="toc-text">5、为什么域名解析用UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%8C%BA%E5%9F%9F%E4%BC%A0%E9%80%81%E4%BD%BF%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">6、区域传送使用TCP协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">7、HTTP长连接和短连接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8EHTTP-x2F-1-1%E8%B5%B7%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E7%94%A8%E4%BB%A5%E4%BF%9D%E6%8C%81%E8%BF%9E%E6%8E%A5%E7%89%B9%E6%80%A7%E3%80%82"><span class="toc-number">1.9.</span> <span class="toc-text">从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81TCP%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85%EF%BC%9F%E5%8F%91%E7%94%9F%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">8、TCP粘包&#x2F;拆包？发生原因？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">9、为什么服务器会缓存功能？如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">10、HTTP请求方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81GET%E5%92%8CPOST%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">1.13.</span> <span class="toc-text">11、GET和POST的请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%BA%94%E5%87%A0%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">12、一个TCP连接可以对应几个HTTP请求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E3%80%82"><span class="toc-number">1.15.</span> <span class="toc-text">如果长连接，一个TCP连接是可以对应多个HTTP请求的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%B8%ADHTTP%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%E5%90%97%EF%BC%88%E5%A6%82%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%E4%B8%89%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E4%B8%80%E8%B5%B7%E6%8E%A5%E5%8F%97%EF%BC%89%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">13、一个TCP连接中HTTP请求发送可以一起发送吗（如一起发送三个请求，在一起接受）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E5%90%8C%E4%B8%80-Host-%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%9A%84%E6%95%B0%E9%87%8F%E6%9C%89%E6%B2%A1%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">14、浏览器对同一 Host 建立TCP连接到的数量有没有限制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%9C%B0%E5%9D%80%E5%90%8E%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">15、在浏览器中输入URL地址后显示主页的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E8%83%8C%E5%90%8E%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.20.</span> <span class="toc-text">17、DNS解析过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81DNS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.21.</span> <span class="toc-text">18、DNS负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81HTTPS%E5%92%8CHTTP%E5%8C%BA%E5%88%AB"><span class="toc-number">1.22.</span> <span class="toc-text">19、HTTPS和HTTP区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSSL-x2F-TLS%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">20、什么是SSL&#x2F;TLS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E9%83%BD%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%A7%98%E9%92%A5%E7%9A%84%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9A%E4%BC%98%E7%82%B9%E5%9C%A8%E4%BA%8E%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E6%95%88%E7%8E%87%E9%80%9A%E5%B8%B8%E8%BE%83%E9%AB%98%EF%BC%8Chttps%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%EF%BC%8C%E5%85%AC%E9%92%A5%E5%85%AC%E5%BC%80%E3%80%82"><span class="toc-number">1.24.</span> <span class="toc-text">加密和解密都使用一个秘钥的对称加密：优点在于加密解密效率通常较高，https是基于非对称加密的，公钥公开。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81HTTPS%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%EF%BC%8C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F%EF%BC%88SSL%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-number">1.25.</span> <span class="toc-text">21、HTTPS如何保证数据传输安全，整体流程？（SSL如何工作保证安全）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%AC%E9%92%A5%E4%B8%8D%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">22、如何保证公钥不被篡改？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">1.27.</span> <span class="toc-text">23、HTTP请求和响应报文有哪些字段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81Cookie%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.28.</span> <span class="toc-text">24、Cookie是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81Cookie%E7%94%A8%E9%80%94%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">25、Cookie用途？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81Session%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">1.30.</span> <span class="toc-text">26、Session知识总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81Session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">27、Session 的工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%AF%8F%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%83%BD%E5%B8%A6%E7%9D%80Session-ID%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%BF%E5%88%B0Session-ID%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94Session%E5%8D%B3%E5%8F%AF"><span class="toc-number">1.32.</span> <span class="toc-text">客户端每次访问服务器时都带着Session ID，服务器拿到Session ID后，在内存中找到对应Session即可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81Cookie%E5%92%8CSession%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.33.</span> <span class="toc-text">28、Cookie和Session的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">29、SQL注入攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.35.</span> <span class="toc-text">30、网络的七层模型和各自功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%A5"><span class="toc-number">1.36.</span> <span class="toc-text">略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRARP%EF%BC%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.37.</span> <span class="toc-text">31、什么是RARP？工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E7%AB%AF%E5%8F%A3%E6%9C%89%E6%95%88%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">32、端口有效范围？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B0%86TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">33、为何要将TCP&#x2F;IP协议栈分层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81DNS%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">34、DNS查询方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81HTTP%E4%B8%AD%E7%BC%93%E5%AD%98%E7%9A%84%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E6%9C%89%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">1.41.</span> <span class="toc-text">35、HTTP中缓存的私有和公有字段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81GET%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%86%99%E6%B3%95%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.42.</span> <span class="toc-text">36、GET方法参数写法固定的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B3%EF%BC%9A%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E7%BA%A6%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%83%BD%E8%A7%A3%E9%87%8A%E5%87%BA%E6%9D%A5%E5%8D%B3%E5%8F%AF"><span class="toc-number">1.43.</span> <span class="toc-text">即：我们可以自己约定参数的写法，只要服务端能解释出来即可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81GET%E6%96%B9%E6%B3%95%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">1.44.</span> <span class="toc-text">37、GET方法的长度限制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E5%9B%A0%EF%BC%9A%E5%A4%84%E7%90%86%E9%95%BFURL%E8%A6%81%E6%B6%88%E8%80%97%E8%BE%83%E5%A4%9A%E8%B5%84%E6%BA%90%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%92%8C%E5%AE%89%E5%85%A8%EF%BC%88%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E6%9E%84%E9%80%A0%E9%95%BFURL%E6%9D%A5%E6%94%BB%E5%87%BB%EF%BC%89%E8%80%83%E8%99%91%EF%BC%8C%E4%BC%9A%E7%BB%99URL%E9%95%BF%E5%BA%A6%E5%8A%A0%E9%99%90%E5%88%B6%E3%80%82"><span class="toc-number">1.45.</span> <span class="toc-text">服务器原因：处理长URL要消耗较多资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81POST%E6%96%B9%E6%B3%95%E6%AF%94GET%E6%96%B9%E6%B3%95%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.46.</span> <span class="toc-text">38、POST方法比GET方法安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B3%E8%A6%81%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%8A%A0%E5%AF%86%EF%BC%8C%E5%8D%B3HTTPS"><span class="toc-number">1.47.</span> <span class="toc-text">想要安全传输，只有加密，即HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81POST%E6%96%B9%E6%B3%95%E4%BA%A7%E7%94%9F%E4%B8%A4%E4%B8%AATCP%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9F"><span class="toc-number">1.48.</span> <span class="toc-text">39、POST方法产生两个TCP数据包？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0%EF%BC%9Aheader%E5%92%8Cbody%E5%88%86%E5%BC%80%E5%8F%91%E9%80%81%E6%98%AF%E9%83%A8%E5%88%86%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%96%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%B1%9E%E4%BA%8Epost%E5%BF%85%E7%84%B6%E8%A1%8C%E4%B8%BA%E3%80%82"><span class="toc-number">1.49.</span> <span class="toc-text">综上所述：header和body分开发送是部分浏览器或框架的请求方法，不属于post必然行为。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81Session%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE26"><span class="toc-number">1.50.</span> <span class="toc-text">40、Session是什么？ —— 参见条目26</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%A5-1"><span class="toc-number">1.51.</span> <span class="toc-text">略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81%E4%BD%BF%E7%94%A8Session%E7%9A%84%E8%BF%87%E7%A8%8B-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE26-x2F-27"><span class="toc-number">1.52.</span> <span class="toc-text">41、使用Session的过程 —— 参见条目26&#x2F;27</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%A5-2"><span class="toc-number">1.53.</span> <span class="toc-text">略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81Session%E5%92%8CCookie%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%9F"><span class="toc-number">1.54.</span> <span class="toc-text">42、Session和Cookie应该如何选择（适用场景）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.55.</span> <span class="toc-text">43、Cookie和Session的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81DDos%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">1.56.</span> <span class="toc-text">44、DDos攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81MTU%E5%92%8CMSS%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.57.</span> <span class="toc-text">45、MTU和MSS分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81HTTP%E4%B8%AD%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E6%9C%80%E6%96%B0%EF%BC%9F"><span class="toc-number">1.58.</span> <span class="toc-text">46、HTTP中缓存机制，如何保证缓存最新？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81TCP%E5%A4%B4%E9%83%A8%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.59.</span> <span class="toc-text">47、TCP头部中有哪些信息？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.60.</span> <span class="toc-text">48、常见的TCP连接状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%83%E5%B1%82-x2F-%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.61.</span> <span class="toc-text">49、网络的七层&#x2F;五层协议有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81TCP%EF%BC%9F"><span class="toc-number">1.62.</span> <span class="toc-text">50、TCP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81TCP%E5%A4%B4%E9%83%A8%E6%8A%A5%E6%96%87%E5%AD%97%E6%AE%B5%EF%BC%9F%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.63.</span> <span class="toc-text">51、TCP头部报文字段？各自功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81OSI%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.64.</span> <span class="toc-text">52、OSI的七层模型主要功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.65.</span> <span class="toc-text">53、应用层常见协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E4%BA%86%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%90%8E%E6%98%AF%E5%90%A6%E4%BC%9A%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%E6%96%AD%E5%BC%80%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%96%AD%E5%BC%80%EF%BC%9F"><span class="toc-number">1.66.</span> <span class="toc-text">54、浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%BC%9A%E6%96%AD%E5%BC%80%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%9C%A8%E8%AF%B7%E6%B1%82%E6%8A%A5%E5%A4%B4%E5%A3%B0%E6%98%8EConnection-close%E6%89%8D%E4%BC%9A%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.67.</span> <span class="toc-text">默认情况下建立TCP连接不会断开，只有在请求报头声明Connection: close才会在请求完成后关闭连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-number">1.68.</span> <span class="toc-text">55、三次握手相关内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.69.</span> <span class="toc-text">56、为什么要三次握手，两次不行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">1.70.</span> <span class="toc-text">57、什么是半连接队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58%E3%80%81ISN%EF%BC%88Initial-Sequence-Number%EF%BC%89%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.71.</span> <span class="toc-text">58、ISN（Initial Sequence Number）是固定的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-number">1.72.</span> <span class="toc-text">59、三次握手过程可以携带数据吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60%E3%80%81SYN%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">1.73.</span> <span class="toc-text">60、SYN攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-number">1.74.</span> <span class="toc-text">61、四次挥手相关内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8socket-%E7%BC%96%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BB%BB%E4%BD%95%E4%B8%80%E6%96%B9%E6%89%A7%E8%A1%8Cclose-%E6%93%8D%E4%BD%9C%E5%8D%B3%E5%8F%AF%E4%BA%A7%E7%94%9F%E6%8C%A5%E6%89%8B%E5%8A%A8%E4%BD%9C%E3%80%82"><span class="toc-number">1.75.</span> <span class="toc-text">在socket()编程中，任何一方执行close()操作即可产生挥手动作。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E3%80%81%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">1.76.</span> <span class="toc-text">62、挥手为什么要四次？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9F%E5%8F%AF%E8%83%BD%E8%A6%81%E5%8F%91%E9%80%81%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%8F%91%E9%80%81%E5%AE%8C%E6%AF%95%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8D%E8%83%BD%E5%8F%91%E9%80%81FIN%E6%8A%A5%E6%96%87%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%83%BD%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%EF%BC%8C%E6%95%85%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E3%80%82"><span class="toc-number">1.77.</span> <span class="toc-text">但服务器也可能要发送自己的数据，只有当服务器数据也发送完毕，服务器才能发送FIN报文，因此不能一起发送，故四次挥手。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E3%80%812MSL%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.78.</span> <span class="toc-text">63、2MSL等待状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E7%AD%89%E5%BE%852MSL%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">1.79.</span> <span class="toc-text">64、四次挥手释放连接时，等待2MSL的意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E8%A6%81%E7%BB%8F%E8%BF%872MSL%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9ECLOSED%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.80.</span> <span class="toc-text">65、为什么TIME_WAIT状态要经过2MSL才能返回CLOSED状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66%E3%80%81TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.81.</span> <span class="toc-text">66、TCP粘包问题？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67%E3%80%81OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%A4%BA%E5%B1%82%E5%92%8C%E4%BC%9A%E8%AF%9D%E5%B1%82%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">1.82.</span> <span class="toc-text">67、OSI七层模型表示层和会话层功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E5%9B%9E%E6%94%B6%E5%8F%98%E8%BF%81%E5%9B%BE"><span class="toc-number">1.83.</span> <span class="toc-text">68、三次握手四次回收变迁图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69%E3%80%81%E5%AF%B9%E7%A7%B0%E7%A7%98%E9%92%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">1.84.</span> <span class="toc-text">69、对称秘钥加密的优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%A7%98%E9%92%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.85.</span> <span class="toc-text">70、非对称秘钥加密的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E3%80%81HTTPS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.86.</span> <span class="toc-text">71、HTTPS是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E3%80%81HTTP%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.87.</span> <span class="toc-text">72、HTTP缺点有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73%E3%80%81HTTPS%E9%87%87%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AF%B9%E7%A7%B0%E8%BF%98%E6%98%AF%E9%9D%9E%E5%AF%B9%E7%A7%B0%EF%BC%9F"><span class="toc-number">1.88.</span> <span class="toc-text">73、HTTPS采用的加密方式有哪些？对称还是非对称？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8BSSL%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.89.</span> <span class="toc-text">74、为什么有时候刷新页面不需要重新建立SSL连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75%E3%80%81SSL%E4%B8%AD%E7%9A%84%E8%AE%A4%E8%AF%81%E4%B8%AD%E7%9A%84%E8%AF%81%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.90.</span> <span class="toc-text">75、SSL中的认证中的证书是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76%E3%80%81HTTP%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.91.</span> <span class="toc-text">76、HTTP如何禁用缓存？如何确认缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77%E3%80%81GET%E5%92%8CPOST%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E8%83%BD%E8%BE%BE%E5%88%B0%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.92.</span> <span class="toc-text">77、GET和POST传递数据的最大长度能达到多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.93.</span> <span class="toc-text">78、网络层常见协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79%E3%80%81TCP%E5%9B%9B%E5%A4%A7%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.94.</span> <span class="toc-text">79、TCP四大拥塞控制算法总结？（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E6%94%B6%E5%88%B0%E6%96%B0%E7%9A%84ACK%E6%97%B6%EF%BC%8C%E5%8D%B3ACK11%EF%BC%8C%E5%88%99%E9%80%80%E5%87%BA%E5%BF%AB%E6%81%A2%E5%A4%8D%E9%98%B6%E6%AE%B5%EF%BC%8C%E5%B0%86cwnd%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BD%93%E5%89%8D%E7%9A%84ssthresh%EF%BC%8C%E5%8D%B33%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E5%85%A5%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%E9%98%B6%E6%AE%B5"><span class="toc-number">1.95.</span> <span class="toc-text">当收到新的ACK时，即ACK11，则退出快恢复阶段，将cwnd重新设置为当前的ssthresh，即3，然后进入拥塞避免算法阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80%E3%80%81%E4%B8%BA%E4%BD%95%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%98%AF%E9%80%89%E6%8B%A93%E6%AC%A1ACK%EF%BC%9F"><span class="toc-number">1.96.</span> <span class="toc-text">80、为何快速重传是选择3次ACK？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%8C%E5%A6%82%E6%9E%9C%E4%BE%9D%E7%84%B6%E6%8E%A5%E6%94%B6%E5%88%B0Duplicated-ACK%EF%BC%8C%E5%88%99%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%99%8D%E9%80%9F%E5%90%88%E7%90%86%E3%80%82"><span class="toc-number">1.97.</span> <span class="toc-text">而如果依然接收到Duplicated ACK，则认为是网络拥塞造成的，此时降速合理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E3%80%81%E5%AF%B9%E4%BA%8EFIN-WAIT-2%EF%BC%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E5%92%8CTIME-WAIT%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.98.</span> <span class="toc-text">81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.99.</span> <span class="toc-text">82、流量控制原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BTCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.100.</span> <span class="toc-text">建立TCP服务器的各个系统调用的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84%E3%80%81TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-number">1.101.</span> <span class="toc-text">84、TCP协议如何保证可靠传输？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85%E3%80%81UDP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.102.</span> <span class="toc-text">85、UDP是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86%E3%80%81%E5%B0%81%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F%E5%9F%BA%E4%BA%8ETCP%E8%BF%98%E6%98%AFUDP%EF%BC%9F"><span class="toc-number">1.103.</span> <span class="toc-text">86、封包和拆包？基于TCP还是UDP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86%E3%80%81TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.104.</span> <span class="toc-text">86、TCP和UDP的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87%E3%80%81UDP%E5%92%8CTCP%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.105.</span> <span class="toc-text">87、UDP和TCP的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88%E3%80%81TCP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.106.</span> <span class="toc-text">88、TCP对应的应用层协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89%E3%80%81UDP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.107.</span> <span class="toc-text">89、UDP对应的应用层协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.108.</span> <span class="toc-text">90、数据链路层常见协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E3%80%81Ping%E5%91%BD%E4%BB%A4%E5%9F%BA%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.109.</span> <span class="toc-text">91、Ping命令基于哪一层协议的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E5%91%BD%E4%BB%A4%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%98%AF%E5%9F%BA%E4%BA%8EICMP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E7%9A%84%E3%80%82"><span class="toc-number">1.110.</span> <span class="toc-text">ping命令基于网络层的命令，是基于ICMP协议工作的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92%E3%80%81%E5%9C%A8%E8%BF%9B%E8%A1%8CUDP%E7%BC%96%E7%A8%8B%E6%97%B6%EF%BC%8C%E4%B8%80%E6%AC%A1%E5%8F%91%E9%80%81%E5%A4%9A%E5%B0%91Bytes%E5%A5%BD%EF%BC%9F"><span class="toc-number">1.111.</span> <span class="toc-text">92、在进行UDP编程时，一次发送多少Bytes好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%89%B4%E4%BA%8EInternet%E4%B8%8A%E6%A0%87%E5%87%86%E7%9A%84MTU%E5%80%BC%E4%B8%BA576%E5%AD%97%E8%8A%82%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%BB%BA%E8%AE%AE%E5%9C%A8%E8%BF%9B%E8%A1%8CInternet%E7%9A%84UDP%E7%BC%96%E7%A8%8B%E6%97%B6%EF%BC%8C%E6%9C%80%E5%A5%BD%E5%B0%86UDP%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%9C%A8548%E5%AD%97%E8%8A%82%EF%BC%88576-8-20%EF%BC%89%E4%BB%A5%E5%86%85%E3%80%82"><span class="toc-number">1.112.</span> <span class="toc-text">鉴于Internet上标准的MTU值为576字节，因此建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节（576-8-20）以内。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93%E3%80%81TCP%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.113.</span> <span class="toc-text">93、TCP利用滑动窗口实现流量控制的机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BRTO-x2F-RTT-x2F-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%9F"><span class="toc-number">1.114.</span> <span class="toc-text">94、解释一下RTO&#x2F;RTT&#x2F;超时重传？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95%E3%80%81XSS%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">1.115.</span> <span class="toc-text">95、XSS攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2XSS%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E5%BF%85%E9%A1%BB%E5%AF%B9%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%81%9A%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">1.116.</span> <span class="toc-text">防XSS的核心是必须对输入的数据做过滤处理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96%E3%80%81CSRF%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">1.117.</span> <span class="toc-text">96、CSRF攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83CSRF%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">1.118.</span> <span class="toc-text">97、如何防范CSRF攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.119.</span> <span class="toc-text">98、文件上传漏洞是如何发生的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.120.</span> <span class="toc-text">99、如何防范文件上传漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.121.</span> <span class="toc-text">100、拥塞控制原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E3%80%81%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">1.122.</span> <span class="toc-text">101、如何区分流量控制和拥塞避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E3%80%81%E5%B8%B8%E8%A7%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-number">1.123.</span> <span class="toc-text">102、常见HTTP状态码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-number">1.124.</span> <span class="toc-text">103、服务器出现大量close_wait的连接的原因是什么？有什么解决办法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104%E3%80%81%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%8A%E9%99%90%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%B1%A1%E8%A6%81%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%B6%85%E8%BF%87%E8%BF%99%E4%B8%AA%E9%99%90%E5%88%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.125.</span> <span class="toc-text">104、一台机器能够使用的端口号上限是多少，是否可以修改？如果象要用的端口超过这个限制怎么办？</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、OSI七层模型、功能"><a href="#1、OSI七层模型、功能" class="headerlink" title="1、OSI七层模型、功能"></a>1、OSI七层模型、功能</h2><ul>
<li><p>物理层：物理标准【比特】</p>
</li>
<li><p>数据链路层：定义数据的基本格式，如何传输，如何标识【帧】</p>
</li>
<li><p>网络层：IP、分组转发【包】</p>
</li>
<li><p>传输层：TCP、UDP，端到端传输【数据段】</p>
</li>
<li><p>会话层：控制应用程序之间会话</p>
</li>
<li><p>表示层：数据格式标识</p>
</li>
<li><p>应用层：各种应用软件</p>
</li>
</ul>
<hr>
<h2 id="2、完整的HTTP请求："><a href="#2、完整的HTTP请求：" class="headerlink" title="2、完整的HTTP请求："></a>2、完整的HTTP请求：</h2><ol>
<li><p>域名解析；</p>
</li>
<li><p>TCP的3次握手</p>
</li>
<li><p>建立TCP后的http请求</p>
</li>
<li><p>服务器响应http请求，浏览器得到html代码</p>
</li>
<li><p>浏览器解析html代码，并请求html代码中的资源</p>
</li>
<li><p>浏览器进行渲染</p>
</li>
</ol>
<hr>
<h2 id="3、DNS【域名系统】"><a href="#3、DNS【域名系统】" class="headerlink" title="3、DNS【域名系统】"></a>3、DNS【域名系统】</h2><h2 id="域名和IP映射，不必记住目标地址的IP，而是可以记助记符"><a href="#域名和IP映射，不必记住目标地址的IP，而是可以记助记符" class="headerlink" title="域名和IP映射，不必记住目标地址的IP，而是可以记助记符"></a>域名和IP映射，不必记住目标地址的IP，而是可以记助记符</h2><h2 id="4、DNS工作原理"><a href="#4、DNS工作原理" class="headerlink" title="4、DNS工作原理"></a>4、DNS工作原理</h2><p>主机转换为IP地址，<code>应用层协议</code>，UDP传输</p>
<p>过程：</p>
<ol>
<li><p>当用户输入域名时，浏览器先检查自己的缓存是否有这个域名映射的IP地址，有则解析结束</p>
</li>
<li><p>若未命中，则检查操作系统缓存有无解析过的过程（hosts），有则解析结束</p>
</li>
<li><p>若未命中，则请求本地域名服务器解析（LDNS - local DNS）</p>
</li>
<li><p>若未命中，则跳到根域名服务器请求解析。根域名服务器返回给LDNS一个主域名服务器地址</p>
</li>
<li><p>LDNS发送请求给上一步返回的gTLD（通用顶级域），接受请求的gTLD查找并返回这个域名对应的Name Server地址</p>
</li>
<li><p>Name Server根据映射关系表找到目标ip，返回给LDNS</p>
</li>
<li><p>LDNS缓存这个域名和对应的IP，把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，过程结束</p>
</li>
</ol>
<blockquote>
<p>总结：浏览器缓存、系统缓存、路由器缓存、ISP服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存<br>主机向本地域名服务器的查询一般都是<code>递归查询</code><br>本地域名服务器向根域名服务器的查询一般<code>迭代查询</code></p>
</blockquote>
<hr>
<h2 id="5、为什么域名解析用UDP"><a href="#5、为什么域名解析用UDP" class="headerlink" title="5、为什么域名解析用UDP"></a>5、为什么域名解析用UDP</h2><p>因为若基于TCP的话，需要三次握手，发送数据以及应答，四次挥手。<br>UDP相比而言快很多，一个请求、应答即可，同时UDP传输内容不超过512字节，一般DNS请求内容也不会太大。</p>
<hr>
<h2 id="6、区域传送使用TCP协议？"><a href="#6、区域传送使用TCP协议？" class="headerlink" title="6、区域传送使用TCP协议？"></a>6、区域传送使用TCP协议？</h2><p>TCP协议可靠性好，能够保证数据按序到达和无差错（包括下面几层的功劳）<br>同时TCP能够传输大于512字节的内容，不同于UDP</p>
<hr>
<h2 id="7、HTTP长连接和短连接的区别"><a href="#7、HTTP长连接和短连接的区别" class="headerlink" title="7、HTTP长连接和短连接的区别"></a>7、HTTP长连接和短连接的区别</h2><p>在HTTP&#x2F;1.0中默认使用短连接。即客户端和服务器每进行一次HTTP操作，就建立一次连接，<code>任务结束就中断连接</code>。</p>
<h2 id="从HTTP-x2F-1-1起，默认使用长连接，用以保持连接特性。"><a href="#从HTTP-x2F-1-1起，默认使用长连接，用以保持连接特性。" class="headerlink" title="从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。"></a>从HTTP&#x2F;1.1起，默认使用长连接，用以<code>保持连接</code>特性。</h2><h2 id="8、TCP粘包-x2F-拆包？发生原因？"><a href="#8、TCP粘包-x2F-拆包？发生原因？" class="headerlink" title="8、TCP粘包&#x2F;拆包？发生原因？"></a>8、TCP粘包&#x2F;拆包？发生原因？</h2><p>一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据报发送，这个就是TCP的拆包和粘包问题。<br>【应用层从TCP缓冲区读取数据无法确定发生方的发送边界】</p>
<p>原因：</p>
<ol>
<li><p>应用程序写入数据的字节大小大于套接字发送缓存区的大小</p>
</li>
<li><p>进行MSS大小的TCP分段。（MSS &#x3D; TCP报文段长度 - TCP首部长度）</p>
</li>
<li><p>以太网的payload大于MTU进行IP分片（MTU：最大传输单元）</p>
</li>
</ol>
<p>解决方案：【解决分界问题】</p>
<ol>
<li><p>消息定长</p>
</li>
<li><p>在包尾部增加回车或者空格等特殊字符进行分割</p>
</li>
<li><p>将消息分为消息头和消息尾</p>
</li>
<li><p>使用其他复杂的协议，如RTMP协议。</p>
</li>
</ol>
<hr>
<h2 id="9、为什么服务器会缓存功能？如何实现？"><a href="#9、为什么服务器会缓存功能？如何实现？" class="headerlink" title="9、为什么服务器会缓存功能？如何实现？"></a>9、为什么服务器会缓存功能？如何实现？</h2><p>原因：</p>
<ol>
<li>缓解服务器压力</li>
<li>降低客户端获得资源的延迟：缓存通常位于内存中，读取缓存的速度更快。<br>  缓存服务器在地理位置可能比原服务器更近，例如Browser Cache</li>
</ol>
<p>实现方法：</p>
<ol>
<li>让代理服务器进行缓存</li>
<li>让客户端浏览器进行缓存</li>
</ol>
<hr>
<h2 id="10、HTTP请求方法？"><a href="#10、HTTP请求方法？" class="headerlink" title="10、HTTP请求方法？"></a>10、HTTP请求方法？</h2><p>客户端发送的<code>请求报文</code>第一行为请求行，包含了方法字段</p>
<p>根据HTTP标准，HTTP请求可以使用多种方法</p>
<p>HTTP1.0 定义了三种请求方法：GET，POST和HEAD方法。<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUTS、PATCH、DELETE、TRACE和CONNECT方法。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">类似于GET请求，不过返回的响应中没有具体内容，用于获取报头</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据被包含在请求体中，POST请求可能会导致新资源建立&#x2F;已有资源修改</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的页面</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">HTTP&#x2F;1.1协议中预留给能将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器性能</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">PATCH</td>
<td align="left">是对PUT方法的补充，用来对已知资源进行局部更新</td>
</tr>
</tbody></table>
<hr>
<h2 id="11、GET和POST的请求"><a href="#11、GET和POST的请求" class="headerlink" title="11、GET和POST的请求"></a>11、GET和POST的请求</h2><ol>
<li><p>get是获取数据<br>post是修改数据</p>
</li>
<li><p>get把请求的数据放在url上，以<code>?</code>分割URL和传输，参数之间以&amp;相连，因此get不安全。<br>post把数据放在HTTP的包体内（request body）</p>
</li>
<li><p>get提交的数据最大是2k（限制实际上取决于浏览器）<br>post理论上无限制</p>
</li>
<li><p>get产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）<br>post产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应 200 ok（返回数据）</p>
</li>
<li><p>get请求会被浏览器主动缓存<br>post不会，除非手动设置</p>
</li>
<li><p>get是幂等的<br>post不是幂等的（本质区别）</p>
</li>
</ol>
<blockquote>
<p>幂等性：一次和多次请求某一个资源应该具有同样的副作用，简单说意味着同一URL的多个请求返回同样结果。</p>
</blockquote>
<p>因为上述区别：<br>不应该也<b>不能用get请求做数据的增删改这些有副作用的操作</b>。<br>由于get请求是幂等的，<b>在网络不好的隧道中会尝试重试</b>。<br>如果用get请求增数据，会有<code>重复操作</code>的风险，这种重复操作可能会导致副作用。<br>（浏览器和操作系统不知道你用get请求增操作）</p>
<hr>
<h2 id="12、一个TCP连接可以对应几个HTTP请求？"><a href="#12、一个TCP连接可以对应几个HTTP请求？" class="headerlink" title="12、一个TCP连接可以对应几个HTTP请求？"></a>12、一个TCP连接可以对应几个HTTP请求？</h2><h2 id="如果长连接，一个TCP连接是可以对应多个HTTP请求的。"><a href="#如果长连接，一个TCP连接是可以对应多个HTTP请求的。" class="headerlink" title="如果长连接，一个TCP连接是可以对应多个HTTP请求的。"></a>如果长连接，一个TCP连接是可以对应多个HTTP请求的。</h2><h2 id="13、一个TCP连接中HTTP请求发送可以一起发送吗（如一起发送三个请求，在一起接受）？"><a href="#13、一个TCP连接中HTTP请求发送可以一起发送吗（如一起发送三个请求，在一起接受）？" class="headerlink" title="13、一个TCP连接中HTTP请求发送可以一起发送吗（如一起发送三个请求，在一起接受）？"></a>13、一个TCP连接中HTTP请求发送可以一起发送吗（如一起发送三个请求，在一起接受）？</h2><p>HTTP&#x2F;1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求<br>即：两个请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠</p>
<p>在HTTP&#x2F;1.1存在Pipelining技术可以完成多个请求同时发送，但浏览器默认关闭，所以认为不可行。<br>HTTP2中由于Multiplexing特点的存在，多个HTTP请求可以在同一个TCP连接中并行进行。</p>
<blockquote>
<p>HTTP&#x2F;1.1中默认不行，实际可以开启<br>HTTP&#x2F;2中可以</p>
</blockquote>
<p>则在HTTP&#x2F;1.1时代，如何提高页面加载效率？</p>
<ol>
<li><p>维持和服务器已经建立的TCP连接，在同一连接上顺序处理多个请求。</p>
</li>
<li><p>和服务器建立多个TCP连接</p>
</li>
</ol>
<hr>
<h2 id="14、浏览器对同一-Host-建立TCP连接到的数量有没有限制？"><a href="#14、浏览器对同一-Host-建立TCP连接到的数量有没有限制？" class="headerlink" title="14、浏览器对同一 Host 建立TCP连接到的数量有没有限制？"></a>14、浏览器对同一 Host 建立TCP连接到的数量有没有限制？</h2><p>假设HTTP&#x2F;1.1时代，没有多路传输，若接受到一个有几十张图片的网页如何处理？</p>
<p>只开一个TCP很慢，每个图片一个TCP电脑和服务器都接受不了。</p>
<p>限制：有<br>Chrome 最多允许对同一个Host建立六个TCP连接，不同的浏览器有一些区别。</p>
<p>如果图片都是<b>HTTPS连接并且在同一个域名下</b>，那么浏览器在SSL握手之后会和服务器商量能否使用HTTP2<br>若能，则用Multiplexing功能进行多路传输。<br>不过也未必会所有挂在这个域名的资源都会使用一个TCP去获取，但可以确定的是Multiplexing很可能会被用到。</p>
<p>如果用不了HTTP2或者HTTPS（HTTP2在HTTPS基础上实现）</p>
<p>则浏览器会在一个HOST上建立多个TCP连接，连接数量的最大限制取决于浏览器设置。<br>这些连接会在空闲时被浏览器用来发送新的请求，若所有连接都在发送请求，则其他只能等待。</p>
<hr>
<h2 id="15、在浏览器中输入URL地址后显示主页的过程？"><a href="#15、在浏览器中输入URL地址后显示主页的过程？" class="headerlink" title="15、在浏览器中输入URL地址后显示主页的过程？"></a>15、在浏览器中输入URL地址后显示主页的过程？</h2><ul>
<li><p>根据域名，进行DNS解析。</p>
</li>
<li><p>拿到解析的IP地址，建立TCP连接。</p>
</li>
<li><p>向IP地址发送HTTP请求</p>
</li>
<li><p>服务器处理</p>
</li>
<li><p>返回结果</p>
</li>
<li><p>关闭TCP连接</p>
</li>
<li><p>浏览器解析HTML</p>
</li>
<li><p>浏览器渲染</p>
</li>
</ul>
<hr>
<h2 id="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"><a href="#16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？" class="headerlink" title="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"></a>16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</h2><ol>
<li><p>浏览器缓存</p>
</li>
<li><p>本机host</p>
</li>
<li><p>调用API，Linux下Socket函数 gethostbyname</p>
</li>
<li><p>向DNS服务器发送DNS请求，UPD协议</p>
</li>
<li><p>若在子网内，则用ARP地址解析协议进行查询，若不在一个子网内，则要对默认网关进行DNS查询，而且要一直向上找DNS服务器</p>
</li>
<li><p>若此时有服务器IP地址即默认端口号，http（80）、https（443）,则先尝试http然后调用Socket建立TCP连接</p>
</li>
<li><p>三次握手成功建立连接后，开始传送数据，若是http协议，则返回</p>
</li>
<li><p>若不是http协议，服务器会返回一个5开头的重定向消息，但是https，IP不变端口号不同 —— 传输完毕后四次挥手</p>
</li>
<li><p>除了80-&gt;443，还会采用SSL加密技术保证传输数据安全性，保证数据传输过程不被修改或替换</p>
</li>
<li><p>三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验CA安全证书</p>
</li>
<li><p>确认无误后开始通信，服务器返回要访问网址的一些数据，再次过程中会将界面进行渲染，牵涉到ajax技术等。</p>
</li>
</ol>
<hr>
<h2 id="17、DNS解析过程"><a href="#17、DNS解析过程" class="headerlink" title="17、DNS解析过程"></a>17、DNS解析过程</h2><ol>
<li><p>若是chrome浏览器，先找有无<b>缓存过的域名对应IP地址</b><br>若有，则跳过DNS解析<br>若没有，则找硬盘的hosts文件【Hosts文件也是域名对应一个IP】</p>
</li>
<li><p>若hosts文件没能获得对应ip地址，则会发送一个<b>dns请求到本地dns服务器，本地dns服务器一般都是ISP提供</b>。</p>
</li>
<li><p>主机向本地DNS服务器发送DNS请求，使用的是<b>递归方式</b>，本地DNS也会查询自己的缓存。</p>
</li>
<li><p>本地DNS服务器会向域服务器发送请求【迭代】</p>
</li>
<li><p>本地DNS向域名解析服务器发送请求，从而获得DNS-&gt;IP</p>
</li>
</ol>
<hr>
<h2 id="18、DNS负载均衡"><a href="#18、DNS负载均衡" class="headerlink" title="18、DNS负载均衡"></a>18、DNS负载均衡</h2><p>用户足够多，每次请求都在同一台机器上，则机器随时可能宕机</p>
<p>负载均衡：在DNS服务器中为同一个主机名配置多个IP地址，<br>在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同解析结果<br>将客户端的访问引导到不同机器上去，使得不同客户端访问不同服务器，从而负载均衡。</p>
<blockquote>
<p>负载率、地理位置作为考量指标</p>
</blockquote>
<hr>
<h2 id="19、HTTPS和HTTP区别"><a href="#19、HTTPS和HTTP区别" class="headerlink" title="19、HTTPS和HTTP区别"></a>19、HTTPS和HTTP区别</h2><ol>
<li><p>http协议传输的数据都是未加密的，明文的，因此http协议传输隐私信息非常不安全<br>https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p>
</li>
<li><p>https协议要用到ca申请证书，免费证书较少，一般要费用</p>
</li>
<li><p>http(80)和https(443)使用完全不同连接方式，端口也不同</p>
</li>
</ol>
<hr>
<h2 id="20、什么是SSL-x2F-TLS？"><a href="#20、什么是SSL-x2F-TLS？" class="headerlink" title="20、什么是SSL&#x2F;TLS？"></a>20、什么是SSL&#x2F;TLS？</h2><p>SSL：安全套接字层，用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。<br>     加密https的加密机制是一种共享秘钥加密和公开密钥加密并用的混合加密机制。<br>TLS：安全传输层协议</p>
<p>SSL&#x2F;TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议和解密需要两个不同的秘钥，因此称为非对称加密</p>
<h2 id="加密和解密都使用一个秘钥的对称加密：优点在于加密解密效率通常较高，https是基于非对称加密的，公钥公开。"><a href="#加密和解密都使用一个秘钥的对称加密：优点在于加密解密效率通常较高，https是基于非对称加密的，公钥公开。" class="headerlink" title="加密和解密都使用一个秘钥的对称加密：优点在于加密解密效率通常较高，https是基于非对称加密的，公钥公开。"></a>加密和解密都使用一个秘钥的对称加密：优点在于加密解密效率通常较高，https是基于非对称加密的，公钥公开。</h2><h2 id="21、HTTPS如何保证数据传输安全，整体流程？（SSL如何工作保证安全）"><a href="#21、HTTPS如何保证数据传输安全，整体流程？（SSL如何工作保证安全）" class="headerlink" title="21、HTTPS如何保证数据传输安全，整体流程？（SSL如何工作保证安全）"></a>21、HTTPS如何保证数据传输安全，整体流程？（SSL如何工作保证安全）</h2><ol>
<li><p>客户端向服务器端发起SSL连接请求</p>
</li>
<li><p>服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥</p>
</li>
<li><p>客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端</p>
</li>
<li><p>服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密</p>
</li>
<li><p>进行数据传输，服务器和客户端双方用共有的相同的对称秘钥对数据进行加密解密，可以保证数据在收发过程中的安全，即使第三方获得数据包也无法加密解密篡改等。</p>
</li>
</ol>
<p>由于数字签名、摘要是证书方位非常关键的武器。<br>“摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。<br>然后通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”</p>
<p>SSL&#x2F;TLS协议的基本思路是采用公钥加密法，即客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<blockquote>
<p>补充：SSL&#x2F;TLS四次握手，现在TLS 1.2已经成为主流，使用ECDHE算法。</p>
</blockquote>
<hr>
<h2 id="22、如何保证公钥不被篡改？"><a href="#22、如何保证公钥不被篡改？" class="headerlink" title="22、如何保证公钥不被篡改？"></a>22、如何保证公钥不被篡改？</h2><p>将公钥放在数字证书中。只要证书可信，公钥就是可信的。</p>
<p>公钥加密计算量太大，如何减少耗用时间？<br>每一次对话（session），客户端和服务器端都生成一个“对话秘钥”（Session key），用它加密信息。</p>
<p>由于“对话秘钥”是对称加密，所以运算速度非常快，服务器公钥只用于加密“对话秘钥”本身，即减少了加密运算的消耗时间。</p>
<ol>
<li><p>客户端向服务器端索要并验证公钥</p>
</li>
<li><p>双方协商生成“对话秘钥”【以上两步，即“握手阶段”（handshake）】</p>
</li>
<li><p>双方采用“对话秘钥”进行加密通信</p>
</li>
</ol>
<hr>
<h2 id="23、HTTP请求和响应报文有哪些字段？"><a href="#23、HTTP请求和响应报文有哪些字段？" class="headerlink" title="23、HTTP请求和响应报文有哪些字段？"></a>23、HTTP请求和响应报文有哪些字段？</h2><ul>
<li><p>请求报文：</p>
<ul>
<li>请求行 ： Request Line</li>
<li>请求头 ： Request Headers</li>
<li>请求体 ： Request Body</li>
</ul>
</li>
<li><p>响应报文：</p>
<ul>
<li>状态行 ： Status Line</li>
<li>响应头 ： Response Headers</li>
<li>响应体 ： Response Body</li>
</ul>
</li>
</ul>
<hr>
<h2 id="24、Cookie是什么"><a href="#24、Cookie是什么" class="headerlink" title="24、Cookie是什么"></a>24、Cookie是什么</h2><p>HTTP协议是<b>无状态</b>的，主要是为了让HTTPS协议尽可能简单，时期能处理大量事物<br>HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是<b>服务器发送到用户浏览器并保存在本地的一小块数据</b>，它会在浏览器之后向同一服务器再次发送请求时被携带上，用于告知服务端两个请求是否来自统一浏览器。<br>由于之后每次请求都会需要携带Cookie数据，因此会带来额外性能开销（特别移动环境下）</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其他合适的存储办法而作为唯一的存储手段，但技术更新的背景下，Cookie逐渐被淘汰。</p>
<p>新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或IndexedDB</p>
<p>由于HTTP无状态，服务器不知道你之前的信息，让你再次发送请求时，服务器能通过Cookie认识你</p>
<blockquote>
<p>Cookie 可认为是一种【变量】，形如name &#x3D; value，存储在浏览器<br>Session 可认为是一种【数据结构-映射】（键值对），存储在服务器</p>
</blockquote>
<hr>
<h2 id="25、Cookie用途？"><a href="#25、Cookie用途？" class="headerlink" title="25、Cookie用途？"></a>25、Cookie用途？</h2><ul>
<li><p>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</p>
</li>
<li><p>个性化设置（如用户自定义设置、主题等）</p>
</li>
<li><p>浏览器行为跟踪（如跟踪分析用户行为等）</p>
</li>
</ul>
<hr>
<h2 id="26、Session知识总结"><a href="#26、Session知识总结" class="headerlink" title="26、Session知识总结"></a>26、Session知识总结</h2><blockquote>
<p>Cookie 可以将用户信息存储在用户浏览器中<br>Session 可以将用户信息存储在客户端（更加安全）</p>
</blockquote>
<p>Session可以存储在服务器上的文件、数据库或内存中。<br>可以将Session存储在Redis这种内存性数据库中，效率更高。</p>
<p>使用Session维护用户登录状态过程如下：</p>
<ol>
<li><p>用户进行登录时，用户提交包含用户名和密码的表单，放入HTTP请求报文中；</p>
</li>
<li><p>服务器验证该用户名和密码，如果正确则把用户信息存储到Redis中，它在Redis中的Key称为Session ID；</p>
</li>
<li><p>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个Session ID，客户端收到响应报文后将该Cookie存入浏览器中。</p>
</li>
<li><p>客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到之后提取出Session ID，从Redis中取出用户信息，继续之前的业务操作。</p>
</li>
</ol>
<blockquote>
<p>注意，Session ID的安全性问题，有时候要重新生成，或者重新验证等。</p>
</blockquote>
<hr>
<h2 id="27、Session-的工作原理？"><a href="#27、Session-的工作原理？" class="headerlink" title="27、Session 的工作原理？"></a>27、Session 的工作原理？</h2><p>客户端登录完成后，服务器创建对应的session，session创建完后，会把Session ID发送给客户端，客户端再存储到浏览器中</p>
<h2 id="客户端每次访问服务器时都带着Session-ID，服务器拿到Session-ID后，在内存中找到对应Session即可"><a href="#客户端每次访问服务器时都带着Session-ID，服务器拿到Session-ID后，在内存中找到对应Session即可" class="headerlink" title="客户端每次访问服务器时都带着Session ID，服务器拿到Session ID后，在内存中找到对应Session即可"></a>客户端每次访问服务器时都带着Session ID，服务器拿到Session ID后，在内存中找到对应Session即可</h2><h2 id="28、Cookie和Session的对比"><a href="#28、Cookie和Session的对比" class="headerlink" title="28、Cookie和Session的对比"></a>28、Cookie和Session的对比</h2><p>HTTP作为无状态协议，必然需要存在某种方式保持连接状态。简要介绍Cookie和Session</p>
<ul>
<li><p>Cookie：<br>Cookie是<b>客户端<b>保持状态的方法</p>
<p>Cookie简单的理解即：存储由服务器发往客户端并由客户端保存的一段字符串。<br>为了保持会话，服务器可以在相应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到之后保存这个字符串，下次请求带上Cookie就可以被识别</p>
<p>除此之外，Cookie在客户端的保存形式可以有：</p>
<ol>
<li>会话Cookie：将服务器返回的Cookie字符串保存在内存中，关闭浏览器之后自动销毁</li>
<li>持久Cookie：存储在客户端磁盘上，有效时间在服务器响应头中被指定，有效期内，客户端再次请求服务器时直接从本地取出。<br>        存储在磁盘中的Cookie是可以被多个浏览器代理共享的。</li>
</ol>
</li>
<li><p>Session<br>Session是<b>服务器</b>保持状态的方法</p>
<p>Session保存在服务器上，可以在数据库、文件或内存中<br>每个用户有独立的Session用户，其在客户端上记录用户的操作。</p>
<p>理解为：每个用户有独一无二个Session ID作为Session文件的Hash键，通过该值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为</p>
</li>
</ul>
<p>当服务器需要识别客户端时，需要结合Cookie。<br>每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。<br>实际上大多数应用都是可以用Cookie来实现Session跟踪的</p>
<p>第一次创建Session时，服务端会在HTTP协议中高速客户端，需要Set-Cookie记录一个Session ID<br>      然后每次请求会把这个Session ID发送到服务器，服务器就能识别客户</p>
<p>如果客户端浏览器禁用了Cookie，会使用一种叫做URL重写的技术进行会话跟踪<br>    即每次HTTP交互，URL后面都会被附加上一个例如：Sid &#x3D; xxxx 的参数，服务器以此来识别用户，可以帮用户完成注入用户信息自动填入等操作。</p>
<hr>
<h2 id="29、SQL注入攻击？"><a href="#29、SQL注入攻击？" class="headerlink" title="29、SQL注入攻击？"></a>29、SQL注入攻击？</h2><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行</p>
<p>防范SQL注入攻击 —— 使用预编译的PrepareStatement<br>Web端：</p>
<ol>
<li>有效性检验</li>
<li>限制字符串输入长度</li>
</ol>
<p>服务端：</p>
<ol>
<li><p>不用拼接SQL字符串</p>
</li>
<li><p>使用预编译的PrepareStatement</p>
</li>
<li><p>有效性检验（服务端有效性检验：第一准则，外部都是不可信的，防止攻击者绕过Web端请求）</p>
</li>
<li><p>过滤SQL需要的参数中的特殊字符，比如单引号、双引号</p>
</li>
</ol>
<hr>
<h2 id="30、网络的七层模型和各自功能"><a href="#30、网络的七层模型和各自功能" class="headerlink" title="30、网络的七层模型和各自功能"></a>30、网络的七层模型和各自功能</h2><h2 id="略"><a href="#略" class="headerlink" title="略"></a>略</h2><h2 id="31、什么是RARP？工作原理"><a href="#31、什么是RARP？工作原理" class="headerlink" title="31、什么是RARP？工作原理"></a>31、什么是RARP？工作原理</h2><p>概括：反向地址转换协议，网络层协议<br>ARP：从IP地址返回物理地址<br>RARP：从物理地址返回IP地址 —— 应答包括能提供所需信息的RARP服务器发出的IP地址。</p>
<p>原理：</p>
<ol>
<li><p>网络上的每台设备都有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。<br>主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址</p>
</li>
<li><p>RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机</p>
</li>
<li><p>PC1收到RARP回应后，就使用得到的IP地址进行通讯。</p>
</li>
</ol>
<hr>
<h2 id="32、端口有效范围？"><a href="#32、端口有效范围？" class="headerlink" title="32、端口有效范围？"></a>32、端口有效范围？</h2><p>0-1023是知名端口号，其中HTTP是80，FTP是20（数据端口）、21（控制端口）</p>
<p>UDP和TCP报头使用两个字节存放端口号，所以端口号有效范围是0-65536.<br>动态端口的范围是1024-65535</p>
<hr>
<h2 id="33、为何要将TCP-x2F-IP协议栈分层？"><a href="#33、为何要将TCP-x2F-IP协议栈分层？" class="headerlink" title="33、为何要将TCP&#x2F;IP协议栈分层？"></a>33、为何要将TCP&#x2F;IP协议栈分层？</h2><p>ARPANET的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次性的。<br>分层好处：</p>
<ol>
<li><p>各层之间独立</p>
</li>
<li><p>灵活性好</p>
</li>
<li><p>结构上可以分开</p>
</li>
<li><p>易于实现和维护</p>
</li>
<li><p>能促进标准化工作</p>
</li>
</ol>
<hr>
<h2 id="34、DNS查询方式？"><a href="#34、DNS查询方式？" class="headerlink" title="34、DNS查询方式？"></a>34、DNS查询方式？</h2><ul>
<li><p>递归查询</p>
</li>
<li><p>迭代查询</p>
</li>
</ul>
<hr>
<h2 id="35、HTTP中缓存的私有和公有字段？"><a href="#35、HTTP中缓存的私有和公有字段？" class="headerlink" title="35、HTTP中缓存的私有和公有字段？"></a>35、HTTP中缓存的私有和公有字段？</h2><p>private指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control : private</span><br></pre></td></tr></table></figure>

<p>public指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control : public</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="36、GET方法参数写法固定的吗？"><a href="#36、GET方法参数写法固定的吗？" class="headerlink" title="36、GET方法参数写法固定的吗？"></a>36、GET方法参数写法固定的吗？</h2><p>在约定中，参数写在?后面，用&amp;分割。</p>
<p>解析报文的过程是通过获取TCP数据，用正则等工具从数据中获取Header和Body，从而提取参数。</p>
<p>比如header请求头添加token，来验证用户是否登录等权限问题</p>
<h2 id="即：我们可以自己约定参数的写法，只要服务端能解释出来即可"><a href="#即：我们可以自己约定参数的写法，只要服务端能解释出来即可" class="headerlink" title="即：我们可以自己约定参数的写法，只要服务端能解释出来即可"></a>即：我们可以自己约定参数的写法，只要服务端能解释出来即可</h2><h2 id="37、GET方法的长度限制？"><a href="#37、GET方法的长度限制？" class="headerlink" title="37、GET方法的长度限制？"></a>37、GET方法的长度限制？</h2><p>网络上都会提到浏览器地址栏输入的参数是有限的。</p>
<p>虽然HTTP协议没有Body和URL的长度限制，对URL限制的大多是浏览器和服务器；</p>
<p>浏览器原因：</p>
<h2 id="服务器原因：处理长URL要消耗较多资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。"><a href="#服务器原因：处理长URL要消耗较多资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。" class="headerlink" title="服务器原因：处理长URL要消耗较多资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。"></a>服务器原因：处理长URL要消耗较多资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。</h2><h2 id="38、POST方法比GET方法安全？"><a href="#38、POST方法比GET方法安全？" class="headerlink" title="38、POST方法比GET方法安全？"></a>38、POST方法比GET方法安全？</h2><p>从传输角度而言，都不安全。<br>因为HTTP在网络上都使明文传输的，只要在网络节点上抓包就可以截获报文。</p>
<h2 id="想要安全传输，只有加密，即HTTPS"><a href="#想要安全传输，只有加密，即HTTPS" class="headerlink" title="想要安全传输，只有加密，即HTTPS"></a>想要安全传输，只有加密，即HTTPS</h2><h2 id="39、POST方法产生两个TCP数据包？"><a href="#39、POST方法产生两个TCP数据包？" class="headerlink" title="39、POST方法产生两个TCP数据包？"></a>39、POST方法产生两个TCP数据包？</h2><p>POST会将Header和Body分开发送，先发送header，服务端返回<code>100状态码</code>再发送body。</p>
<p>HTTP协议中没有明确说明POST会产生两个TCP数据包<br>经过实际测试（Chrome）发现，header和body不会分开发送</p>
<h2 id="综上所述：header和body分开发送是部分浏览器或框架的请求方法，不属于post必然行为。"><a href="#综上所述：header和body分开发送是部分浏览器或框架的请求方法，不属于post必然行为。" class="headerlink" title="综上所述：header和body分开发送是部分浏览器或框架的请求方法，不属于post必然行为。"></a>综上所述：header和body分开发送是部分浏览器或框架的请求方法，不属于post必然行为。</h2><h2 id="40、Session是什么？-——-参见条目26"><a href="#40、Session是什么？-——-参见条目26" class="headerlink" title="40、Session是什么？ —— 参见条目26"></a>40、Session是什么？ —— 参见条目26</h2><h2 id="略-1"><a href="#略-1" class="headerlink" title="略"></a>略</h2><h2 id="41、使用Session的过程-——-参见条目26-x2F-27"><a href="#41、使用Session的过程-——-参见条目26-x2F-27" class="headerlink" title="41、使用Session的过程 —— 参见条目26&#x2F;27"></a>41、使用Session的过程 —— 参见条目26&#x2F;27</h2><h2 id="略-2"><a href="#略-2" class="headerlink" title="略"></a>略</h2><h2 id="42、Session和Cookie应该如何选择（适用场景）？"><a href="#42、Session和Cookie应该如何选择（适用场景）？" class="headerlink" title="42、Session和Cookie应该如何选择（适用场景）？"></a>42、Session和Cookie应该如何选择（适用场景）？</h2><ul>
<li><p>Cookie 只能存储ASCII码字符串，而Session则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session；</p>
</li>
<li><p>Cookie存储在浏览器，容易被恶意查看。<br>如果非要将一些隐私数据存入Cookie中，可以将Cookie值进行加密，然后在服务器解密</p>
</li>
<li><p>对于大型网站，如果用户所有的信息都存储在Session中，那么开销非常大，因此不建议将所有用户的信息都存储到Session中。</p>
</li>
</ul>
<hr>
<h2 id="43、Cookie和Session的区别？"><a href="#43、Cookie和Session的区别？" class="headerlink" title="43、Cookie和Session的区别？"></a>43、Cookie和Session的区别？</h2><p>  Cookie和Session都是客户端与服务器之间保持状态的解决方案</p>
<ol>
<li><p>存储的位置不同，<br>cookie ： 存放在客户端<br>session： 存放在服务端，Session存储的数据比较安全</p>
</li>
<li><p>存储的数据类型不同，两者都是key-value类型，但针对value的类型有差异<br>cookie ： value只能是字符串类型<br>session： value是Object类型</p>
</li>
<li><p>存储的数据大小限制不同，<br>cookie ： 大小受浏览器限制，最多是4K大小<br>session： 理论上受当前内存限制</p>
</li>
<li><p>生命周期的控制，<br>cookie ： cookie的生命周期是累计的，从创建时开始计时，20分钟后，cookie生命周期结束<br>session： session的生命周期是间隔的，从创建开始计时，如在20分钟没访问session，则生命周期被销毁</p>
</li>
</ol>
<hr>
<h2 id="44、DDos攻击？"><a href="#44、DDos攻击？" class="headerlink" title="44、DDos攻击？"></a>44、DDos攻击？</h2><p>客户端向服务器发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认<br>没有彻底根治办法，除非不用TCP</p>
<p>DDos预防：</p>
<ol>
<li><p>限制同时打开SYN半链接的数目</p>
</li>
<li><p>缩短SYN半链接的Time out时间</p>
</li>
<li><p>关闭不必要的服务</p>
</li>
</ol>
<hr>
<h2 id="45、MTU和MSS分别是什么？"><a href="#45、MTU和MSS分别是什么？" class="headerlink" title="45、MTU和MSS分别是什么？"></a>45、MTU和MSS分别是什么？</h2><p>MTU：Maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。</p>
<p>MSS：Maximum segment size，最大分节大小，为<b>TCP数据包每次传输的最大数据分段</b>大小，一般由发送端向对端TCP通知对端在每分节中能发送的最大TCP数据。<br>MSS值为MTU减去 IPv4 Header（20 Byte）和TCP header（20 Byte）得到。</p>
<hr>
<h2 id="46、HTTP中缓存机制，如何保证缓存最新？"><a href="#46、HTTP中缓存机制，如何保证缓存最新？" class="headerlink" title="46、HTTP中缓存机制，如何保证缓存最新？"></a>46、HTTP中缓存机制，如何保证缓存最新？</h2><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age = 31536000</span><br></pre></td></tr></table></figure>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>
<ul>
<li>在 HTTP&#x2F;1.1中，会优先处理max-age指令</li>
<li>在 HTTP&#x2F;1.0中，max-age指令会被忽略掉</li>
</ul>
<hr>
<h2 id="47、TCP头部中有哪些信息？"><a href="#47、TCP头部中有哪些信息？" class="headerlink" title="47、TCP头部中有哪些信息？"></a>47、TCP头部中有哪些信息？</h2><ul>
<li><p>序号（32bit）：传输方向上字节流的字节编号。<br>初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 &#x3D; ISN + 数据在整个字节流中的位移。<br>假设 A-&gt;B 且ISN &#x3D; 1024，<br>第一段数据512字节已经到B，则第二端数据发送时序号为1024+512。用于解决网络包乱序问题。</p>
</li>
<li><p>确认号（32bit）：接收方对发送方TCP报文段响应，其值是收到的序号值 + 1。</p>
</li>
<li><p>首部长（4bit）：标识首部有多少个4字节*首部长，最大为15，即60字节。</p>
</li>
<li><p>标志位（6bit）：</p>
<ul>
<li><p>URG：紧急指针是否有效</p>
</li>
<li><p>ACK：确认号是否有效（确认报文段），解决丢包问题</p>
</li>
<li><p>PSH：提示接收端立即从缓冲读走数据</p>
</li>
<li><p>RST：标识要求对方重新建立连接（复位报文段）。</p>
</li>
<li><p>SYN：标识请求建立一个连接（连接报文段）。</p>
</li>
<li><p>FIN：标识关闭连接（断开报文段）。</p>
</li>
</ul>
</li>
<li><p>窗口（16bit）：接收窗口，用于告知对方（发送方）本方的缓冲还能接收多少字节数据，【流量控制】</p>
</li>
<li><p>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</p>
</li>
</ul>
<hr>
<h2 id="48、常见的TCP连接状态？"><a href="#48、常见的TCP连接状态？" class="headerlink" title="48、常见的TCP连接状态？"></a>48、常见的TCP连接状态？</h2><ul>
<li><p>CLOSED：初始状态</p>
</li>
<li><p>LISTEN：服务器处于监听状态</p>
</li>
<li><p>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态</p>
</li>
<li><p>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</p>
</li>
<li><p>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包进入此状态，服务器接收到ACK包后进入此状态。</p>
</li>
<li><p>FIN_WAIT_1：<b>终止连接的一方</b>（通常是客户机）发送了FIN报文后进入，等待对方FIN。</p>
</li>
<li><p>CLOSE_WAIT：（假设服务器）接收到客户机FIN包后等待关闭的阶段，在接收到对方的FIN包之后，自然需要立即回复ACK包的，表示已经知道断开请求<br>        但是本方是否立即断开（发送FIN包）取决于是否还有数据要发送给客户端，若有，则在发送FIN包之前均为此状态。【关闭之前发送完数据】</p>
</li>
<li><p>FIN_WAIT_2：此时是半链接状态，即有一方要求关闭连接，等待另一方关闭。<br>        客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</p>
</li>
<li><p>LAST_ACK：服务器发动最后的FIN包，等待最后的客户端ACK相应，进入此状态。</p>
</li>
<li><p>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，再次之后的2MSL时间称为TIME_WAIT状态。</p>
</li>
</ul>
<hr>
<h2 id="49、网络的七层-x2F-五层协议有哪些？"><a href="#49、网络的七层-x2F-五层协议有哪些？" class="headerlink" title="49、网络的七层&#x2F;五层协议有哪些？"></a>49、网络的七层&#x2F;五层协议有哪些？</h2><img src="/2022/02/25/network/OSI-1.png" class="">
<hr>
<h2 id="50、TCP？"><a href="#50、TCP？" class="headerlink" title="50、TCP？"></a>50、TCP？</h2><p>TCP（Transmission Control Protocol 传输控制协议）<br>面向连接、可靠的、基于字节流的传输层通信协议。</p>
<hr>
<h2 id="51、TCP头部报文字段？各自功能？"><a href="#51、TCP头部报文字段？各自功能？" class="headerlink" title="51、TCP头部报文字段？各自功能？"></a>51、TCP头部报文字段？各自功能？</h2><ul>
<li><p>源端口和目的端口<br> source port ： 源端口号【本地端口】<br> destination port ： 目的端口号【远程端口】</p>
<blockquote>
<p>扩展：应用程序所在主机的IP和应用程序的端口号统称为socket（套接字） —— IP:端口号<br>在互联网上，是一个socket唯一标识一个应用程序<br>源端口 + IP + 目的端口 + 目的IP 称为“套接字对”，一对套接字就是一个连接，一个客户端与服务器之间的连接</p>
</blockquote>
</li>
<li><p>序列号<br> 序列号。<br> 用于TCP通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信有序性，避免网络中乱序问题。<br> 接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。<br> 初始序列号由自己定，后续的序列号由对端ACK决定：SN_x &#x3D; ACK_y（x的序列号 &#x3D; y发送给x的ACK）</p>
</li>
<li><p>ACK确认序列号<br> 确认序列号。<br> 接收确认端期望收到的下一序列号。<br> 确认序号应当是上次已成功收到的数据字节序号加1，只有当标志位中的ACK标志位1时，该确认序列号的字段才有效<br> 解决不丢包问题。</p>
</li>
<li><p>TCP Flag<br> TCP首部中有6个标志比特，他们中的多个可同时被设置为1，主要是用来控制TCP状态的<br> 有：<code>URG、ACK、PSH、RST、SYN、FIN</code></p>
<ol>
<li><p>ACK：理解为发送端发送数据到接收端，发送时ACK为0，标识接收端还未应答，一旦接收端接收数据之后，就将ACK置为1<br> 发送端接收之后，就知道接收端已经接收到了数据。</p>
</li>
<li><p>SYN：表示【同步序列号】，是TCP握手发送的第一个数据包。用来建立TCP连接<br> SYN标志和ACK标志位搭配使用<br> 当连接请求时，SYN &#x3D; 1, ACK &#x3D; 0<br> 当连接相应时，SYN &#x3D; 1, ACK &#x3D; 1<br> 这个标志的数据报经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明该主机存在端口</p>
</li>
<li><p>FIN：表示发送端已经达到数据末尾，也就是说双方数据传送完成，没有数据可以传送了<br> 发送FIN标志位的TCP数据报后，连接将被断开。<br> 这个标志位的数据报也经常被用于端口扫描。<br> 发送端只剩最后一段数据了，同时要告诉接收端后面没有数据可以接受了，所以用FIN标识一下，接收端看到FIN后，接受完就关闭了</p>
</li>
</ol>
</li>
<li><p>Windows Size 窗口大小<br> 滑动窗口大小，用于流量控制</p>
</li>
</ul>
<hr>
<h2 id="52、OSI的七层模型主要功能？"><a href="#52、OSI的七层模型主要功能？" class="headerlink" title="52、OSI的七层模型主要功能？"></a>52、OSI的七层模型主要功能？</h2><img src="/2022/02/25/network/OSI-2.png" class="">
<ul>
<li><p>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输</p>
</li>
<li><p>数据链路层：接收来自物理层的位流形式的数据，<b>封装成帧</b></p>
</li>
<li><p>网络层：网络地址翻译成对应物理地址，通过路由选择算法为分组通过通信子网选择最适合路径【分组转发】</p>
</li>
<li><p>传输层：在源端和目的端之间提供可靠的透明数据传输【TCP&#x2F;UPD】</p>
</li>
<li><p>会话层：负责在网络中两节点之间建立、维持和终止通信【建立会话】</p>
</li>
<li><p>表示层：处理用户信息的表示问题，数据编码、压缩解压缩、数据的加密和解密</p>
</li>
<li><p>应用层：为用户的应用进程提供网络通信服务。</p>
</li>
</ul>
<hr>
<h2 id="53、应用层常见协议？"><a href="#53、应用层常见协议？" class="headerlink" title="53、应用层常见协议？"></a>53、应用层常见协议？</h2><table>
<thead>
<tr>
<th align="left">协议</th>
<th align="left">名称</th>
<th align="left">默认端口</th>
<th align="left">底层协议</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HTTP</td>
<td align="left">超文本传输协议</td>
<td align="left">80</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">HTTPS</td>
<td align="left">超文本传输安全协议</td>
<td align="left">443</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">Telnet</td>
<td align="left">远程登录服务的标准协议</td>
<td align="left">23</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">FTP</td>
<td align="left">文件传输协议</td>
<td align="left">20传输、21连接</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">TFTF</td>
<td align="left">简单文件传输协议</td>
<td align="left">69</td>
<td align="left">UDP</td>
</tr>
<tr>
<td align="left">SMTP</td>
<td align="left">简单邮件传输协议（发送用）</td>
<td align="left">25</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">POP</td>
<td align="left">邮局协议（接收用）</td>
<td align="left">110</td>
<td align="left">TCP</td>
</tr>
<tr>
<td align="left">DNS</td>
<td align="left">域名解析协议</td>
<td align="left">53</td>
<td align="left">服务器间进行域传输时候用TCP（更新信息）、客户端查询DNS时用UDP</td>
</tr>
</tbody></table>
<hr>
<h2 id="54、浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？"><a href="#54、浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？" class="headerlink" title="54、浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？"></a>54、浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？</h2><p>在 HTTP&#x2F;1.0 中，一个服务器在发送完一个HTTP响应后，会断开TCP链接。但这样每次请求都会重新建立和断开TCP链接，代价过大。</p>
<p>虽然标准中没有设定，某些服务器对<code>Connection: keep-alive</code>的<code>Header</code>进行了支持<br>也即：完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接。<br>好处是链接可以被重新使用，之后发送HTTP请求的时候不需要重新建立TCP连接，如果维持连接，SSL的开销也可避免。</p>
<p><b>持久连接</b>：既然维持TCP连接好处那么多，HTTP&#x2F;1.1就把Connection头写进标准，并且默认开启持久连接，除非请求中声明<code>Connection: close</code><br>那么浏览器和服务器之间会维持一段时间的TCP连接，不会一个请求结束后就断掉</p>
<h2 id="默认情况下建立TCP连接不会断开，只有在请求报头声明Connection-close才会在请求完成后关闭连接"><a href="#默认情况下建立TCP连接不会断开，只有在请求报头声明Connection-close才会在请求完成后关闭连接" class="headerlink" title="默认情况下建立TCP连接不会断开，只有在请求报头声明Connection: close才会在请求完成后关闭连接"></a>默认情况下建立TCP连接不会断开，只有在请求报头声明<code>Connection: close</code>才会在请求完成后关闭连接</h2><h2 id="55、三次握手相关内容"><a href="#55、三次握手相关内容" class="headerlink" title="55、三次握手相关内容"></a>55、三次握手相关内容</h2><img src="/2022/02/25/network/handshake.png" class="">

<p>三次握手，指建立一个TCP连接时，需要客户端和服务器总共发送三个包</p>
<ol>
<li><p>SYN &#x3D; 1, seq &#x3D; client_seq</p>
</li>
<li><p>SYN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; server_seq, ack &#x3D; client_seq + 1</p>
</li>
<li><p>ACK &#x3D; 1, seq &#x3D; client_seq + 1, ack &#x3D; server_seq + 1</p>
</li>
</ol>
<p>进行三次握手的主要作用就是为了</p>
<ul>
<li><p>确认双方的发送和接收能力是否正常</p>
</li>
<li><p>指定自己的初始化序列号为后面可靠性传输做准备</p>
</li>
</ul>
<p>实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和交换号，交换<code>TCP窗口大小</code>信息。</p>
<blockquote>
<p>初始状态：客户端处于<code>closed(关闭)</code>状态，服务器处于<code>listen(监听)</code>状态。<br>第一次握手：客户端发送请求报文将<code>SYN = 1, seq = x</code>，同步序列号及初始化序列号发送给服务端<br>           此后，客户端处于<code>SYN_SEND</code>状态（验证可客户端发送能力和服务器接收能力）<br>第二次握手：服务器收到<code>SYN</code>确认报文之后，如果同意连接，会以自己的同步序列号<code>SYN = 1, seq = y, ack = x + 1</code>，即初始化序列号、确认号报文应答<br>           此后，服务器处于<code>SYN_RECEIVE</code>状态（但是注意，此时客户端的发送能力得到确认，服务器发送和接收得到确认，但不知道客户端是否能接收）<br>第三次握手：客户端接收到服务器的<code>SYN + ACK</code>之后，知道可以下次发送下一序列的数据包了，然后发送<code>ACK = 1, seq = x + 1, ack = y + 1</code>应答<br>           此后客户端作为<code>ESTABLISHED</code>状态。（各自的发送和接受都OK）</p>
</blockquote>
<hr>
<h2 id="56、为什么要三次握手，两次不行？"><a href="#56、为什么要三次握手，两次不行？" class="headerlink" title="56、为什么要三次握手，两次不行？"></a>56、为什么要三次握手，两次不行？</h2><p>需要弄明白三次握手的目的是什么，能不能只用两次握手达到同样目的</p>
<ul>
<li><p>第一次握手：客户端发送数据包，服务器收到 —— 服务器得知：客户端发送能力、服务器接收能力正常。</p>
</li>
<li><p>第二次握手：服务器发送数据包，客户端收到 —— 客户端得知：客户端的发送、接收；服务器的发送、接收正常，但服务器不知道客户端的接收是否正常</p>
</li>
<li><p>第三次握手：客户端发送数据包，服务器收到 —— 服务器得知：客户端的发送、接收；服务器的发送、接收正常。</p>
</li>
</ul>
<p>因此，需要三次握手才能确认双方的发送和接收能力是否正常<br>若用两次握手，则可能：</p>
<blockquote>
<p>客户端发送连接请求，但连接请求报文丢失未收到确认，于是客户端再重传一次连接请求，后来收到了确认，建立了连接。<br>数据传输完毕后，释放了连接，客户端一共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务器</p>
<p>但第一个丢失的报文段只是<b>在某些网络节点长时间滞留了，延误到连接释放以后的某个时间才到达服务器</b><br>此时服务器误以为客户端又发出一次新的连接请求，于是向客户端发送确认报文段，同意建立连接。<br>不采用三次握手，即服务器发送确认就相当于建立了新的连接，但客户端忽略了服务器的该请求，不发送数据<br>服务器则一直等待客户端发送数据，浪费资源。</p>
</blockquote>
<hr>
<h2 id="57、什么是半连接队列？"><a href="#57、什么是半连接队列？" class="headerlink" title="57、什么是半连接队列？"></a>57、什么是半连接队列？</h2><p>服务器第一次收到客户端的SYN后，就会处于SYN_RCVD状态，此时双方还没有完全建立起连接，<br>服务器会把此种状态下请求连接放在一个<b>队列</b>里，该队列即<b>半连接队列</b>。</p>
<p>全连接队列：已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>补充一点关于<b>SYN-ACK重传次数</b>的问题：<br>服务器发送完SYN-ACK包，如果未收到客户端确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。<br>如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。<br>注意：每次等待时间不一定相同，一般指数增长，1&#x2F;2&#x2F;4&#x2F;8诸如此类</p>
<hr>
<h2 id="58、ISN（Initial-Sequence-Number）是固定的吗？"><a href="#58、ISN（Initial-Sequence-Number）是固定的吗？" class="headerlink" title="58、ISN（Initial Sequence Number）是固定的吗？"></a>58、ISN（Initial Sequence Number）是固定的吗？</h2><p>当一端为建立连接而发送SYN时，它为连接选择一个初始序号。<br>ISN随时间而变化，因此每个连接都将具有不同的ISN，ISN可以看做是一个32bit的计数器，但不是简单计数器，大概每4ms加1。</p>
<blockquote>
<p>ISN &#x3D; M + F（localhost, localport, remotehost, remoteport）（M为计数器），ISN应该由这个公式确定，F是哈希算法，不是简单计数器</p>
</blockquote>
<p>这样选择序号的目的在于防止在网络上被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<blockquote>
<p>三次握手的其中一个重要功能是客户端和服务器交换ISN，以便让对方知道接下来收到数据时如何按照序列号组装数据<br>若ISN固定，攻击者很容易猜出后续的序号，因此ISN要动态生成</p>
</blockquote>
<hr>
<h2 id="59、三次握手过程可以携带数据吗？"><a href="#59、三次握手过程可以携带数据吗？" class="headerlink" title="59、三次握手过程可以携带数据吗？"></a>59、三次握手过程可以携带数据吗？</h2><p>三次握手过程中，可以携带数据，但是，<b>只有第三次才可以携带数据</b></p>
<p>为什么要这样？<br>若第一次握手可以携带数据，若有人要恶意攻击服务器，则每次在第一次握手中的SYN报文中放入大量数据，就会让服务器花费很多资源去处理这些报文。</p>
<p>第一次握手中不可放入数据，否则会让服务器更加容易受到攻击。<br>第三次握手中，客户端已经处于ESTABLISHED状态。对于客户端来说，已经建立起连接了，也知道服务器的发送、接受能力正常，所以可以携带。</p>
<hr>
<h2 id="60、SYN攻击？"><a href="#60、SYN攻击？" class="headerlink" title="60、SYN攻击？"></a>60、SYN攻击？</h2><p><b>服务器端的资源分配是在第二次握手时分配的，客户端资源则是在第三次握手时分配的。</b>因此服务器很容易受到SYN泛洪攻击</p>
<p>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断发送SYN包，Server则回复确认包，等待Client确认<br>由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因队满被丢弃，从而网络拥塞，系统瘫痪</p>
<blockquote>
<p>SYN 攻击是一种典型的DoS&#x2F;DDoS攻击。</p>
</blockquote>
<p>检测SYN攻击非常方便，但服务器上看到大量半连接状态时，特别源IP地址是随机的，基本上可以断定是SYN攻击。</p>
<p>在Linux&#x2F;Unix上可以使用系统自带的netstat命令检测SYN攻击。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法：</p>
<ul>
<li><p>缩短超时（SYN Timeout）时间</p>
</li>
<li><p>增加最大半连接数</p>
</li>
<li><p>过滤网关服务</p>
</li>
<li><p>SYN cookies技术</p>
</li>
</ul>
<hr>
<h2 id="61、四次挥手相关内容"><a href="#61、四次挥手相关内容" class="headerlink" title="61、四次挥手相关内容"></a>61、四次挥手相关内容</h2><img src="/2022/02/25/network/handshake4.png" class="">

<p>建立一个连接需要三次握手，终止一个连接需要四次挥手（或称四次握手）<br>这由TCP的<b>半关闭(half-close)</b>造成的<br>半关闭，即TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP的连接的拆除需要发送四个包，因此称为四次回收（Four-way handshake），客户端或服务器均可主动发起挥手动作。</p>
<ul>
<li><p>初始状态：客户端和服务器都在<code>ESTABLISHED（连接状态）</code>下，接下来进行四次挥手断开连接操作。</p>
</li>
<li><p>第一次挥手：事实上，客户端和服务器都可以主动终止连接，此处假设客户端先终止链接。<br>       客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于<code>FIN_WAIT1</code>状态。<br>       即发送<b>链接释放报文</b>，<code>FIN=1, seq = u</code>，并停止再发送数据，主动关闭TCP链接，进入<code>FIN_WAIT1（终止等待1）</code>状态。</p>
</li>
<li><p>第二次挥手：服务器收到FIN之后，发送ACK报文，并把客户端序列号值+1作为ACK报文的ack值，表明收到，此时客户端处于<code>CLOSE_WAIT</code>状态<br>       即发送<b>确认报文段</b>，<code>ACK=1, seq = v, ack = u+1</code>，服务端进入<code>CLOSE_WAIT（关闭等待）</code>状态<br>       此时TCP处于半关闭状态<br>       客户端到服务端的连接释放。客户端收到服务器的确认后，进入<code>FIN_WAIT2（终止等待2）</code>状态，等待服务器发出的连接释放报文段</p>
</li>
<li><p>第三次挥手：服务器收到了客户端的连接释放请求，然而服务器可能还有未传输完毕的数据，则还需要发送消息，并主动断连<br>       服务器也想断开连接，和客户端第一次挥手一样，发送FIN报文，且指定一个序列号，服务器进入<code>LAST_ACK（最后确认）</code>状态。<br>       即服务端没有要向客户端发出的数据，服务器发出<b>连接释放报文段</b>，<code>FIN=1, ACK=1, seq = w, ack = u+1</code><br>       服务器进入<code>LAST_ACK</code>状态，等待客户端确认。</p>
</li>
<li><p>第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应答，且把服务器序列号值+1作为自己ACK报文的确认号，此时客户端处于<code>TIME_WAIT</code>状态<br>       需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态（自己最后的ACK报文段可能出差错到不了服务器）<br>       服务器收到ACK报文之后，就处于关闭连接了，即<code>CLOSED</code>状态。<br>       即客户端收到服务器的链接释放报文后，向其发送<b>确认报文段</b><code>ACK = 1, seq = u + 1, ack = w + 1</code>，客户端进入<code>TIME_WAIT（时间等待）</code>状态。<br>       此时TCP未释放掉，要经过事件等待计时器设置的时间2MSL之后，客户端才进入CLOSED状态。</p>
</li>
</ul>
<p>收到一个FIN只意味着在这一个方向上没有数据流动。<br>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p>
<h2 id="在socket-编程中，任何一方执行close-操作即可产生挥手动作。"><a href="#在socket-编程中，任何一方执行close-操作即可产生挥手动作。" class="headerlink" title="在socket()编程中，任何一方执行close()操作即可产生挥手动作。"></a>在socket()编程中，任何一方执行close()操作即可产生挥手动作。</h2><h2 id="62、挥手为什么要四次？"><a href="#62、挥手为什么要四次？" class="headerlink" title="62、挥手为什么要四次？"></a>62、挥手为什么要四次？</h2><p>因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。<br>其中ACK报文是用来应答的，SYN报文是用来同步的。</p>
<p>但是关闭连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端“收到FIN请求”</p>
<h2 id="但服务器也可能要发送自己的数据，只有当服务器数据也发送完毕，服务器才能发送FIN报文，因此不能一起发送，故四次挥手。"><a href="#但服务器也可能要发送自己的数据，只有当服务器数据也发送完毕，服务器才能发送FIN报文，因此不能一起发送，故四次挥手。" class="headerlink" title="但服务器也可能要发送自己的数据，只有当服务器数据也发送完毕，服务器才能发送FIN报文，因此不能一起发送，故四次挥手。"></a>但服务器也可能要发送自己的数据，只有当服务器数据也发送完毕，服务器才能发送FIN报文，因此不能一起发送，故四次挥手。</h2><h2 id="63、2MSL等待状态？"><a href="#63、2MSL等待状态？" class="headerlink" title="63、2MSL等待状态？"></a>63、2MSL等待状态？</h2><p>TIME_WAIT状态也称为2MSL等待状态</p>
<p>每个具体TCP必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。<br>这个时间是有限的，因为TCP报文段以IP数据包在网络内传输，而IP数据包则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留时间的2倍的MSL。<br>这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）</p>
<p>另一个结果：TCP连接在2MSL等待期间，定义这个连接的接口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。<br>该连接只能在2MSL结束后才能再被使用。</p>
<ol>
<li>防止自己的FIN_ACK丢失</li>
<li>可以阻塞其他该端口上的连接</li>
</ol>
<hr>
<h2 id="64、四次挥手释放连接时，等待2MSL的意义？"><a href="#64、四次挥手释放连接时，等待2MSL的意义？" class="headerlink" title="64、四次挥手释放连接时，等待2MSL的意义？"></a>64、四次挥手释放连接时，等待2MSL的意义？</h2><blockquote>
<p>MSL（Maximum Segment Lifetime）最长报文段寿命，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
</blockquote>
<p>为了保证客户端发送的最后一个ACK报文能到达服务器，因为这个ACK有可能丢失，从而导致处在LAST_ACK状态的服务器接收不到最后的FIN_ACK确认报文。<br>服务器会超时重传这个FIN_ACK，接着客户端再重传一次确认，重新启动时间等待计时器。</p>
<p>最后客户端和服务器都能正常关闭，若服务器不等待2MSL，而是发送ACK后直接释放关闭，一旦这个ACK丢失，服务器无法正常进入关闭连接状态。</p>
<ol>
<li><p>确保客户端发送的最后一个ACK能够到达服务器。该报文段可能丢失，使得LAST_ACK接收不到FIN_ACK报文段确认，服务器超时重传该FIN_ACK。<br>若不等待，可能报文段丢失时再接到了FIN_ACK报文段确认。</p>
</li>
<li><p>防止“已经失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK后，经过2MSL，旧的报文段都会从网络中消失。<br>新的连接中不会收到旧连接请求报文段。</p>
</li>
<li><p>阻塞其他该端口通信。</p>
</li>
</ol>
<hr>
<h2 id="65、为什么TIME-WAIT状态要经过2MSL才能返回CLOSED状态？"><a href="#65、为什么TIME-WAIT状态要经过2MSL才能返回CLOSED状态？" class="headerlink" title="65、为什么TIME_WAIT状态要经过2MSL才能返回CLOSED状态？"></a>65、为什么TIME_WAIT状态要经过2MSL才能返回CLOSED状态？</h2><p>网络可能不可靠，TIME_WAIT状态用来重发可能丢失的最后一个ACK报文。</p>
<p>客户端给服务器发送的ACK &#x3D; 1丢失，服务器会再发一次，若客户端收到重发，说明之前的包丢失，要重启计时器，并在此发送确认请求。<br>若接下来再无服务器信息，说明已收到确认，双方都关闭连接。</p>
<hr>
<h2 id="66、TCP粘包问题？如何解决？"><a href="#66、TCP粘包问题？如何解决？" class="headerlink" title="66、TCP粘包问题？如何解决？"></a>66、TCP粘包问题？如何解决？</h2><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一个包<br>从接收缓冲区来看，后一个数据包的数据头紧紧连着前一个数据包的数据尾</p>
<ul>
<li><p>由TCP连接复用造成的粘包问题</p>
</li>
<li><p>因为TCP默认使用Nagle算法，此算法导致粘包问题。</p>
<ul>
<li>只有上一个分组得到确认，才会发送下一个小组</li>
<li>收集多个小分组，在一个确认到来时一起发送</li>
</ul>
</li>
<li><p>数据包过大造成的粘包问题。</p>
</li>
<li><p>流量控制，拥塞控制也可能导致粘包。</p>
</li>
<li><p>接收方不及时接收缓冲区的包，造成多个包接收</p>
</li>
</ul>
<p>解决：</p>
<ol>
<li><p>Nagle算法问题导致的，要结合应用场景适当关闭该算法</p>
</li>
<li><p>尾部标记序列。通过特殊标识符表示数据边界，例如\n\t\r或特殊字符</p>
</li>
<li><p>头部标记分步接收。在TCP报文头部加上表示数据长度。</p>
</li>
<li><p>应用层发送数据时定长发送</p>
</li>
</ol>
<hr>
<h2 id="67、OSI七层模型表示层和会话层功能？"><a href="#67、OSI七层模型表示层和会话层功能？" class="headerlink" title="67、OSI七层模型表示层和会话层功能？"></a>67、OSI七层模型表示层和会话层功能？</h2><ul>
<li><p>表示层：图像、视频编码解码、数据加密。</p>
</li>
<li><p>会话层：建立会话，如Session认证、断点续传。</p>
</li>
</ul>
<hr>
<h2 id="68、三次握手四次回收变迁图"><a href="#68、三次握手四次回收变迁图" class="headerlink" title="68、三次握手四次回收变迁图"></a>68、三次握手四次回收变迁图</h2>
<hr>
<h2 id="69、对称秘钥加密的优点和缺点"><a href="#69、对称秘钥加密的优点和缺点" class="headerlink" title="69、对称秘钥加密的优点和缺点"></a>69、对称秘钥加密的优点和缺点</h2><p>对称秘钥加密（Symmetric-Key Encryption），加密和解密使用同一秘钥</p>
<ul>
<li>优点：运算速度快</li>
<li>缺点：无法安全地将秘钥传输给通信方</li>
</ul>
<hr>
<h2 id="70、非对称秘钥加密的优缺点？"><a href="#70、非对称秘钥加密的优缺点？" class="headerlink" title="70、非对称秘钥加密的优缺点？"></a>70、非对称秘钥加密的优缺点？</h2><p>非对称秘钥加密，即公开秘钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开秘钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开秘钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。<br>因为私有秘钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断该签名是否正确。</p>
<hr>
<h2 id="71、HTTPS是什么？"><a href="#71、HTTPS是什么？" class="headerlink" title="71、HTTPS是什么？"></a>71、HTTPS是什么？</h2><p>HTTPS不是新协议，是<b>HTTP先和SSL（Secure Sockets Layer）通信，再由SSL和TCP通信，即HTTPS使用隧道进行通信</b><br>通过使用SSL，HTTPS具有了加密性（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<hr>
<h2 id="72、HTTP缺点有哪些？"><a href="#72、HTTP缺点有哪些？" class="headerlink" title="72、HTTP缺点有哪些？"></a>72、HTTP缺点有哪些？</h2><ul>
<li><p>使用明文进行通信，内容可能会被窃听</p>
</li>
<li><p>不验证通信方的身份，通信方的身份有可能遭遇伪装</p>
</li>
<li><p>无法证明报文的完整性，报文有可能遭篡改</p>
</li>
</ul>
<hr>
<h2 id="73、HTTPS采用的加密方式有哪些？对称还是非对称？"><a href="#73、HTTPS采用的加密方式有哪些？对称还是非对称？" class="headerlink" title="73、HTTPS采用的加密方式有哪些？对称还是非对称？"></a>73、HTTPS采用的加密方式有哪些？对称还是非对称？</h2><p>HTTPS采用混合的加密机制，使用<b>非对称密钥加密用于传输对称密钥来保证传输过程的安全性</b><br>之后使用<b>对称密钥加密进行通信来保证通信过程的效率</b>。</p>
<blockquote>
<p>非对称保证安全，对称保证效率</p>
</blockquote>
<img src="/2022/02/25/network/httpsSecure.png" class="">

<p>确保传输安全过程（其实就是rsa原理）：</p>
<ol>
<li><p>Client给出协议版本号、一个客户端生成的随机数（Client Random），以及客户端支持的加密算法。</p>
</li>
<li><p>Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server Random）。</p>
</li>
<li><p>Client确认数字证书有效，然后生成一个新的随机数（Premaster Secret），并使用数字证书中的公钥，加密这个随机数，发给Server</p>
</li>
<li><p>Server使用自己的私钥，获取Client发来的随机数（Premaster Secret）</p>
</li>
<li><p>Client和Server根据约定的加密方法，使用前面的三个随机数，生成“对话密钥”（Session Key），用来加密接下来的整个对话过程。</p>
</li>
</ol>
<hr>
<h2 id="74、为什么有时候刷新页面不需要重新建立SSL连接？"><a href="#74、为什么有时候刷新页面不需要重新建立SSL连接？" class="headerlink" title="74、为什么有时候刷新页面不需要重新建立SSL连接？"></a>74、为什么有时候刷新页面不需要重新建立SSL连接？</h2><p>TCP连接有的时候会被浏览器和服务端维持一段时间<br>TCP不需要重新建立，SSL自然也会用之前的。</p>
<hr>
<h2 id="75、SSL中的认证中的证书是什么？"><a href="#75、SSL中的认证中的证书是什么？" class="headerlink" title="75、SSL中的认证中的证书是什么？"></a>75、SSL中的认证中的证书是什么？</h2><p>通过使用<b>证书</b>来对通信放进行认证。</p>
<p>数字证书认证机构（CA，Certficate Authority）是客户端和服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向CA提出公开密钥的申请，CA在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名<br>然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥整数后绑定在一起。</p>
<p>进行HTTPS通信时，服务器会把证书发送给客户端。<br>客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以通信了。</p>
<hr>
<h2 id="76、HTTP如何禁用缓存？如何确认缓存？"><a href="#76、HTTP如何禁用缓存？如何确认缓存？" class="headerlink" title="76、HTTP如何禁用缓存？如何确认缓存？"></a>76、HTTP如何禁用缓存？如何确认缓存？</h2><p>HTTP&#x2F;1.1 通过Cache-Control首部字段来控制缓存。</p>
<p><b>禁止进行缓存</b></p>
<p>no-store指令规定不能对请求或响应的任何一部分进行缓存。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p><b>强制确认缓存</b></p>
<p>no-cache指令规定缓存服务器需要先向源服务器验证缓存资源的有效性<br>只有当缓存资源有效时才能使用该缓存对客户端的请求进行相应。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="77、GET和POST传递数据的最大长度能达到多少？"><a href="#77、GET和POST传递数据的最大长度能达到多少？" class="headerlink" title="77、GET和POST传递数据的最大长度能达到多少？"></a>77、GET和POST传递数据的最大长度能达到多少？</h2><p>get 是通过URL提交数据，因此GET可提交的数据量就跟URL能达到的最大长度有直接关系。<code>?和key:value</code></p>
<p>很多文章都说GET方式提交的数据最多只能是1024字节，实际上，URL不存在参数上限的问题，HTTP协议也没有对URL长度进行限制。<br>然而，特定浏览器及服务器对URL有限制：<br>   IE对URL长度的限制是2083字节（2K+35字节）；<br>   对于其他浏览器，如FireFox，Netscape等，没有长度限制，此时限制取决于服务器操作系统；<br>   如果URL太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。</p>
<p>post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。</p>
<p>因为一般post的数据量很少超过MB，因此很少能感觉得到post的数据量限制<br>但实际上如果上传文件过程中会发现这样的问题，即上传个头较大文件到服务器时，可能上传不上去。</p>
<p>以php语言来说，查原因的时候也许会看到说PHP上传文件涉及到的参数，PHP默认上传有限定，一般值是2MB<br>更改这个值需要修改php.conf和post_max_size这个值。</p>
<hr>
<h2 id="78、网络层常见协议？"><a href="#78、网络层常见协议？" class="headerlink" title="78、网络层常见协议？"></a>78、网络层常见协议？</h2><table>
<thead>
<tr>
<th align="left">协议</th>
<th align="left">名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IP</td>
<td align="left">网际协议</td>
<td align="left">IP协议不但定义了数据传输时的基本单元和格式，还定义了数据包的递交方法和路由选择</td>
</tr>
<tr>
<td align="left">ICMP</td>
<td align="left">Internet控制报文协议</td>
<td align="left">ICMP就是一个“错误侦测和回报机制”，其目的就是让我们能够检测网络的连线状况，也能确保连线准确性，是ping和tracert的工作协议</td>
</tr>
<tr>
<td align="left">RIP</td>
<td align="left">路由信息协议</td>
<td align="left">使用“跳数”（metric）来衡量到达目标地址的路由距离</td>
</tr>
<tr>
<td align="left">IGMP</td>
<td align="left">Internet组管理协议</td>
<td align="left">用于实现组播、广播等通信</td>
</tr>
</tbody></table>
<hr>
<h2 id="79、TCP四大拥塞控制算法总结？（重要）"><a href="#79、TCP四大拥塞控制算法总结？（重要）" class="headerlink" title="79、TCP四大拥塞控制算法总结？（重要）"></a>79、TCP四大拥塞控制算法总结？（重要）</h2><p><b>四大算法</b><br>拥塞控制主要是四个算法：</p>
<ol>
<li>慢启动</li>
<li>拥塞控制</li>
<li>快重传</li>
<li>快恢复</li>
</ol>
<ul>
<li><p>慢启动 - Slow Start：<br> 所谓慢启动，就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道秩序</p>
<ol>
<li><p>连接建好时，初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</p>
</li>
<li><p>每当收到一个ACK，cwnd大小加1，呈线性上升</p>
</li>
<li><p>每当过了一个往返延迟时间RTT（Round-Trip Time），cwnd大小直接翻倍，乘2，指数上升</p>
</li>
<li><p>还有一个ssthresh（Slow start threshold），是一个上线，当cwnd &gt;&#x3D; ssthresh时，就会进入<code>拥塞避免</code>算法</p>
</li>
</ol>
</li>
<li><p>拥塞避免算法 - Congestion Avoidance<br> 当拥塞窗口cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。</p>
<ol>
<li><p>收到一个ACK，则cwnd &#x3D; cwnd + 1 &#x2F; cwnd</p>
</li>
<li><p>每当过了一个往返时延时间RTT，cwnd大小加1。【即收到一组之后cwnd才加】</p>
</li>
</ol>
<p> 过了慢启动阈值之后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢地增加调整到网络的最佳值。</p>
</li>
<li><p>拥塞发生状态时的算法<br> 一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。<br> 对于丢包有两种判定方式<br>1. 超时重传RTO（Retransmission Timeout）超时<br><br>2. 收到三个重复确认ACK<br> 超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据包的ACK报文，那么就重发数据，直到发送成功为止</p>
<p> 重复收到3个以上ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做<code>快重传</code>，而快速重传之后没有使用慢启动算法，而是拥塞避免算法，这个又叫做<code>快恢复</code>算法。</p>
<p> 超出重传RTO（Retransmission Timeout）超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：<br>* 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一般，即 ssthresh &#x3D; cwnd &#x2F; 2<br><br>* cwnd 重置为1<br>* 进入慢启动过程<br> 最早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd重置为1，不利于网络数据的稳定传输。</p>
<p> 所以TCP Reno算法进行了优化，当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，不用等到RTO超时再进行重传：<br>* cwnd大小缩小为当前的一半<br><br>* ssthresh设置为缩小后的cwnd大小（相当于ssthresh也缩小为一半）<br>* 然后进入快速恢复算法Fast Recovery</p>
</li>
</ul>
<img src="/2022/02/25/network/CrowdWindow.png" class="">

<ul>
<li><p>快速恢复算法 - Fast Recovery<br> TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。</p>
<p> 在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。<br> 快速恢复算法的逻辑如下：<br>* cwnd &#x3D; cwnd + 3 MSS，加3 MSS的原因是因为受到三个重复的ACK<br><br>* 重传DACKs指定的数据包<br>* 如果再受到DACKs，则cwnd大小加1<br>* 如果收到新的ACK，表明重传的包成功了，则退出快速恢复算法，将cwnd设置为ssthresh，然后进入拥塞避免算法。</p>
</li>
</ul>
<img src="/2022/02/25/network/CrowdWindowPractical.png" class="">

<p>如图所示，第五个包发生了丢失，所以导致接收方收到三次重复AK，也就是ACK5。</p>
<p>所以将ssthresh设置为当前cwnd的一半，也就是6&#x2F;2 &#x3D; 3，cwnd设置为3+3&#x3D;6，然后重传第五个包。</p>
<h2 id="当收到新的ACK时，即ACK11，则退出快恢复阶段，将cwnd重新设置为当前的ssthresh，即3，然后进入拥塞避免算法阶段"><a href="#当收到新的ACK时，即ACK11，则退出快恢复阶段，将cwnd重新设置为当前的ssthresh，即3，然后进入拥塞避免算法阶段" class="headerlink" title="当收到新的ACK时，即ACK11，则退出快恢复阶段，将cwnd重新设置为当前的ssthresh，即3，然后进入拥塞避免算法阶段"></a>当收到新的ACK时，即ACK11，则退出快恢复阶段，将cwnd重新设置为当前的ssthresh，即3，然后进入拥塞避免算法阶段</h2><h2 id="80、为何快速重传是选择3次ACK？"><a href="#80、为何快速重传是选择3次ACK？" class="headerlink" title="80、为何快速重传是选择3次ACK？"></a>80、为何快速重传是选择3次ACK？</h2><p>主要的考虑还是要区分包的丢失是忧郁链路故障还是乱序等其他因素引发。</p>
<p>两次Duplicated ACK时很可能是乱序造成的。<br>三次Duplicated ACK时很可能是丢包造成的。<br>四次Duplicated ACK时更可能是丢包造成的，但四次重复ACK响应策略太慢。</p>
<p>丢包肯定会造成三次Duplicated ACK，综上所述，收到三个重复确认时窗口减半效果最好，是实践经验。</p>
<p>在没有<code>快重传/快恢复</code>算法之前，重传依靠发送方的retransit timeout，就是在timeout内如果没有接收到对方的ACK，默认丢包，发送方则重传<br>包丢失的原因：</p>
<ol>
<li>包checksum出错</li>
<li>网络拥塞</li>
<li>网络断，包括路由重收敛。</li>
</ol>
<p>但是发送方无法判断是哪一种情况，于是采用最笨的方法，就是将自己的发送速率减半，即CWND减为1&#x2F;2<br>这样的方法对2是有效的，可以缓解网络拥塞；<br>3则无所谓，反正网络断了，无论发快发慢都会被丢；<br>对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。</p>
<p>于是有了快恢复算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK<br>如果在timeout时间内没有接收到&gt;2的Duplicated ACK，则大概率为乱序，乱序无序重传，接收方会进行排序工作。</p>
<p>而如果接收到三个或三个以上的Duplicated ACK，则大概率丢包，可以逻辑推理，发送方可以接收ACK，则网络可能是通的<br>可能是1&#x2F;2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）</p>
<h2 id="而如果依然接收到Duplicated-ACK，则认为是网络拥塞造成的，此时降速合理。"><a href="#而如果依然接收到Duplicated-ACK，则认为是网络拥塞造成的，此时降速合理。" class="headerlink" title="而如果依然接收到Duplicated ACK，则认为是网络拥塞造成的，此时降速合理。"></a>而如果依然接收到Duplicated ACK，则认为是网络拥塞造成的，此时降速合理。</h2><h2 id="81、对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？"><a href="#81、对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？" class="headerlink" title="81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？"></a>81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？</h2><ul>
<li><p>FIN_WAIT_2:</p>
<ul>
<li><p>半关闭状态</p>
</li>
<li><p>发送断开请求一方还有数据接收能力，但没有发送数据能力。</p>
</li>
</ul>
</li>
<li><p>CLOSE_WAIT：</p>
<ul>
<li><p>被动关闭连接一方收到FN包会立即返回ACK包表示已经收到断开请求。</p>
</li>
<li><p>被动关闭连接一方如果还有剩余数据要发送就进入CLOSE_WAIT状态。</p>
</li>
</ul>
</li>
<li><p>TIME_WAIT状态：</p>
<ul>
<li><p>也称2MSL等待状态</p>
</li>
<li><p>如果客户端直接进入CLOSED状态，如果服务器没有接收到最后一次ACK包，会在超时之后重新发送FIN包，因为客户端已经CLOSED，所以服务器就不会收到ACK而是RST。<br> 因此，TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</p>
</li>
<li><p>在2MSL时间内，同一个socket不能再被使用，否则可能会和旧连接数据混淆（如果新旧连接socket相同的话）</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="82、流量控制原理？"><a href="#82、流量控制原理？" class="headerlink" title="82、流量控制原理？"></a>82、流量控制原理？</h2><ul>
<li><p>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</p>
</li>
<li><p>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个<b>发送窗口和接收窗口</b></p>
<ul>
<li><p>发送窗口：用来限制发送方可以发送的数据大小（应该是接收窗口和拥塞窗口最小值）<br> 其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓存（受系统、硬件等限制）大小</p>
</li>
<li><p>接收窗口：用来标记可以接收的数据大小。</p>
</li>
</ul>
</li>
<li><p>TCP是流数据，发送出去的数据流可以被分为以下四个部分：</p>
<ul>
<li>已发送且被确认部分</li>
<li>已发送未被确认部分</li>
<li>未发送但可发送部分</li>
<li>不可发送部分<br> 其中发送窗口 &#x3D; 已发送未确认 + 未发送但可发送部分。</li>
</ul>
<p> 接收到的数据流可分为：</p>
<ul>
<li>已接收</li>
<li>未接收但准备接收</li>
<li>未接收不准备接收<br> 其中接收窗口 &#x3D; 未接收但准备接收部分。</li>
</ul>
</li>
<li><p>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗口，左边缘紧贴刚被确认的数据<br> 接收窗口也只有接收到数据且最左侧连续时才移动接收窗口。</p>
</li>
</ul>
<hr>
<h2 id="建立TCP服务器的各个系统调用的过程？"><a href="#建立TCP服务器的各个系统调用的过程？" class="headerlink" title="建立TCP服务器的各个系统调用的过程？"></a>建立TCP服务器的各个系统调用的过程？</h2><img src="/2022/02/25/network/TCPBuilder1.png" class="">
<img src="/2022/02/25/network/TCPBuilder2.png" class="">

<ul>
<li><p>服务器：</p>
<ul>
<li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p>
<ul>
<li>domain：协议域，决定了socket的地址类型，IPv4为AF_INET</li>
<li>type：指定socket类型，SOCK_STREAM为TCP连接</li>
<li>protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。</li>
</ul>
</li>
<li><p>绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<ul>
<li>sockfd：socket返回的套接字描述符，类似于文件描述符fd。</li>
<li>addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPv4的sockaddr地址结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">   <span class="type">sa_family_t</span> sin_family; <span class="comment">// 协议类型，AF_INET</span></span><br><span class="line">   <span class="type">in_port_t</span>   sin_port;   <span class="comment">// 端口号</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">// IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">   <span class="type">uint32_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>addrlen：地址长度</li>
</ul>
</li>
<li><p>监听端口号 -&gt; int listen(int sockfd, int backlog);</p>
<ul>
<li>sockfd：要监听的socket描述字。</li>
<li>backlog：socket可以排队的最大连接数</li>
</ul>
</li>
<li><p>接收用户请求 -&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
<ul>
<li>sockfd：服务器socket描述字。</li>
<li>addr：指向地址结构指针。</li>
<li>addrlen：协议地址长度。</li>
<li>注意：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。</li>
</ul>
</li>
<li><p>从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);</p>
<ul>
<li>fd：连接描述字</li>
<li>buf：缓冲区buf</li>
<li>count：缓冲区长度</li>
<li>注：大于0标识读取的字节数，返回0标识文件读取结束，小于0标识发生错误。</li>
</ul>
</li>
<li><p>关闭socket -&gt; int close(int fd);</p>
<ul>
<li>fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。</li>
<li>注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>客户机：</p>
<ul>
<li>创建socket -&gt; int socket(int domain, int type, int protocol);</li>
<li>连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr *addr, socklen_t addrlen);<ul>
<li>sockfd：客户端的sock描述字</li>
<li>addr：服务器的地址</li>
<li>addrlen：socket地址长度</li>
</ul>
</li>
<li>向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);<ul>
<li>fd、buf、count：同read中含义</li>
<li>大于0表示写了部分或全部数据，小于0则表示出错</li>
</ul>
</li>
<li>关闭socket -&gt; int close(int fd);<ul>
<li>fd：同服务器端fd。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="84、TCP协议如何保证可靠传输？"><a href="#84、TCP协议如何保证可靠传输？" class="headerlink" title="84、TCP协议如何保证可靠传输？"></a>84、TCP协议如何保证可靠传输？</h2><ol>
<li><p>确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</p>
</li>
<li><p>数据校验：TCP报文头有校验和，用于校验报文是否损坏</p>
</li>
<li><p>数据合理分片和排序：</p>
<ul>
<li>TCP会按最大传输单元（MTU）合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。</li>
<li>UDP：IP数据包大于1500字节，大于MTU，则IP层要分片，把数据报分成若干片，每一片小于MTU。接收方的IP层要进行重组。<br>由于UDP的特性，某一片数据丢失时，接收方便无法重组数据包，导致丢弃整个UDP数据报。</li>
</ul>
</li>
<li><p>流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止丢包</p>
</li>
<li><p>拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止丢包。</p>
</li>
</ol>
<hr>
<h2 id="85、UDP是什么？"><a href="#85、UDP是什么？" class="headerlink" title="85、UDP是什么？"></a>85、UDP是什么？</h2><p>提供无连接的，尽最大努力交付的数据传输服务（<b>不保证数据传输可靠性</b>）</p>
<h2 id="86、封包和拆包？基于TCP还是UDP？"><a href="#86、封包和拆包？基于TCP还是UDP？" class="headerlink" title="86、封包和拆包？基于TCP还是UDP？"></a>86、封包和拆包？基于TCP还是UDP？</h2><p>封包和拆包都是基于TCP的概念，因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报时为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。<br> 包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在收到报文后提取包头中的长度信息进行截取。</li>
</ul>
<hr>
<h2 id="86、TCP和UDP的区别？"><a href="#86、TCP和UDP的区别？" class="headerlink" title="86、TCP和UDP的区别？"></a>86、TCP和UDP的区别？</h2><ol>
<li><p>是否面向连接？<br>TCP面向连接（如同打电话要先拨号建立连接）<br>UDP是无连接的，即发送数据之前不需要建立连接</p>
</li>
<li><p>是否可靠？<br>TCP提供可靠的服务，即通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；<br>UDP尽最大努力交付，即不保证可靠交付。</p>
</li>
<li><p>字节流？报文？<br>TCP面向字节流，实际上TCP把数据看成一连串无结构的字节流；<br>   可以想象成流水形式，发送方TCP会将数据放入缓存区，等到可以发送时候发送。不能发送就等着TCP会根据当前网络拥塞状态来确定每个报文段大小。<br>UDP面向报文，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，直播等）<br>   发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层<br>   论应用层交给UDP多长的报文，它统统发送，一次发送一个。<br>   接收方接到后直接去除首部，交给上面的应用层就完成任务了，因此需要应用层控制报文大小</p>
</li>
<li><p>如何交互？<br>TCP连接，只能是点对点的<br>UDP连接支持一对一，一对多，多对一，多对多的交互通信。</p>
</li>
<li><p>首部开销？<br>TCP首部开销20字节；<br>UDP首部开销8字节</p>
</li>
<li><p>逻辑通信信道？<br>TCP逻辑通信信道是全双工的可靠信道<br>UDP则是不可靠信道</p>
</li>
</ol>
<hr>
<h2 id="87、UDP和TCP的特点？"><a href="#87、UDP和TCP的特点？" class="headerlink" title="87、UDP和TCP的特点？"></a>87、UDP和TCP的特点？</h2><ul>
<li><p>UDP</p>
<ul>
<li><p>UDP是无连接的</p>
</li>
<li><p>UDP尽最大努力交付</p>
</li>
<li><p>UDP面向报文</p>
</li>
<li><p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，IP电话，实时视频会议等）</p>
</li>
<li><p>UDP支持一对一、一对多、多对一、多对多的交互通信</p>
</li>
<li><p>UDP的首部开销小，只有8个字节，比TCP的20字节首部短</p>
</li>
</ul>
</li>
<li><p>TCP</p>
<ul>
<li><p>TCP面向连接</p>
</li>
<li><p>TCP提供可靠交付的服务</p>
</li>
<li><p>TCP提供全双工通信，因此双方都有发送和接收缓存</p>
</li>
<li><p>TCP面向字节流</p>
</li>
<li><p>TCP是点对点的，一对一</p>
</li>
<li><p>TCP首部20字节</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="88、TCP对应的应用层协议"><a href="#88、TCP对应的应用层协议" class="headerlink" title="88、TCP对应的应用层协议"></a>88、TCP对应的应用层协议</h2><ul>
<li><p>FTP：定义了文件传输协议，使用21端口</p>
</li>
<li><p>Telnet：是一种用于远程登录的协议，使用23端口</p>
</li>
<li><p>SMTP：定义了简单邮件传送协议，服务器开放25端口</p>
</li>
<li><p>POP3：和SMTP对应，POP3用于接收邮件</p>
</li>
</ul>
<hr>
<h2 id="89、UDP对应的应用层协议"><a href="#89、UDP对应的应用层协议" class="headerlink" title="89、UDP对应的应用层协议"></a>89、UDP对应的应用层协议</h2><ul>
<li><p>DNS：用于域名解析服务，用53端口</p>
</li>
<li><p>SNMP：简单网络管理协议，使用161端口</p>
</li>
<li><p>TFTP（Trival File Transfer Protocol）：简单文件传输协议，使用69端口</p>
</li>
</ul>
<hr>
<h2 id="90、数据链路层常见协议？"><a href="#90、数据链路层常见协议？" class="headerlink" title="90、数据链路层常见协议？"></a>90、数据链路层常见协议？</h2><table>
<thead>
<tr>
<th align="left">协议</th>
<th align="left">名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ARP</td>
<td align="left">地址解析协议</td>
<td align="left">根据IP地址获取物理地址</td>
</tr>
<tr>
<td align="left">RARP</td>
<td align="left">反向地址转换协议</td>
<td align="left">根据物理地址获得IP地址</td>
</tr>
<tr>
<td align="left">PPP</td>
<td align="left">点对点协议</td>
<td align="left">主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通解决方案</td>
</tr>
</tbody></table>
<hr>
<h2 id="91、Ping命令基于哪一层协议的原理？"><a href="#91、Ping命令基于哪一层协议的原理？" class="headerlink" title="91、Ping命令基于哪一层协议的原理？"></a>91、Ping命令基于哪一层协议的原理？</h2><h2 id="ping命令基于网络层的命令，是基于ICMP协议工作的。"><a href="#ping命令基于网络层的命令，是基于ICMP协议工作的。" class="headerlink" title="ping命令基于网络层的命令，是基于ICMP协议工作的。"></a>ping命令基于网络层的命令，是基于ICMP协议工作的。</h2><h2 id="92、在进行UDP编程时，一次发送多少Bytes好？"><a href="#92、在进行UDP编程时，一次发送多少Bytes好？" class="headerlink" title="92、在进行UDP编程时，一次发送多少Bytes好？"></a>92、在进行UDP编程时，一次发送多少Bytes好？</h2><p>没有唯一答案，对于不同系统，不同要求，得到答案不一样。</p>
<p>仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，也许能得到一点帮助：<br>   首先，TCP&#x2F;IP通常被认为是一个四层协议系统，包括：链路层、网络层、运输层、应用层。<br>   UDP属于运输层。</p>
<p>由下至上一步一步看：<br>   以太网（Ethernet）数据帧长度必须在46-1500字节之间，这是由以太网的物理特性决定的。<br>   这个1500字节被称为链路层的MTU（最大传输单元）。但这并不是指链路层的长度被限制在1500字节<br>   其实MTU指的是链路层的<code>数据区</code>，并不包括链路层的首部和尾部18字节。</p>
<p>所以，其实1500字节就是网络层IP数据包的长度限制，因为IP数据包的首部为20字节，所以IP数据包的数据区长度最大为1480字节。<br>而这1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的。<br>因为UDP数据报的首部8字节，所以UDP数据报的数据区最大长度为1472字节。即可用字节数。</p>
<p>当UDP数据大于1472时候会怎样？<br>即IP数据报大于1500字节，大于MTU。此时发送方IP层就要分片（fragmentation），把数据分成若干片，使每一片都小于MTU。<br>接收方IP层要对数据报进行重组。这样会多做很多事情。<br>更严重的是，UDP的特性导致当某一片数据传输中丢失时，接收方无法重组整个数据报，会导致UDP数据报被丢弃。</p>
<p>因此在普通局域网环境下，建议将UDP数据控制在1472字节一下为好。</p>
<p>进行Internet变成时则不同，因为Internet上路由器可能会将MTU设置为不同值。<br>假定MTU为1500来发送数据，经过某个网络的MTU值小于1500字节，则系统将会使用一系列机制调整MTU，使数据报能顺利到达目的地，多做许多不必要操作。</p>
<h2 id="鉴于Internet上标准的MTU值为576字节，因此建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节（576-8-20）以内。"><a href="#鉴于Internet上标准的MTU值为576字节，因此建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节（576-8-20）以内。" class="headerlink" title="鉴于Internet上标准的MTU值为576字节，因此建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节（576-8-20）以内。"></a>鉴于Internet上标准的MTU值为576字节，因此建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节（576-8-20）以内。</h2><h2 id="93、TCP利用滑动窗口实现流量控制的机制？"><a href="#93、TCP利用滑动窗口实现流量控制的机制？" class="headerlink" title="93、TCP利用滑动窗口实现流量控制的机制？"></a>93、TCP利用滑动窗口实现流量控制的机制？</h2><blockquote>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP利用滑动窗口实现流量控制</p>
</blockquote>
<p>TCP中采用滑动窗口进行传输控制，滑动窗口的大小意味着<b>接收方还有多大的缓冲区可以用于接收数据</b>。<br>发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。<br>当滑动窗口为0时，发送方一般不能再发送数据报。</p>
<p>两种情况除外：</p>
<ol>
<li>可以发送紧急数据 —— 例如允许用户终止在远端机上的运行程序。</li>
<li>发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方滑动窗口大小。</li>
</ol>
<hr>
<h2 id="94、解释一下RTO-x2F-RTT-x2F-超时重传？"><a href="#94、解释一下RTO-x2F-RTT-x2F-超时重传？" class="headerlink" title="94、解释一下RTO&#x2F;RTT&#x2F;超时重传？"></a>94、解释一下RTO&#x2F;RTT&#x2F;超时重传？</h2><ul>
<li><p>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间，就是重传间隔。</p>
<ul>
<li>通常每次重传RTO是前一次重传时间的两倍，计量单位通常是RTT。例如：1RTT&#x2F;2RTT&#x2F;4RTT&#x2F;8RTT…</li>
<li>重传次数到达上限之后停止重传</li>
</ul>
</li>
<li><p>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据包在网络中一个往返用时，大小不稳定</p>
</li>
<li><p>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：</p>
<ul>
<li><p>发送的数据没能到达接收端，所以对方没有相应。</p>
</li>
<li><p>接收端接收到数据，但是ACK报文在返回过程中丢失。</p>
</li>
<li><p>接收端拒绝或丢弃数据。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="95、XSS攻击？"><a href="#95、XSS攻击？" class="headerlink" title="95、XSS攻击？"></a>95、XSS攻击？</h2><p>跨站点脚本攻击，指攻击者通过篡改网络，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。</p>
<p>如何防范XSS？</p>
<ol>
<li><p>前端、服务端，同时需要字符串输入的长度限制</p>
</li>
<li><p>前端、服务端，同时需要对HTML转义处理，将其中”&lt;””&gt;”等特殊字符进行转义编码。</p>
</li>
</ol>
<h2 id="防XSS的核心是必须对输入的数据做过滤处理。"><a href="#防XSS的核心是必须对输入的数据做过滤处理。" class="headerlink" title="防XSS的核心是必须对输入的数据做过滤处理。"></a>防XSS的核心是必须对输入的数据做过滤处理。</h2><h2 id="96、CSRF攻击？"><a href="#96、CSRF攻击？" class="headerlink" title="96、CSRF攻击？"></a>96、CSRF攻击？</h2><p>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户身份进行非法操作。</p>
<p>攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求<br>CSRF能做的事包括用你的身份发邮件、发短信、进行交易转账、甚至盗取账号信息等。</p>
<hr>
<h2 id="97、如何防范CSRF攻击？"><a href="#97、如何防范CSRF攻击？" class="headerlink" title="97、如何防范CSRF攻击？"></a>97、如何防范CSRF攻击？</h2><ol>
<li><p>安全框架：例如Spring Security。</p>
</li>
<li><p>token机制：在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。</p>
</li>
<li><p>验证码：通常情况下，验证码能够很好地遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，不是主要解决方案。</p>
</li>
<li><p>referer识别：在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。<br>  但是，服务器并非都能取到Referer。很多用户处于隐私保护的考虑，限制了Referer的发送。<br>  在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。</p>
<ol>
<li>验证请求来源地址</li>
<li>关键操作添加验证码</li>
<li>在请求地址添加token并验证</li>
</ol>
</li>
</ol>
<hr>
<h2 id="98、文件上传漏洞是如何发生的？"><a href="#98、文件上传漏洞是如何发生的？" class="headerlink" title="98、文件上传漏洞是如何发生的？"></a>98、文件上传漏洞是如何发生的？</h2><p>文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。<br>许多第三方框架、服务，都曾经被曝出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等，可被攻击者上传恶意代码，有可能服务端被黑。</p>
<hr>
<h2 id="99、如何防范文件上传漏洞"><a href="#99、如何防范文件上传漏洞" class="headerlink" title="99、如何防范文件上传漏洞"></a>99、如何防范文件上传漏洞</h2><p>文件上传的目录设置为不可执行</p>
<ol>
<li><p>判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。<br>因为对于上传文件，不能简单地通过后缀名判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。</p>
</li>
<li><p>对上传的文件类型进行白名单校验，只允许上传可靠类型。</p>
</li>
<li><p>上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本<br>同时像shell.php.rar.ara这类文件，因为重命名而无法成功实施攻击。</p>
</li>
<li><p>限制上传文件的大小。</p>
</li>
<li><p>单独设置文件服务器的域名。</p>
</li>
</ol>
<hr>
<h2 id="100、拥塞控制原理？"><a href="#100、拥塞控制原理？" class="headerlink" title="100、拥塞控制原理？"></a>100、拥塞控制原理？</h2><ul>
<li><p>拥塞控制的目的是防止数据被过多注入网络导致网络资源（路由器、交换机等）过载。<br> 因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</p>
</li>
<li><p>TCP拥塞控制算法：</p>
<ul>
<li><p>慢开始 &amp; 拥塞避免：<br> 慢开始：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到到达阈值ssthresh<br> 拥塞避免：以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阈值减为原先一半，继续执行线性增加，这个过程为拥塞避免。</p>
</li>
<li><p>快速重传 &amp; 快速恢复：<br> 略</p>
</li>
<li><p>最终拥塞窗口会收敛于稳定值。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="101、如何区分流量控制和拥塞避免？"><a href="#101、如何区分流量控制和拥塞避免？" class="headerlink" title="101、如何区分流量控制和拥塞避免？"></a>101、如何区分流量控制和拥塞避免？</h2><ul>
<li><p>流量控制属于通信双方协商<br>拥塞控制涉及通信链路全局</p>
</li>
<li><p>流量控制需要通信双方各维护一个发送窗口、一个接收窗口，对任意一方，接收窗口大小由自身决定，发送窗口大小由接收方TCP报文段中窗口值确定<br>拥塞控制的拥塞窗口大小由试探性发送一定数据量数据探查网络状况后而自适应调整</p>
</li>
<li><p>实际最终发送窗口 &#x3D; min（拥塞窗口，发送窗口）</p>
</li>
</ul>
<hr>
<h2 id="102、常见HTTP状态码？"><a href="#102、常见HTTP状态码？" class="headerlink" title="102、常见HTTP状态码？"></a>102、常见HTTP状态码？</h2><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">类别</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">Informational（信息性状态码）</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">Success（成功状态码）</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">Redirection（重定向状态码）</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">Client Error（客户端错误状态码）</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">Server Error（服务器错误状态码）</td>
<td align="left">服务器处理请求出错</td>
</tr>
</tbody></table>
<ul>
<li><p>1XX 信息<br> 100 Continue：表明目前为止很正常，客户端可以继续发送请求或忽略这个相应。</p>
</li>
<li><p>2XX 成功</p>
<ul>
<li><p>200 OK</p>
</li>
<li><p>204 No Content：请求已经成功处理，但是返回的相应报文不包含实体的主题部分。<br>            一般只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li><p>206 Partial Content：表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容。</p>
</li>
</ul>
</li>
<li><p>3XX 重定向</p>
<ul>
<li><p>301 Moved Permanently：永久性重定向</p>
</li>
<li><p>302 Found：临时性重定向</p>
</li>
<li><p>303 See Other：和302有相同的功能，但是303明确要求客户端应该采用GET方法获取资源</p>
</li>
<li><p>304 Not Modified：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Mathch，If-Range，If-Unmdodified-Since<br>              如果不满足条件，则服务器返回304状态码</p>
</li>
<li><p>307 Temporary Redirect：临时重定向，与302的含义类似，但307要求浏览器不会把重定向请求的POST改为GET方法。</p>
</li>
</ul>
</li>
<li><p>4XX 客户端错误</p>
<ul>
<li><p>400 Bad Request：请求报文中存在语法错误</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有认证信息（BASIC认证、DIGEST认证）。如果之前进行过一次请求，则表示用户认证失败。</p>
</li>
<li><p>403 Forbidden：请求被拒绝</p>
</li>
<li><p>404 Not Found</p>
</li>
</ul>
</li>
<li><p>5XX 服务器错误</p>
<ul>
<li><p>500 Internal Server Error：服务器正在执行请求时发生错误</p>
</li>
<li><p>503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="103、服务器出现大量close-wait的连接的原因是什么？有什么解决办法？"><a href="#103、服务器出现大量close-wait的连接的原因是什么？有什么解决办法？" class="headerlink" title="103、服务器出现大量close_wait的连接的原因是什么？有什么解决办法？"></a>103、服务器出现大量close_wait的连接的原因是什么？有什么解决办法？</h2><p>CLOSE_WAIT状态实在TCP四次挥手时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量CLOSE_WAIT状态的原因有两种：</p>
<ul>
<li><p>服务器内部业务处理占用了很多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</p>
</li>
<li><p>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致Socket的引用不为0无法回收。</p>
</li>
</ul>
<p>处理方法：</p>
<ul>
<li><p>停止应用程序</p>
</li>
<li><p>修改程序里的BUG</p>
</li>
</ul>
<hr>
<h2 id="104、一台机器能够使用的端口号上限是多少，是否可以修改？如果象要用的端口超过这个限制怎么办？"><a href="#104、一台机器能够使用的端口号上限是多少，是否可以修改？如果象要用的端口超过这个限制怎么办？" class="headerlink" title="104、一台机器能够使用的端口号上限是多少，是否可以修改？如果象要用的端口超过这个限制怎么办？"></a>104、一台机器能够使用的端口号上限是多少，是否可以修改？如果象要用的端口超过这个限制怎么办？</h2><p>0-65535，因为TCP报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同的端口号</p>
<p>因此TCP可供识别的端口号最多只有65536个。<br>但是由于0-1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>对于服务器来说，可以开的端口与65536无关，其实受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置</p>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/02/25/network/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/02/25/network/";
            const title         = "「计算机网络」";
            const excerpt       = `计算机网络1、OSI七层模型、功能
物理层：物理标准【比特】

数据链路层：定义数据的基本格式，如何传输，如何标识【帧】

网络层：IP、分组转发【包】

传输层：TCP、UDP，端到端传输【数据段】

会话层：控制应用程序之间会话
...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a>
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-03-30</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" MySQL" href="/2022/02/22/MySQL/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" dp" href="/2022/02/25/dp/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/Ru.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">人间归离复归离，借一浮生逃浮生</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E3%80%81%E5%8A%9F%E8%83%BD"><span class="toc-text">1、OSI七层模型、功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-text">2、完整的HTTP请求：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81DNS%E3%80%90%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E3%80%91"><span class="toc-text">3、DNS【域名系统】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E5%92%8CIP%E6%98%A0%E5%B0%84%EF%BC%8C%E4%B8%8D%E5%BF%85%E8%AE%B0%E4%BD%8F%E7%9B%AE%E6%A0%87%E5%9C%B0%E5%9D%80%E7%9A%84IP%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%AE%B0%E5%8A%A9%E8%AE%B0%E7%AC%A6"><span class="toc-text">域名和IP映射，不必记住目标地址的IP，而是可以记助记符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81DNS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4、DNS工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%94%A8UDP"><span class="toc-text">5、为什么域名解析用UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%8C%BA%E5%9F%9F%E4%BC%A0%E9%80%81%E4%BD%BF%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">6、区域传送使用TCP协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、HTTP长连接和短连接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8EHTTP-x2F-1-1%E8%B5%B7%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E7%94%A8%E4%BB%A5%E4%BF%9D%E6%8C%81%E8%BF%9E%E6%8E%A5%E7%89%B9%E6%80%A7%E3%80%82"><span class="toc-text">从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81TCP%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85%EF%BC%9F%E5%8F%91%E7%94%9F%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">8、TCP粘包&#x2F;拆包？发生原因？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">9、为什么服务器会缓存功能？如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">10、HTTP请求方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81GET%E5%92%8CPOST%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-text">11、GET和POST的请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%BA%94%E5%87%A0%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-text">12、一个TCP连接可以对应几个HTTP请求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E3%80%82"><span class="toc-text">如果长连接，一个TCP连接是可以对应多个HTTP请求的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%B8%ADHTTP%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%E5%90%97%EF%BC%88%E5%A6%82%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%E4%B8%89%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E4%B8%80%E8%B5%B7%E6%8E%A5%E5%8F%97%EF%BC%89%EF%BC%9F"><span class="toc-text">13、一个TCP连接中HTTP请求发送可以一起发送吗（如一起发送三个请求，在一起接受）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E5%90%8C%E4%B8%80-Host-%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%9A%84%E6%95%B0%E9%87%8F%E6%9C%89%E6%B2%A1%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-text">14、浏览器对同一 Host 建立TCP连接到的数量有没有限制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%9C%B0%E5%9D%80%E5%90%8E%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">15、在浏览器中输入URL地址后显示主页的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E8%83%8C%E5%90%8E%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-text">16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">17、DNS解析过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81DNS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">18、DNS负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81HTTPS%E5%92%8CHTTP%E5%8C%BA%E5%88%AB"><span class="toc-text">19、HTTPS和HTTP区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSSL-x2F-TLS%EF%BC%9F"><span class="toc-text">20、什么是SSL&#x2F;TLS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E9%83%BD%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%A7%98%E9%92%A5%E7%9A%84%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9A%E4%BC%98%E7%82%B9%E5%9C%A8%E4%BA%8E%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E6%95%88%E7%8E%87%E9%80%9A%E5%B8%B8%E8%BE%83%E9%AB%98%EF%BC%8Chttps%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%EF%BC%8C%E5%85%AC%E9%92%A5%E5%85%AC%E5%BC%80%E3%80%82"><span class="toc-text">加密和解密都使用一个秘钥的对称加密：优点在于加密解密效率通常较高，https是基于非对称加密的，公钥公开。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81HTTPS%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%EF%BC%8C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F%EF%BC%88SSL%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">21、HTTPS如何保证数据传输安全，整体流程？（SSL如何工作保证安全）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%AC%E9%92%A5%E4%B8%8D%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9F"><span class="toc-text">22、如何保证公钥不被篡改？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-text">23、HTTP请求和响应报文有哪些字段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81Cookie%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">24、Cookie是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81Cookie%E7%94%A8%E9%80%94%EF%BC%9F"><span class="toc-text">25、Cookie用途？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81Session%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-text">26、Session知识总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81Session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">27、Session 的工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%AF%8F%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%83%BD%E5%B8%A6%E7%9D%80Session-ID%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%BF%E5%88%B0Session-ID%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94Session%E5%8D%B3%E5%8F%AF"><span class="toc-text">客户端每次访问服务器时都带着Session ID，服务器拿到Session ID后，在内存中找到对应Session即可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81Cookie%E5%92%8CSession%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">28、Cookie和Session的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">29、SQL注入攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD"><span class="toc-text">30、网络的七层模型和各自功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%A5"><span class="toc-text">略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRARP%EF%BC%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">31、什么是RARP？工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81%E7%AB%AF%E5%8F%A3%E6%9C%89%E6%95%88%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="toc-text">32、端口有效范围？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B0%86TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-text">33、为何要将TCP&#x2F;IP协议栈分层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81DNS%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">34、DNS查询方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81HTTP%E4%B8%AD%E7%BC%93%E5%AD%98%E7%9A%84%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E6%9C%89%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-text">35、HTTP中缓存的私有和公有字段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81GET%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%86%99%E6%B3%95%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">36、GET方法参数写法固定的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B3%EF%BC%9A%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E7%BA%A6%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%83%BD%E8%A7%A3%E9%87%8A%E5%87%BA%E6%9D%A5%E5%8D%B3%E5%8F%AF"><span class="toc-text">即：我们可以自己约定参数的写法，只要服务端能解释出来即可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81GET%E6%96%B9%E6%B3%95%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-text">37、GET方法的长度限制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E5%9B%A0%EF%BC%9A%E5%A4%84%E7%90%86%E9%95%BFURL%E8%A6%81%E6%B6%88%E8%80%97%E8%BE%83%E5%A4%9A%E8%B5%84%E6%BA%90%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E5%92%8C%E5%AE%89%E5%85%A8%EF%BC%88%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E6%9E%84%E9%80%A0%E9%95%BFURL%E6%9D%A5%E6%94%BB%E5%87%BB%EF%BC%89%E8%80%83%E8%99%91%EF%BC%8C%E4%BC%9A%E7%BB%99URL%E9%95%BF%E5%BA%A6%E5%8A%A0%E9%99%90%E5%88%B6%E3%80%82"><span class="toc-text">服务器原因：处理长URL要消耗较多资源，为了性能和安全（防止恶意构造长URL来攻击）考虑，会给URL长度加限制。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81POST%E6%96%B9%E6%B3%95%E6%AF%94GET%E6%96%B9%E6%B3%95%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">38、POST方法比GET方法安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B3%E8%A6%81%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%8A%A0%E5%AF%86%EF%BC%8C%E5%8D%B3HTTPS"><span class="toc-text">想要安全传输，只有加密，即HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81POST%E6%96%B9%E6%B3%95%E4%BA%A7%E7%94%9F%E4%B8%A4%E4%B8%AATCP%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9F"><span class="toc-text">39、POST方法产生两个TCP数据包？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0%EF%BC%9Aheader%E5%92%8Cbody%E5%88%86%E5%BC%80%E5%8F%91%E9%80%81%E6%98%AF%E9%83%A8%E5%88%86%E6%B5%8F%E8%A7%88%E5%99%A8%E6%88%96%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%B1%9E%E4%BA%8Epost%E5%BF%85%E7%84%B6%E8%A1%8C%E4%B8%BA%E3%80%82"><span class="toc-text">综上所述：header和body分开发送是部分浏览器或框架的请求方法，不属于post必然行为。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81Session%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE26"><span class="toc-text">40、Session是什么？ —— 参见条目26</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%A5-1"><span class="toc-text">略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81%E4%BD%BF%E7%94%A8Session%E7%9A%84%E8%BF%87%E7%A8%8B-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE26-x2F-27"><span class="toc-text">41、使用Session的过程 —— 参见条目26&#x2F;27</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%A5-2"><span class="toc-text">略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81Session%E5%92%8CCookie%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%9F"><span class="toc-text">42、Session和Cookie应该如何选择（适用场景）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">43、Cookie和Session的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81DDos%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">44、DDos攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81MTU%E5%92%8CMSS%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">45、MTU和MSS分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81HTTP%E4%B8%AD%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E6%9C%80%E6%96%B0%EF%BC%9F"><span class="toc-text">46、HTTP中缓存机制，如何保证缓存最新？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81TCP%E5%A4%B4%E9%83%A8%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-text">47、TCP头部中有哪些信息？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">48、常见的TCP连接状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%83%E5%B1%82-x2F-%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">49、网络的七层&#x2F;五层协议有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81TCP%EF%BC%9F"><span class="toc-text">50、TCP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81TCP%E5%A4%B4%E9%83%A8%E6%8A%A5%E6%96%87%E5%AD%97%E6%AE%B5%EF%BC%9F%E5%90%84%E8%87%AA%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">51、TCP头部报文字段？各自功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81OSI%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">52、OSI的七层模型主要功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">53、应用层常见协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E4%BA%86%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%90%8E%E6%98%AF%E5%90%A6%E4%BC%9A%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%E6%96%AD%E5%BC%80%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%96%AD%E5%BC%80%EF%BC%9F"><span class="toc-text">54、浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%BC%9A%E6%96%AD%E5%BC%80%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%9C%A8%E8%AF%B7%E6%B1%82%E6%8A%A5%E5%A4%B4%E5%A3%B0%E6%98%8EConnection-close%E6%89%8D%E4%BC%9A%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">默认情况下建立TCP连接不会断开，只有在请求报头声明Connection: close才会在请求完成后关闭连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-text">55、三次握手相关内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%EF%BC%9F"><span class="toc-text">56、为什么要三次握手，两次不行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">57、什么是半连接队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58%E3%80%81ISN%EF%BC%88Initial-Sequence-Number%EF%BC%89%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">58、ISN（Initial Sequence Number）是固定的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="toc-text">59、三次握手过程可以携带数据吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60%E3%80%81SYN%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">60、SYN攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-text">61、四次挥手相关内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8socket-%E7%BC%96%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BB%BB%E4%BD%95%E4%B8%80%E6%96%B9%E6%89%A7%E8%A1%8Cclose-%E6%93%8D%E4%BD%9C%E5%8D%B3%E5%8F%AF%E4%BA%A7%E7%94%9F%E6%8C%A5%E6%89%8B%E5%8A%A8%E4%BD%9C%E3%80%82"><span class="toc-text">在socket()编程中，任何一方执行close()操作即可产生挥手动作。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E3%80%81%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-text">62、挥手为什么要四次？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%9F%E5%8F%AF%E8%83%BD%E8%A6%81%E5%8F%91%E9%80%81%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%8F%91%E9%80%81%E5%AE%8C%E6%AF%95%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8D%E8%83%BD%E5%8F%91%E9%80%81FIN%E6%8A%A5%E6%96%87%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%83%BD%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%EF%BC%8C%E6%95%85%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E3%80%82"><span class="toc-text">但服务器也可能要发送自己的数据，只有当服务器数据也发送完毕，服务器才能发送FIN报文，因此不能一起发送，故四次挥手。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E3%80%812MSL%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">63、2MSL等待状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E7%AD%89%E5%BE%852MSL%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-text">64、四次挥手释放连接时，等待2MSL的意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E8%A6%81%E7%BB%8F%E8%BF%872MSL%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9ECLOSED%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">65、为什么TIME_WAIT状态要经过2MSL才能返回CLOSED状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66%E3%80%81TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">66、TCP粘包问题？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67%E3%80%81OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%A1%A8%E7%A4%BA%E5%B1%82%E5%92%8C%E4%BC%9A%E8%AF%9D%E5%B1%82%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">67、OSI七层模型表示层和会话层功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E5%9B%9E%E6%94%B6%E5%8F%98%E8%BF%81%E5%9B%BE"><span class="toc-text">68、三次握手四次回收变迁图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69%E3%80%81%E5%AF%B9%E7%A7%B0%E7%A7%98%E9%92%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">69、对称秘钥加密的优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%A7%98%E9%92%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">70、非对称秘钥加密的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E3%80%81HTTPS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">71、HTTPS是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E3%80%81HTTP%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">72、HTTP缺点有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73%E3%80%81HTTPS%E9%87%87%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AF%B9%E7%A7%B0%E8%BF%98%E6%98%AF%E9%9D%9E%E5%AF%B9%E7%A7%B0%EF%BC%9F"><span class="toc-text">73、HTTPS采用的加密方式有哪些？对称还是非对称？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%8BSSL%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">74、为什么有时候刷新页面不需要重新建立SSL连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75%E3%80%81SSL%E4%B8%AD%E7%9A%84%E8%AE%A4%E8%AF%81%E4%B8%AD%E7%9A%84%E8%AF%81%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">75、SSL中的认证中的证书是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76%E3%80%81HTTP%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-text">76、HTTP如何禁用缓存？如何确认缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77%E3%80%81GET%E5%92%8CPOST%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E8%83%BD%E8%BE%BE%E5%88%B0%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">77、GET和POST传递数据的最大长度能达到多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">78、网络层常见协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79%E3%80%81TCP%E5%9B%9B%E5%A4%A7%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">79、TCP四大拥塞控制算法总结？（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E6%94%B6%E5%88%B0%E6%96%B0%E7%9A%84ACK%E6%97%B6%EF%BC%8C%E5%8D%B3ACK11%EF%BC%8C%E5%88%99%E9%80%80%E5%87%BA%E5%BF%AB%E6%81%A2%E5%A4%8D%E9%98%B6%E6%AE%B5%EF%BC%8C%E5%B0%86cwnd%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BD%93%E5%89%8D%E7%9A%84ssthresh%EF%BC%8C%E5%8D%B33%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E5%85%A5%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%E9%98%B6%E6%AE%B5"><span class="toc-text">当收到新的ACK时，即ACK11，则退出快恢复阶段，将cwnd重新设置为当前的ssthresh，即3，然后进入拥塞避免算法阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80%E3%80%81%E4%B8%BA%E4%BD%95%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%98%AF%E9%80%89%E6%8B%A93%E6%AC%A1ACK%EF%BC%9F"><span class="toc-text">80、为何快速重传是选择3次ACK？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%8C%E5%A6%82%E6%9E%9C%E4%BE%9D%E7%84%B6%E6%8E%A5%E6%94%B6%E5%88%B0Duplicated-ACK%EF%BC%8C%E5%88%99%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%99%8D%E9%80%9F%E5%90%88%E7%90%86%E3%80%82"><span class="toc-text">而如果依然接收到Duplicated ACK，则认为是网络拥塞造成的，此时降速合理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E3%80%81%E5%AF%B9%E4%BA%8EFIN-WAIT-2%EF%BC%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E5%92%8CTIME-WAIT%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">82、流量控制原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BTCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">建立TCP服务器的各个系统调用的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84%E3%80%81TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-text">84、TCP协议如何保证可靠传输？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85%E3%80%81UDP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">85、UDP是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86%E3%80%81%E5%B0%81%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%EF%BC%9F%E5%9F%BA%E4%BA%8ETCP%E8%BF%98%E6%98%AFUDP%EF%BC%9F"><span class="toc-text">86、封包和拆包？基于TCP还是UDP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86%E3%80%81TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">86、TCP和UDP的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87%E3%80%81UDP%E5%92%8CTCP%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">87、UDP和TCP的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88%E3%80%81TCP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">88、TCP对应的应用层协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89%E3%80%81UDP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">89、UDP对应的应用层协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">90、数据链路层常见协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E3%80%81Ping%E5%91%BD%E4%BB%A4%E5%9F%BA%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">91、Ping命令基于哪一层协议的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E5%91%BD%E4%BB%A4%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%98%AF%E5%9F%BA%E4%BA%8EICMP%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E7%9A%84%E3%80%82"><span class="toc-text">ping命令基于网络层的命令，是基于ICMP协议工作的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92%E3%80%81%E5%9C%A8%E8%BF%9B%E8%A1%8CUDP%E7%BC%96%E7%A8%8B%E6%97%B6%EF%BC%8C%E4%B8%80%E6%AC%A1%E5%8F%91%E9%80%81%E5%A4%9A%E5%B0%91Bytes%E5%A5%BD%EF%BC%9F"><span class="toc-text">92、在进行UDP编程时，一次发送多少Bytes好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%89%B4%E4%BA%8EInternet%E4%B8%8A%E6%A0%87%E5%87%86%E7%9A%84MTU%E5%80%BC%E4%B8%BA576%E5%AD%97%E8%8A%82%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%BB%BA%E8%AE%AE%E5%9C%A8%E8%BF%9B%E8%A1%8CInternet%E7%9A%84UDP%E7%BC%96%E7%A8%8B%E6%97%B6%EF%BC%8C%E6%9C%80%E5%A5%BD%E5%B0%86UDP%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%9C%A8548%E5%AD%97%E8%8A%82%EF%BC%88576-8-20%EF%BC%89%E4%BB%A5%E5%86%85%E3%80%82"><span class="toc-text">鉴于Internet上标准的MTU值为576字节，因此建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节（576-8-20）以内。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93%E3%80%81TCP%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">93、TCP利用滑动窗口实现流量控制的机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BRTO-x2F-RTT-x2F-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%9F"><span class="toc-text">94、解释一下RTO&#x2F;RTT&#x2F;超时重传？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95%E3%80%81XSS%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">95、XSS攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2XSS%E7%9A%84%E6%A0%B8%E5%BF%83%E6%98%AF%E5%BF%85%E9%A1%BB%E5%AF%B9%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%81%9A%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-text">防XSS的核心是必须对输入的数据做过滤处理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96%E3%80%81CSRF%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">96、CSRF攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83CSRF%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">97、如何防范CSRF攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">98、文件上传漏洞是如何发生的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E"><span class="toc-text">99、如何防范文件上传漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">100、拥塞控制原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E3%80%81%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">101、如何区分流量控制和拥塞避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E3%80%81%E5%B8%B8%E8%A7%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-text">102、常见HTTP状态码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-text">103、服务器出现大量close_wait的连接的原因是什么？有什么解决办法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104%E3%80%81%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%8A%E9%99%90%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%B1%A1%E8%A6%81%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%B6%85%E8%BF%87%E8%BF%99%E4%B8%AA%E9%99%90%E5%88%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">104、一台机器能够使用的端口号上限是多少，是否可以修改？如果象要用的端口超过这个限制怎么办？</span></a></li></ol></li></ol>
    </div>
</aside>
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.6em;">动态规划</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.8em;">数据库</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.6em;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.6em;">计算机网络</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/03/30/Git/"><i class="fa  fa-book"></i> Git</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/28/cppRest/"><i class="fa  fa-book"></i> cppRest</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/27/cpp11/"><i class="fa  fa-book"></i> cpp11</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/26/cppMemory/"><i class="fa  fa-book"></i> cppMemory</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/24/STL/"><i class="fa  fa-book"></i> STL</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/ReisenU"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@ReisenU"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/ReisenUx"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 月战老兵月球基地 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by ReisenU.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>




    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="7292006123"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>