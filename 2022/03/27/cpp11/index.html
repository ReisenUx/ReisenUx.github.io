<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>cpp11 | 月战老兵月球基地</title>
  <meta name="author" content="ReisenU" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="C++ 11新标准1. C++ 11有哪些新特性？ nullptr 替代 NULL  引入了auto 和 decltype 这两个关键字实现了类型推导  基于范围的 for 循环 for(auto &amp;i : res){}  类和结构体中的初始化列表  Lambda表达式（匿名函数）  std::forward_list（单向链表）  右值引用和move语义  …    2、auto、dec">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp11">
<meta property="og:url" content="http://example.com/2022/03/27/cpp11/index.html">
<meta property="og:site_name" content="月战老兵月球基地">
<meta property="og:description" content="C++ 11新标准1. C++ 11有哪些新特性？ nullptr 替代 NULL  引入了auto 和 decltype 这两个关键字实现了类型推导  基于范围的 for 循环 for(auto &amp;i : res){}  类和结构体中的初始化列表  Lambda表达式（匿名函数）  std::forward_list（单向链表）  右值引用和move语义  …    2、auto、dec">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2022-03-27T05:01:31.000Z">
<meta property="article:modified_time" content="2022-03-30T08:28:29.544Z">
<meta property="article:author" content="ReisenU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li><a href="/"><i class="fa fa-link"></i>链接</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">月战老兵月球基地</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>月战老兵月球基地</h2> <br />
                        <span>Lunar Capital</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">cpp11</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-03-27</li>
                <li><i class="fa fa-user"></i> 作者 ReisenU</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~10.59K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1648628909544"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-number">1.</span> <span class="toc-text">C++ 11新标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C-11%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1. C++ 11有哪些新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81auto%E3%80%81decltype%E5%92%8Cdecltype-auto-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">2、auto、decltype和decltype(auto)的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">4、智能指针的原理、常用的智能指针及实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%85%B3%E4%BA%8Elambda%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A8%E9%83%A8%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.</span> <span class="toc-text">5、关于lambda函数的全部知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">6、智能指针的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BA%86%E8%A7%A3%E7%9A%84auto-ptr%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">7、说说了解的auto_ptr作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">8、智能指针的循环引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%AE%9E%E9%99%85%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E6%8C%87%E5%90%91%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8F%AF%E9%81%BF%E5%85%8D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%BC%B1%E6%8C%87%E9%92%88weak-ptr%EF%BC%8C%E4%B8%8D%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%87%BA%E4%BA%86%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%87%AA%E5%8A%A8%E6%9E%90%E6%9E%84%E3%80%82"><span class="toc-number">1.8.</span> <span class="toc-text">在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针weak_ptr，不增加引用计数，只要出了作用域自动析构。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9、手写实现智能指针需要实现哪些函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10、智能指针出现循环引用如何解决？</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <h1 id="C-11新标准"><a href="#C-11新标准" class="headerlink" title="C++ 11新标准"></a>C++ 11新标准</h1><h2 id="1-C-11有哪些新特性？"><a href="#1-C-11有哪些新特性？" class="headerlink" title="1. C++ 11有哪些新特性？"></a>1. C++ 11有哪些新特性？</h2><ul>
<li><p>nullptr 替代 NULL</p>
</li>
<li><p>引入了auto 和 decltype 这两个关键字实现了类型推导</p>
</li>
<li><p>基于范围的 for 循环 for(auto &amp;i : res){}</p>
</li>
<li><p>类和结构体中的初始化列表</p>
</li>
<li><p>Lambda表达式（匿名函数）</p>
</li>
<li><p>std::forward_list（单向链表）</p>
</li>
<li><p>右值引用和move语义</p>
</li>
<li><p>…</p>
</li>
</ul>
<hr>
<h2 id="2、auto、decltype和decltype-auto-的用法"><a href="#2、auto、decltype和decltype-auto-的用法" class="headerlink" title="2、auto、decltype和decltype(auto)的用法"></a>2、auto、decltype和decltype(auto)的用法</h2><ol>
<li>auto<br>C++ 11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。<br>和原来哪些只对应某种特定类型的说明符（例如int）不同</li>
</ol>
<p><b>auto让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说auto定义的变量必须有初始值。</b></p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b; <span class="comment">// c 为 int 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const，会被忽略，所以j的类型是int【初始值】</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i;    <span class="comment">// 变量i是一个常量，对常量取地址是一种底层const，所以k的类型是const int*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> l = i;   <span class="comment">// 如果希望推断出的类型是顶层const，则需要手动在auto前加上const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用和指针类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">// z是int类型不是int&amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y;   <span class="comment">// p1是int&amp;类型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x;   <span class="comment">// p2是指针类型int*</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>decltype<br>有时候我们还会遇到这种情况：<br><b>我们希望从表达式中推断出要定义变量的类型，却不想用表达式的值去初始化变量。</b></li>
</ol>
<p>还有可能是函数的返回值为某表达式的值类型。<br>此时auto无能为力，所以C++11引入了第二种类型说明符decltype<br><b>它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值</b></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>())    sum = <span class="number">5</span>;    <span class="comment">// sum的类型是func()的返回值类型int，但此时不会实际调用func()</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>;  <span class="comment">// a的类型是int，所以b的类型也是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不论是顶层const还是底层const，decltype都会保留</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c;  <span class="comment">// d 的类型和c的类型是一样的，都是顶层const</span></span><br><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e;  <span class="comment">// f 是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f;  <span class="comment">// g 是底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用于指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型，则decltype的类型也是引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>;  <span class="comment">// k 的类型是 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型，但是想要得到这个引用所指向的类型，需要修改表达式：</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>;  <span class="comment">// 此时是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp; 类型，c和j绑定在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用，但是我们需要推断出引用，那么可以加上一对括号，就变成引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i;    <span class="comment">// 此时j的类型是int&amp;类型，j和i绑定在了一起</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>decltype(auto)<br>decltype(auto) 是 C++14 新增的类型指示符，可以用来声明变量以及指示函数返回类型。<br>在使用时，会将”&#x3D;”左侧的表达式替换掉auto，在根据decltype的语法规则来确定类型。</li>
</ol>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e;  <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;   <span class="comment">// j的类型是 const int* 并且指向的是e</span></span><br><span class="line"><span class="comment">// 相当于此处j替换了auto</span></span><br></pre></td></tr></table></figure>
<hr>
<ol start="3">
<li>C++中NULL和nullptr的区别<br>算是为了与C语言进行兼容而定义的一个问题</li>
</ol>
<p>NULL来自C语言，一般由宏定义实现，而nullptr则是C++11的新增关键字。<br><b>在C语言中，NULL被定义为(void*) 0，而在C++语言中，NULL则被定义为整数0。</b></p>
<p>编译器一般对其实际定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在C++中指针必须有明确的类型定义。<br>但是将NULL定义为0带来的一个问题是无法与整数的0区分。<br>因为C++中允许有函数重载，所以可以试想如下函数定义情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果: int</span></span><br></pre></td></tr></table></figure>

<p>那么在传入NULL参数时，会把NULL当做整数0来看，但如果想调用参数是指针的函数，如何解决？</p>
<p>nullptr在C++中被引入解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p>
<p>nullptr的一种实现方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> <span class="title class_">nullptr_t</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   <span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="type">const</span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">C</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="type">const</span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>&amp;() <span class="type">const</span>&#123;&#125;;</span><br><span class="line">&#125; <span class="literal">nullptr</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化，从而解决了（void）指针带来的参数类型不明问题</p>
<ul>
<li><p>另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆</p>
</li>
<li><p>但nullptr仍存在一些问题，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char* p&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int* p&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int p&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>((<span class="type">char</span>*) <span class="literal">nullptr</span>);   <span class="comment">// 语句1</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);   <span class="comment">// 语句2</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);      <span class="comment">// 语句3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 语句1：char* p</span></span><br><span class="line"><span class="comment">// 语句2：报错，有多个匹配</span></span><br><span class="line"><span class="comment">// 语句3：int p</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下存在对不同指针类型的函数重载，次数如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显式指明指针参数类型。</p>
</li>
</ul>
<hr>
<h2 id="4、智能指针的原理、常用的智能指针及实现"><a href="#4、智能指针的原理、常用的智能指针及实现" class="headerlink" title="4、智能指针的原理、常用的智能指针及实现"></a>4、智能指针的原理、常用的智能指针及实现</h2><ul>
<li><p>原理<br>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。<br>动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源。</p>
</li>
<li><p>常用的智能指针</p>
<ol>
<li>shared_ptr<br>  实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部引用计数加1<br>    每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动释放动态分配的资源。</li>
</ol>
<ul>
<li><p>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共多少个类对象共享一个指针</p>
</li>
<li><p>每次创建类的新对象时，初始化指针并将引用计数置为1</p>
</li>
<li><p>当对象作为另一个对象的副本而创建时，拷贝构造函数拷贝指针增加与之相应的引用计数</p>
</li>
<li><p>当一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（若引用计数减为0，则删除对象，并增加右操作数所指对象的引用计数。</p>
</li>
<li><p>调用析构函数时，构造函数减少引用计数（如果引用计数减为0，则删除基础对象）</p>
</li>
</ul>
<ol start="2">
<li>unique_ptr<br>  unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。</li>
</ol>
<p>  转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；<br>  所以unique_ptr不支持普通的拷贝的赋值操作，不能用在STL标准容器中；</p>
<p>  局部变量的返回值除外（因为编译器知道返回的对象将要被销毁）<br>  如果拷贝一个unique_ptr，那么拷贝结束后，两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p>
<ol start="3">
<li>weak_ptr<br>  weak_ptr：弱引用。<br>  引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。</li>
</ol>
<p>  需要使用weak_ptr打破环形引用。<br>  weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针<br>  它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，<code>只引用，不计数</code>。</p>
<p>  如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。<br>  所以weak_ptr不保证它所指向的内存一定是有效的<br>  在使用之前使用函数lock()检查weak_ptr是否为空指针。</p>
<ol start="4">
<li>auto_ptr<br>  主要是为了解决“有异常抛出时发生内存泄漏”的问题。因为发生异常，无法正常释放内存。<br>  【构造函数构造A&#x2F;B资源时候有一个失败，则其析构函数不会触发】</li>
</ol>
<p>  auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；<br>  而unique_ptr则无语义拷贝，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</p>
<p>  auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。<br>  STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</p>
</li>
<li><p>智能指针shared_ptr代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharedPtr</span>(T* ptr = <span class="literal">NULL</span>):_ptr(ptr), _pcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount)&#123; <span class="comment">// 复制构造函数</span></span><br><span class="line">        (*_pcount)++;</span><br><span class="line">    &#125;</span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr&amp; s)&#123;    <span class="comment">// 赋值运算符</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--(*(<span class="keyword">this</span>-&gt;_pcount)) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_pcount;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr = s._ptr;</span><br><span class="line">            _pcount = s._pcount;</span><br><span class="line">            *(_pcount)++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SharedPtr</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(--(*(<span class="keyword">this</span>-&gt;_pcount)) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            _ptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> _pcount;</span><br><span class="line">            _pcount = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="type">int</span>* _pcount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="5、关于lambda函数的全部知识"><a href="#5、关于lambda函数的全部知识" class="headerlink" title="5、关于lambda函数的全部知识"></a>5、关于lambda函数的全部知识</h2><ol>
<li><p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象。</p>
</li>
<li><p>每当定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称之为闭包类型（closure type）<br>那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。</p>
<p>所以，我们上面的lambda表达式的结果就是一个个闭包。<br>闭包的一个强大之处是其可以通过传值或者引用的方式捕捉器封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，称之为lambda捕捉块。</p>
</li>
<li><p>lambda表达式的语法定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters)<span class="keyword">mutable</span>-&gt;<span class="keyword">return</span>-type&#123;statement&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体。</p>
</li>
</ol>
<hr>
<h2 id="6、智能指针的作用"><a href="#6、智能指针的作用" class="headerlink" title="6、智能指针的作用"></a>6、智能指针的作用</h2><ol>
<li><p>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄漏（忘记释放）、二次释放、程序发生异常时内存泄漏等问题<br>使用智能指针可以更好地管理内存。</p>
</li>
<li><p>智能指针在C++11版本后提供，包含在头文件&lt; memory&gt;中，shared_ptr、unique_ptr、weak_ptr。<br>shared_ptr多个指针指向相同的对象，shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。<br>每使用他一次，内部的引用计数就会加1；每析构一次，内部的引用计数就会减1，减为0时，自动删除所指向的堆内存。<br>shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p>
</li>
<li><p>初始化<br>智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。<br>不能将指针直接赋值给一个智能指针，一个是类，一个是指针。</p>
<p>例如：std::stared_ptr<int> p4 &#x3D; new int(1);写法是错误的</p>
</li>
<li><p>拷贝和赋值<br>拷贝使得对象的引用计数+1，赋值使得原对象引用计数-1，当计数为0时，自动释放内存。<br>后来指向的对象引用计数+1，指向后来的对象。</p>
</li>
<li><p>unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。<br>相比于原始指针，unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。</p>
<p>unique_ptr指针本身的生命周期：<br>  从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象存在，则将其所指对象销毁（默认用delete操作符，用户可指定其他操作）</p>
<p>unique指针与其所指对象关系：<br>  在智能指针生命周期内，可以改变智能指针所指对象，<br>  如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权</p>
</li>
<li><p>智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。<br>每次创建类的新对象时，初始化指针并将引用计数置为1；<br>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；<br>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果减为0，则删除对象），并增加右操作数所指对象的引用计数；<br>调用析构函数时，构造函数减少引用计数（若引用计数减为0，则删除基础对象）</p>
</li>
<li><p>weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象<br>进行该对象的内存管理的是那个强引用的shared_ptr<br>weak_ptr只是提供了对管理对象的一个访问手段。<br>weak_ptr设计的目的是为了配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它置可以从一个shared_ptr或另外一个weak_ptr对象构造<br>它的构造和析构不会引起计数的增加或减少。</p>
</li>
</ol>
<hr>
<h2 id="7、说说了解的auto-ptr作用"><a href="#7、说说了解的auto-ptr作用" class="headerlink" title="7、说说了解的auto_ptr作用"></a>7、说说了解的auto_ptr作用</h2><ol>
<li><p>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；<br>抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏。</p>
</li>
<li><p>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。<br>我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身拥有的指针空间释放，所以不会有内存泄漏；</p>
</li>
<li><p>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的喜爱那个<br>必须要用auto_ptr的构造函数创建对象；</p>
</li>
<li><p>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一指针；</p>
</li>
<li><p>auto_ptr内部实现，析构函数中删除对象用的是delete而非delete[]，所以auto_ptr不能管理数组；</p>
</li>
<li><p>auto_ptr支持所拥有的指针类型之间的隐式类型转换；</p>
</li>
<li><p>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行操作</p>
</li>
<li><p>T* get()，获得auto_ptr所拥有的指针；<br>T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</p>
</li>
</ol>
<hr>
<h2 id="8、智能指针的循环引用"><a href="#8、智能指针的循环引用" class="headerlink" title="8、智能指针的循环引用"></a>8、智能指针的循环引用</h2><p>循环引用是指使用多个智能指针shared_ptr，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁<br>这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。</p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; value):_pPre(<span class="literal">nullptr</span>), _pNext(<span class="literal">nullptr</span>), _value(value)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt; &gt; _pPre;</span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt; &gt; _pNext;</span><br><span class="line">    T _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funtest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shared_ptr&lt;Node&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">    shared_ptr&lt;Node&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1-&gt;_pNext = sp2;  <span class="comment">// sp2的引用+1</span></span><br><span class="line">    sp2-&gt;_pPre = sp1;   <span class="comment">// sp1的引用+1</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Funtest</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Node()</span></span><br><span class="line"><span class="comment">// Node()</span></span><br><span class="line"><span class="comment">// sp1.use_count: 1</span></span><br><span class="line"><span class="comment">// sp2.use_count: 1</span></span><br><span class="line"><span class="comment">// sp1.use_count: 2</span></span><br><span class="line"><span class="comment">// sp2.use_count: 2</span></span><br></pre></td></tr></table></figure>

<p>从上面shared_ptr的实现中我们知道了只有当引用计数–之后等于0，析构时才会释放对象，而上述情况造成了一个僵局<br>那就是析构对象时限析构sp2，可是由于sp2的空间sp1还在使用中，所以sp2.use_count–后为1，不释放，<br>sp1也同理，由于sp1的空间sp2还在使用中，所以sp1.use_count–之后为1，也不释放。</p>
<p>sp1等着sp2先释放，sp2等着sp1先释放，二者互不谦让，导致最终都没能释放，内存泄漏。</p>
<h2 id="在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针weak-ptr，不增加引用计数，只要出了作用域自动析构。"><a href="#在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针weak-ptr，不增加引用计数，只要出了作用域自动析构。" class="headerlink" title="在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针weak_ptr，不增加引用计数，只要出了作用域自动析构。"></a>在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针weak_ptr，不增加引用计数，只要出了作用域自动析构。</h2><h2 id="9、手写实现智能指针需要实现哪些函数？"><a href="#9、手写实现智能指针需要实现哪些函数？" class="headerlink" title="9、手写实现智能指针需要实现哪些函数？"></a>9、手写实现智能指针需要实现哪些函数？</h2><ol>
<li><p>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还要提供自动垃圾回收机制。<br>他会自动记录SmartPointer&lt; T*&gt; 对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象</p>
<p>除了<code>指针对象</code>以外，还需要一个<code>引用计数的指针</code>设定对象的值，并将引用计数记为1，需要一个构造函数。<br>新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p>
<p>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p>
</li>
<li><p>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数</p>
</li>
</ol>
<hr>
<h2 id="10、智能指针出现循环引用如何解决？"><a href="#10、智能指针出现循环引用如何解决？" class="headerlink" title="10、智能指针出现循环引用如何解决？"></a>10、智能指针出现循环引用如何解决？</h2><p>弱指针weak_ptr专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不会影响对象的引用计数器。</p>
<p>循环引用即：<br>两个对象互相使用一个shared_ptr成员变量指向对方。<br>弱引用并不对对象的内存进行管理，在功能上类似普通指针，<br>然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/03/27/cpp11/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/03/27/cpp11/";
            const title         = "「cpp11」";
            const excerpt       = `C++ 11新标准1. C++ 11有哪些新特性？
nullptr 替代 NULL

引入了auto 和 decltype 这两个关键字实现了类型推导

基于范围的 for 循环 for(auto &amp;i : res){}

类...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-03-30</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" cppMemory" href="/2022/03/26/cppMemory/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" cppRest" href="/2022/03/28/cppRest/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/Ru.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">人间归离复归离，借一浮生逃浮生</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-text">C++ 11新标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C-11%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">1. C++ 11有哪些新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81auto%E3%80%81decltype%E5%92%8Cdecltype-auto-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">2、auto、decltype和decltype(auto)的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">4、智能指针的原理、常用的智能指针及实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%85%B3%E4%BA%8Elambda%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A8%E9%83%A8%E7%9F%A5%E8%AF%86"><span class="toc-text">5、关于lambda函数的全部知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">6、智能指针的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BA%86%E8%A7%A3%E7%9A%84auto-ptr%E4%BD%9C%E7%94%A8"><span class="toc-text">7、说说了解的auto_ptr作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">8、智能指针的循环引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%AE%9E%E9%99%85%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E6%8C%87%E5%90%91%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8F%AF%E9%81%BF%E5%85%8D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%BC%B1%E6%8C%87%E9%92%88weak-ptr%EF%BC%8C%E4%B8%8D%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%8C%E5%8F%AA%E8%A6%81%E5%87%BA%E4%BA%86%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%87%AA%E5%8A%A8%E6%9E%90%E6%9E%84%E3%80%82"><span class="toc-text">在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针weak_ptr，不增加引用计数，只要出了作用域自动析构。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">9、手写实现智能指针需要实现哪些函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">10、智能指针出现循环引用如何解决？</span></a></li></ol></li></ol>
    </div>
</aside>
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.6em;">动态规划</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.8em;">数据库</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.6em;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.6em;">计算机网络</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/03/30/Git/"><i class="fa  fa-book"></i> Git</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/28/cppRest/"><i class="fa  fa-book"></i> cppRest</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/27/cpp11/"><i class="fa  fa-book"></i> cpp11</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/26/cppMemory/"><i class="fa  fa-book"></i> cppMemory</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/24/STL/"><i class="fa  fa-book"></i> STL</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/ReisenU"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@ReisenU"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/ReisenUx"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 月战老兵月球基地 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by ReisenU.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>




    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="7292006123"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>