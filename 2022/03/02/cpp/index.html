<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>cpp | 月战老兵月球基地</title>
  <meta name="author" content="ReisenU" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="C++相关知识，非原创">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp">
<meta property="og:url" content="http://example.com/2022/03/02/cpp/index.html">
<meta property="og:site_name" content="月战老兵月球基地">
<meta property="og:description" content="C++相关知识，非原创">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2022-03-02T12:40:57.000Z">
<meta property="article:modified_time" content="2022-03-30T08:28:29.535Z">
<meta property="article:author" content="ReisenU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li><a href="/"><i class="fa fa-link"></i>链接</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">月战老兵月球基地</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>月战老兵月球基地</h2> <br />
                        <span>Lunar Capital</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">cpp</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-03-02</li>
                <li><i class="fa fa-user"></i> 作者 ReisenU</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~73.64K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1648628909535"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">一、基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1、在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">2、结构体内存对齐问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">3、指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9C%A8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">5、堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">6、栈快一点还是堆快一点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7、区别以下指针类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81new-x2F-delete-%E5%92%8C-malloc-x2F-free%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.8.</span> <span class="toc-text">8、new&#x2F;delete 和 malloc&#x2F;free的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.9.</span> <span class="toc-text">9、new和delete是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81malloc-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10、malloc 和 new 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86malloc-x2F-free%EF%BC%8Cc-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81new-x2F-delete%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">11、既然有了malloc&#x2F;free，c++中为什么还需要new&#x2F;delete？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12、被free回收的内存是立即返还给操作系统吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13、宏定义和函数有何区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">14、宏定义和typedef的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">15、变量声明和定义区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81stelen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">16、stelen和sizeof的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">17、常量指针和指针常量的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81a%E5%92%8C-amp-a%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">18、a和&amp;a有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81C-%E5%92%8CPython%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.</span> <span class="toc-text">19、C++和Python区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81C-%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.</span> <span class="toc-text">20、C++和C语言的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81C-%E4%B8%8EJava%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text">21、C++与Java的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.22.</span> <span class="toc-text">22、C++中struct和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.23.</span> <span class="toc-text">23、define宏定义和const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81C-%E4%B8%ADconst%E5%92%8Cstatic%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.24.</span> <span class="toc-text">24、C++中const和static的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81C-%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">1.25.</span> <span class="toc-text">25、C++的顶层const和底层const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%BA%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">26、数组名和指针（这里为指向数组首元素的指针）区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81final%E5%92%8Coverride%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.27.</span> <span class="toc-text">27、final和override关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.28.</span> <span class="toc-text">28、拷贝初始化和直接初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.29.</span> <span class="toc-text">29、初始化和赋值的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81extern%E2%80%9DC%E2%80%9D%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.30.</span> <span class="toc-text">30、extern”C”的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.31.</span> <span class="toc-text">31、野指针和悬空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81C%E5%92%8CC-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.32.</span> <span class="toc-text">32、C和C++的类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E5%92%8C%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.33.</span> <span class="toc-text">33、C++中的重载、重写（覆盖）和隐藏的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81C-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.34.</span> <span class="toc-text">34、C++有哪几种构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.35.</span> <span class="toc-text">35、浅拷贝和深拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.36.</span> <span class="toc-text">36、内联函数和宏定义的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81public-x2F-protected-x2F-private%E8%AE%BF%E9%97%AE%E5%92%8Cpublic-x2F-protected-x2F-private%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.37.</span> <span class="toc-text">37、public&#x2F;protected&#x2F;private访问和public&#x2F;protected&#x2F;private继承权限的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number">1.38.</span> <span class="toc-text">38、如何用代码判断大小端存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81volatile%E3%80%81mutable%E5%92%8Cexplicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.39.</span> <span class="toc-text">39、volatile、mutable和explicit关键字的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.40.</span> <span class="toc-text">40、什么情况下会调用拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81C-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8Bnew"><span class="toc-number">1.41.</span> <span class="toc-text">41、C++有几种类型new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.42.</span> <span class="toc-text">42、C++的异常处理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81static%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">43、static的用法和作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.44.</span> <span class="toc-text">44、指针和const的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.45.</span> <span class="toc-text">45、形参和实参的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%95%88%E7%8E%87"><span class="toc-number">1.46.</span> <span class="toc-text">46、值传递、指针传递、引用传递的区别和效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.47.</span> <span class="toc-text">47、静态变量什么时候初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.48.</span> <span class="toc-text">48、const关键字的作用有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">1.49.</span> <span class="toc-text">49、什么是类的继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E4%BB%8E%E6%B1%87%E7%BC%96%E5%B1%82%E5%8E%BB%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%BC%95%E7%94%A8"><span class="toc-number">1.50.</span> <span class="toc-text">50、从汇编层去解释一下引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E8%80%83%E6%9D%A1%E7%9B%AE35"><span class="toc-number">1.51.</span> <span class="toc-text">51、深拷贝和浅拷贝？ —— 参考条目35</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81new%E5%92%8Cmalloc%E5%8C%BA%E5%88%AB%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E8%80%83%E6%9D%A1%E7%9B%AE10"><span class="toc-number">1.52.</span> <span class="toc-text">52、new和malloc区别？ —— 参考条目10</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81delete-p%E3%80%81delete-p%E3%80%81allocator%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.53.</span> <span class="toc-text">53、delete p、delete []p、allocator都有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">1.54.</span> <span class="toc-text">54、new和delete的实现原理，delete是如何知道释放内存大小的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81malloc%E7%94%B3%E8%AF%B7%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E8%83%BD%E7%94%A8delete%E9%87%8A%E6%94%BE%E5%90%97%EF%BC%9F"><span class="toc-number">1.55.</span> <span class="toc-text">55、malloc申请的存储空间能用delete释放吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81malloc%E5%92%8Cfree%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.56.</span> <span class="toc-text">56、malloc和free的实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81malloc%E3%80%81realloc%E3%80%81calloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.57.</span> <span class="toc-text">57、malloc、realloc、calloc的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58%E3%80%81%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.58.</span> <span class="toc-text">58、类成员初始化方式？构造函数执行顺序？为什么用成员初始化列表快一些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E7%94%A8%E5%88%B0%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.59.</span> <span class="toc-text">59、有哪些情况必须用到成员列表初始化？作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60%E3%80%81C-%E4%B8%AD%E6%96%B0%E5%A2%9E%E4%BA%86string%EF%BC%8C%E5%AE%83%E4%B8%8EC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.60.</span> <span class="toc-text">60、C++中新增了string，它与C语言中的char *有什么区别吗？如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95%EF%BC%8C%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%89%A9%E5%B1%95%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%A6%E5%A4%96%E7%94%B3%E8%AF%B7%E4%B8%80%E5%9D%97%E5%8E%9F%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F2%E5%80%8D%E7%9A%84%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E6%BA%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E8%BF%87%E5%8E%BB%EF%BC%8C%E5%B9%B6%E5%8A%A0%E4%B8%8A%E6%96%B0%E5%A2%9E%E5%86%85%E5%AE%B9%E3%80%82"><span class="toc-number">1.61.</span> <span class="toc-text">  string 可以进行自动扩展，在每次扩展的时候另外申请一块原空间大小2倍的空间，然后将源字符串拷贝过去，并加上新增内容。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E3%80%81%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%92%8C%E9%81%BF%E5%85%8D"><span class="toc-number">1.62.</span> <span class="toc-text">61、什么是内存泄漏、如何检测和避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">1.63.</span> <span class="toc-text">62、对象复用的了解、零拷贝的了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E3%80%81%E4%BB%8B%E7%BB%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.64.</span> <span class="toc-text">63、介绍面向对象的三大特性，并举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E3%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%AE%83%E4%BC%9A%E5%BF%AB%E4%B8%80%E7%82%B9-%E2%80%94%E2%80%94-%E5%8F%82%E8%80%83%E6%9D%A1%E7%9B%AE58"><span class="toc-number">1.65.</span> <span class="toc-text">64、成员初始化列表的概念，为什么用它会快一点 —— 参考条目58</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E3%80%81C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2reinterpret-cast-x2F-const-cast-x2F-static-cast-x2F-dynamic-cast"><span class="toc-number">1.66.</span> <span class="toc-text">65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66%E3%80%81C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B"><span class="toc-number">1.67.</span> <span class="toc-text">66、C++函数调用的压栈过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%87%BD%E6%95%B0%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%94%A8%E6%99%AE%E9%80%9Areturn%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87%E4%BC%A0%E5%9B%9E%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%9B%E8%A1%8C%EF%BC%8C%E5%8D%B3%E5%9C%B0%E5%9D%80-x2F-%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%82"><span class="toc-number">1.68.</span> <span class="toc-text">当函数有多个返回值时，不能用普通return方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67%E3%80%81%E5%86%99C-%E4%BB%A3%E7%A0%81%E6%97%B6%E6%9C%89%E4%B8%80%E7%B1%BB%E9%94%99%E8%AF%AF%E6%98%AFcoredump%EF%BC%8C%E5%B8%B8%E8%A7%81%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%EF%BC%9F"><span class="toc-number">1.69.</span> <span class="toc-text">67、写C++代码时有一类错误是coredump，常见，如何调试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68%E3%80%81%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.70.</span> <span class="toc-text">68、移动构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69%E3%80%81C-%E4%B8%AD%E5%B0%86%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.71.</span> <span class="toc-text">69、C++中将临时变量做返回值的处理过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E5%8D%B3%E5%8F%AF"><span class="toc-number">1.72.</span> <span class="toc-text">如果需要返回值，一般使用赋值语句即可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%BB%93%E6%9E%84%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E8%8A%82%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.73.</span> <span class="toc-text">70、如何获得结构成员相对于结构开头的字节偏移量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">1.74.</span> <span class="toc-text">71、静态类型和动态类型，静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E3%80%81%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.75.</span> <span class="toc-text">72、引用是否能实现动态绑定，为什么可以实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B3%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E6%89%8D%E6%9C%89%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E9%87%87%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.76.</span> <span class="toc-text">即：虚函数才有动态绑定，采用虚函数情况下，使用的是动态绑定对象的虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.77.</span> <span class="toc-text">73、全局变量和局部变量有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74%E3%80%81%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.78.</span> <span class="toc-text">74、指针加减计算要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-number">1.79.</span> <span class="toc-text">75、如何判断两个浮点数相等？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E8%AF%AF%E5%B7%AE%E5%B0%8F%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E7%94%A8-x3D-x3D"><span class="toc-number">1.80.</span> <span class="toc-text">要误差小于某个特定的值，不能直接用&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E6%A0%88%E3%80%81%E6%B1%87%E7%BC%96%EF%BC%89"><span class="toc-number">1.81.</span> <span class="toc-text">76、方法调用的原理（栈、汇编）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77%E3%80%81C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E4%B8%8E%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.82.</span> <span class="toc-text">77、C++中的指针参与传递和引用参数传递有什么区别？底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78%E3%80%81%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">1.83.</span> <span class="toc-text">78、类如何实现只能静态分配和只能动态分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79%E3%80%81%E5%A6%82%E6%9E%9C%E6%83%B3%E5%B0%86%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BD%9C%E5%9F%BA%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E8%80%8C%E9%9D%9E%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="toc-number">1.84.</span> <span class="toc-text">79、如果想将某个类用作基类，为什么该类必须定义而非声明？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80%E3%80%81%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.85.</span> <span class="toc-text">80、继承机制中对象之间如何转换？指针和引用之间如何转换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E3%80%81C-%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8C%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.86.</span> <span class="toc-text">81、C++中的组合，和继承相比缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.87.</span> <span class="toc-text">82、函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83%E3%80%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8F%8A%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="toc-number">1.88.</span> <span class="toc-text">83、内存对齐及原因。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">1.89.</span> <span class="toc-text">84、结构体变量比较是否相等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E5%93%AA%E4%B8%AA%E5%85%88%E5%85%A5%E6%A0%88%EF%BC%9F"><span class="toc-number">1.90.</span> <span class="toc-text">85、函数调用过程栈的变化，返回值和参数变量哪个先入栈？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86%E3%80%81define%E3%80%81const%E3%80%81typedef%E3%80%81inline%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.91.</span> <span class="toc-text">86、define、const、typedef、inline的使用方法？他们之间的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87%E3%80%81printf%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.92.</span> <span class="toc-text">87、printf的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AAh%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.93.</span> <span class="toc-text">88、为什么模板类一般都是放在一个h文件中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89%E3%80%81C-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE37"><span class="toc-number">1.94.</span> <span class="toc-text">89、C++中类成员的访问权限和继承权限问题 —— 参见条目37</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90%E3%80%81cout-%E5%92%8C-printf-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.95.</span> <span class="toc-text">90、cout 和 printf 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush%E7%AB%8B%E5%8D%B3%E5%BC%BA%E8%BF%AB%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8Cprintf%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%89%E8%BE%93%E5%87%BA%E6%97%B6%E7%AB%8B%E5%8D%B3%E8%BE%93%E5%87%BA%E3%80%82"><span class="toc-number">1.96.</span> <span class="toc-text">flush立即强迫缓冲输出，printf是无缓冲输出，有输出时立即输出。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E3%80%81%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.97.</span> <span class="toc-text">91、重载运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92%E3%80%81%E5%BD%93%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.98.</span> <span class="toc-text">92、当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93%E3%80%81%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE15"><span class="toc-number">1.99.</span> <span class="toc-text">93、定义和声明的区别 —— 参见条目15</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">1.100.</span> <span class="toc-text">有变量、函数的声明和定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8Cstatic%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.101.</span> <span class="toc-text">94、全局变量和static变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.102.</span> <span class="toc-text">95、静态成员与普通成员的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96%E3%80%81ifdef%E5%92%8Cendif%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.103.</span> <span class="toc-text">96、ifdef和endif代表什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97%E3%80%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.104.</span> <span class="toc-text">97、隐式转换，如何消除隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98%E3%80%81C-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.105.</span> <span class="toc-text">98、C++如何处理多个异常的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="toc-number">1.106.</span> <span class="toc-text">99、如何在不使用额外空间的情况下，交换两个数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100%E3%80%81strcpy%E5%92%8Cmemcpy%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.107.</span> <span class="toc-text">100、strcpy和memcpy的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E3%80%81%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8Cint-main-int-argc-char-argc-%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.108.</span> <span class="toc-text">101、程序在执行int main(int argc, char *argc[])时的内存结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE39"><span class="toc-number">1.109.</span> <span class="toc-text">102、volatile关键字的作用 —— 参见条目39</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103%E3%80%81%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.110.</span> <span class="toc-text">103、如果有一个空类，它会默认添加哪些函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104%E3%80%81C-%E4%B8%AD%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.111.</span> <span class="toc-text">104、C++中标准库是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105%E3%80%81const-char-%E5%92%8C-string%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.112.</span> <span class="toc-text">105、const char* 和 string之间的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E7%94%A8%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">1.113.</span> <span class="toc-text">106、什么情况用指针参数，什么时候用引用参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107%E3%80%81%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E7%85%A7%E6%9D%A1%E7%9B%AE71"><span class="toc-number">1.114.</span> <span class="toc-text">107、静态绑定和动态绑定？ —— 参照条目71</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E4%BB%85%E5%8D%95%E4%B8%AA%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0"><span class="toc-number">1.115.</span> <span class="toc-text">108、如何设计一个计算仅单个子类的对象个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#109%E3%80%81%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">1.116.</span> <span class="toc-text">109、如何快速定位错误出现的地方？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B-%E2%80%94%E2%80%94-%E5%8F%82%E7%85%A7%E6%9D%A1%E7%9B%AE59"><span class="toc-number">1.117.</span> <span class="toc-text">110、初始化成员列表什么时候用？调用过程 —— 参照条目59</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%9F%BA%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E7%B1%BB%EF%BC%8C%E6%8C%89%E7%85%A7%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.118.</span> <span class="toc-text">引用、常量、基类、成员类，按照类中定义顺序执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111%E3%80%81%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%A0%E9%80%92%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E6%88%96%E8%80%85%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">1.119.</span> <span class="toc-text">111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4strcpy%E3%80%81sprintf%E5%92%8Cmemcpy%E8%BF%99%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">1.120.</span> <span class="toc-text">112、说一说strcpy、sprintf和memcpy这三个函数的不同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113%E3%80%81%E5%B0%86%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">1.121.</span> <span class="toc-text">113、将引用作为函数参数好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.122.</span> <span class="toc-text">114、指针和数组的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-number">1.123.</span> <span class="toc-text">115、如何组织一个类被实例化？有哪些办法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116%E3%80%81%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.124.</span> <span class="toc-text">116、如何禁止程序自动生成拷贝构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#117%E3%80%81Debug%E5%92%8Crelease%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.125.</span> <span class="toc-text">117、Debug和release的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118%E3%80%81main%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9C%89%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E8%80%83%E7%A9%B6%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="toc-number">1.126.</span> <span class="toc-text">118、main函数的返回值有什么值得考究之处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-int-args-char-argv-%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E3%80%82%E5%8F%82%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E4%B8%80%E8%88%AC%E4%BC%9A%E8%B0%83%E7%94%A8getopt-%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%EF%BC%8C%E4%BD%86%E5%AE%9E%E8%B7%B5%E4%B8%AD%EF%BC%8C%E8%BF%99%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E4%B8%8D%E4%BC%9A%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E3%80%82"><span class="toc-number">1.127.</span> <span class="toc-text">  main(int args, char **argv)参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#119%E3%80%81%E6%A8%A1%E6%9D%BF%E7%B1%BB%EF%BC%9F%E5%86%99%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">1.128.</span> <span class="toc-text">119、模板类？写一个比较大小模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%BE%80%E5%BE%80%E9%9C%80%E8%A6%81%E5%AF%B9%E4%BA%8E-gt-%E5%8F%B7%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%87%8F-%EF%BC%9B"><span class="toc-number">1.129.</span> <span class="toc-text">这个时候往往需要对于 &gt; 号进行重载，代码量++；</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#120%E3%80%81strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.130.</span> <span class="toc-text">120、strcpy函数和strncpy函数的区别？哪个函数更安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121%E3%80%81static-cast%E6%AF%94C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BC%BA%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.131.</span> <span class="toc-text">121、static_cast比C语言中的转换强在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122%E3%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8Cmemset-this-0-sizeof-this-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.132.</span> <span class="toc-text">122、成员函数里memset(this, 0, sizeof(*this))会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.133.</span> <span class="toc-text">123、回调函数？作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">1.134.</span> <span class="toc-text">124、一致性哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%9D%87%E8%A1%A1%EF%BC%8C%E5%B9%B3%E8%A1%A1%E6%80%A7%E6%8F%90%E9%AB%98"><span class="toc-number">1.135.</span> <span class="toc-text">这样数据分布均衡，平衡性提高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125%E3%80%81C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.136.</span> <span class="toc-text">125、C++从代码到可执行程序经历了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#126%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.137.</span> <span class="toc-text">126、友元函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="toc-number">1.138.</span> <span class="toc-text">127、友元函数和友元类的基本情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128%E3%80%81%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0C-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.139.</span> <span class="toc-text">128、使用C语言实现C++的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129%E3%80%81%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91"><span class="toc-number">1.140.</span> <span class="toc-text">129、动态编译和静态编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#130%E3%80%81hello-c%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.141.</span> <span class="toc-text">130、hello.c程序的编译过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131%E3%80%81%E6%BA%90%E4%BB%A3%E7%A0%81-gt-%E9%A2%84%E5%A4%84%E7%90%86-gt-%E7%BC%96%E8%AF%91-gt-%E4%BC%98%E5%8C%96-gt-%E6%B1%87%E7%BC%96-gt-%E9%93%BE%E6%8E%A5-gt-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.142.</span> <span class="toc-text">131、源代码 -&gt; 预处理 -&gt; 编译 -&gt; 优化 -&gt; 汇编 -&gt; 链接 -&gt; 可执行文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132%E3%80%81%E7%BB%8F%E5%85%B8%E7%9A%84%E9%94%81"><span class="toc-number">1.143.</span> <span class="toc-text">132、经典的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#133%E3%80%81delete%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.144.</span> <span class="toc-text">133、delete和delete[]的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%99%E6%88%90%E5%86%85%E8%81%94%EF%BC%9F"><span class="toc-number">1.145.</span> <span class="toc-text">134、为什么不能把所有的函数写成内联？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.146.</span> <span class="toc-text">135、为什么C++没有垃圾回收机制？</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <h1 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h1><h2 id="1、在main执行之前和之后执行的代码可能是什么？"><a href="#1、在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、在main执行之前和之后执行的代码可能是什么？"></a>1、在main执行之前和之后执行的代码可能是什么？</h2><blockquote>
<ol>
<li>main函数执行之前，主要就是初始化系统相关资源：</li>
</ol>
<ul>
<li>设置栈指针</li>
<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型<code>short,int,long</code>赋为<code>0</code>，<code>bool</code>为<code>false</code>，<code>pointer</code>为<code>nullptr</code>，即<code>.bss</code>段内容</li>
<li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数<code>argc,argv</code>等传递给<code>main</code>函数，然后运行main函数</li>
<li><strong>attribute</strong>((constructor))</li>
</ul>
<ol start="2">
<li>main函数执行之后</li>
</ol>
<ul>
<li>全局对象的析构函数会在main函数之后执行</li>
<li>可以用<code>atexit</code>注册一个函数，它会在main之后执行</li>
<li><strong>attribute</strong>((destructor))</li>
</ul>
</blockquote>
<hr>
<h2 id="2、结构体内存对齐问题"><a href="#2、结构体内存对齐问题" class="headerlink" title="2、结构体内存对齐问题"></a>2、结构体内存对齐问题</h2><blockquote>
<ul>
<li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。【首地址】</li>
<li>未特殊说明时，按照结构体中size最大的成员对齐。（若有double，则8字节对齐）</li>
</ul>
</blockquote>
<p>c++11以后引入两个关键字<code>alignof</code>和<code>alignas</code>，其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式<br>但是<code>alignas</code>在某些情况下是不能使用的</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>alignas能使用的例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> a;</span><br><span class="line">    <span class="type">uint16_t</span> b;</span><br><span class="line">    <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl; <span class="comment">// 6: 2+2+2（字节）</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;<span class="comment">// 2字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Info2&#123;</span><br><span class="line">    <span class="type">uint8_t</span> a;</span><br><span class="line">    <span class="type">uint16_t</span> b;</span><br><span class="line">    <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info2) &lt;&lt; std::endl;    <span class="comment">// 8: 4+4（字节）</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info2) &lt;&lt; std::endl;   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><code>alignas</code>将内存对齐调整为4字节<br>∴<code>sizeof(Info2)</code>的值变为了8</p>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>alignas不能使用的例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> a;</span><br><span class="line">    <span class="type">uint32_t</span> b;</span><br><span class="line">    <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl; <span class="comment">// 12: 4+4+4（字节）</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">2</span>) Info2&#123;</span><br><span class="line">    <span class="type">uint8_t</span> a;</span><br><span class="line">    <span class="type">uint32_t</span> b;</span><br><span class="line">    <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info2) &lt;&lt; std::endl; <span class="comment">// 12: 4+4+4（字节）</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info2) &lt;&lt; std::endl; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>若<code>alignas</code>小于自然对齐的最小单位，则会被忽略</p>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>单字节对齐方式</span></div>
    <div class="xContent"><div class="inner">
        <p>用上述方式来看，使用单字节对齐方式，使用<code>alignas</code>是无效的，应该使用<code>#pragma pack(push, 1)</code>或者<code>__attribute__((packed))</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> a;</span><br><span class="line">    <span class="type">uint32_t</span> b;</span><br><span class="line">    <span class="type">uint8_t</span> c;</span><br><span class="line">&#125; ONEBYTE_ALIGN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl; <span class="comment">// 6 1 + 4 + 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;<span class="comment">// 6</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>确定结构体每个元素大小【`alignas`处理不了的情况】</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> a : <span class="number">1</span>; <span class="comment">// 1bit</span></span><br><span class="line">    <span class="type">uint16_t</span> b : <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint16_t</span> c : <span class="number">3</span>;</span><br><span class="line">    <span class="type">uint16_t</span> d : <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint16_t</span> e : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> pad : <span class="number">7</span>;</span><br><span class="line">&#125; ONEBYTE_ALIGN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 0 1   3     6   8 9            15</span></span><br><span class="line"><span class="comment">* +-+---+-----+---+-+-------------+</span></span><br><span class="line"><span class="comment">* | |   |     |   | |             |</span></span><br><span class="line"><span class="comment">* |a| b |  c  | d |e|     pad     |</span></span><br><span class="line"><span class="comment">* | |   |     |   | |             |</span></span><br><span class="line"><span class="comment">* +-+---+-----+---+-+-------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;     <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<hr>
<h2 id="3、指针和引用的区别"><a href="#3、指针和引用的区别" class="headerlink" title="3、指针和引用的区别"></a>3、指针和引用的区别</h2><ul>
<li><p>指针是一个变量，存储的是一个地址，引用跟原来的变量本质上是同一个东西，是原变量的别名。</p>
</li>
<li><p>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</p>
</li>
<li><p>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用可以。</p>
</li>
<li><p>指针可以有多级，引用只能有一级</p>
</li>
<li><p>指针可以为空，引用不能为NULL并且在定义时必须初始化</p>
</li>
<li><p>指针在初始化后可以改变指向，而引用在初始化之后<b>不可再改变</b><br> （变量可以被引用为多次，但引用只能作为一个变量引用）</p>
</li>
<li><p>指针是具体变量，需要占用存储空间；引用本质是一个指针，同样会占4字节内存；</p>
</li>
<li><p>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；<br>指针声明和定义可以分开，可以先只声明指针变量而不初始化，等到用到时再指向具体变量。</p>
</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>测试指针和引用1</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">test</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">nullptr</span>)    cout &lt;&lt; <span class="string">&quot;指针p为NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 0x22ff44 1</span></span><br><span class="line"><span class="comment">// 指针p为NULL</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>测试指针和引用2</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPTR</span><span class="params">(<span class="type">int</span>* p)</span></span>&#123;   <span class="comment">// 只是改动了形参的指向，实参没有变，相当于两个参数都指向一个地址，但本身不同。</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testREF</span><span class="params">(<span class="type">int</span>&amp; p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *b = &amp;a;</span><br><span class="line">    <span class="built_in">testPTR</span>(b);  <span class="comment">// 改变指针指向，但是没有改变指针所指的内容</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; *b &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">testREF</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<p>在编译器看来，int a &#x3D; 10; int &amp;b &#x3D; a; 等价于：int * const b &#x3D; &amp;a; 而 b &#x3D; 20; 等价于 *b &#x3D; 20;<br>自动转换为指针和自动解引用。</p>
<hr>
<h2 id="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用？"><a href="#4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用？" class="headerlink" title="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用？"></a>4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用？</h2><ul>
<li><p>需要返回函数内部局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针。否则会内存泄漏，然而返回局部变量的引用是没有意义的。</p>
</li>
<li><p>对栈空间大小比较敏感（比如递归）的时候使用引用，使用引用传递<b>不需要创建临时变量</b>，开销要更小。</p>
</li>
<li><p>类对象作为参数传递时使用引用，这是C++类对象传递的标准方式。</p>
</li>
</ul>
<hr>
<h2 id="5、堆和栈的区别"><a href="#5、堆和栈的区别" class="headerlink" title="5、堆和栈的区别"></a>5、堆和栈的区别</h2><ul>
<li>申请方式不同：<ul>
<li>栈由系统自动分配</li>
<li>堆是程序员进行申请和释放的</li>
</ul>
</li>
<li>申请大小限制不同：<ul>
<li>栈顶和栈底是预先设计好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改</li>
<li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整</li>
</ul>
</li>
<li>申请效率不同。<ul>
<li>栈由系统分配，速度快，不会有碎片。</li>
<li>堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
</li>
<li>空间大小不同：<ul>
<li>栈空间默认是4M</li>
<li>堆区一般是1-4G</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">堆</th>
<th align="left">栈</th>
</tr>
</thead>
<tbody><tr>
<td align="left">管理方式</td>
<td align="left">堆中资源由程序员控制，容易mem. leak</td>
<td align="left">栈资源由编译器自动管理，无需手工控制</td>
</tr>
<tr>
<td align="left">内存管理机制</td>
<td align="left">系统有一个记录空间内存地址的链表，当系统收到程序申请时，遍历链表，寻找第一个空间大于申请空间的堆结点【首次适应算法】，删除空闲结点链表中的该节点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余部分重新放入空闲链表中）</td>
<td align="left">只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（链表和队列、不连续和连续空间区别）</td>
</tr>
<tr>
<td align="left">空间大小</td>
<td align="left">堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit系统理论上是4G），所以堆的空间比较灵活，比较大</td>
<td align="left">栈是一块连续的内存区域，大小是操作系统预定好的，Windows下栈大小是2M（也有1M，在编译时确定，VC中可设置）</td>
</tr>
<tr>
<td align="left">碎片空间</td>
<td align="left">对于堆，频繁的new&#x2F;delete会造成大量碎片，使程序效率降低</td>
<td align="left">对于栈，它是有点类似于数据结构上的一个先进后出的栈，进入一一对应，不会产生碎片。【栈和队列的区别】</td>
</tr>
<tr>
<td align="left">生长方向</td>
<td align="left">堆向上，向高地址方向增长。</td>
<td align="left">栈向下，向低地址方向增长。</td>
</tr>
<tr>
<td align="left">分配方式</td>
<td align="left">堆都是动态分配（没有静态分配的堆）</td>
<td align="left">栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td>
</tr>
<tr>
<td align="left">分配效率</td>
<td align="left">堆由C&#x2F;C++函数库提供，机制很复杂，所以堆的效率比栈低很多</td>
<td align="left">栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。</td>
</tr>
</tbody></table>
<hr>
<h2 id="6、栈快一点还是堆快一点"><a href="#6、栈快一点还是堆快一点" class="headerlink" title="6、栈快一点还是堆快一点"></a>6、栈快一点还是堆快一点</h2><blockquote>
<p>答：栈快一些<br>操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，而且有专门的指令执行，所以栈的效率较高也比较快。<br>堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存时需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
</blockquote>
<hr>
<h2 id="7、区别以下指针类型"><a href="#7、区别以下指针类型" class="headerlink" title="7、区别以下指针类型"></a>7、区别以下指针类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">p</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>int *p[10]表示指针数组，强调数组概念，是一个数组遍历，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p>
</li>
<li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，该数组大小是10。</p>
</li>
<li><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是 int * 类型的。</p>
</li>
<li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p>
</li>
</ul>
<blockquote>
<p>小总结：带括号的(*p)强调的是指针。</p>
</blockquote>
<hr>
<h2 id="8、new-x2F-delete-和-malloc-x2F-free的异同"><a href="#8、new-x2F-delete-和-malloc-x2F-free的异同" class="headerlink" title="8、new&#x2F;delete 和 malloc&#x2F;free的异同"></a>8、new&#x2F;delete 和 malloc&#x2F;free的异同</h2><p>相同点：</p>
<ul>
<li><p>都可以用于内存的动态申请和释放<br>不同点：</p>
</li>
<li><p>new&#x2F;delete是 C++ 运算符，malloc&#x2F;free是C&#x2F;C++语言标准库函数</p>
</li>
<li><p>new&#x2F;delete不需要库文件支持，malloc&#x2F;free需要库文件支持</p>
</li>
<li><p>new 自动计算要分配的空间大小，malloc需要手工计算</p>
</li>
<li><p>new 是类型安全的，malloc不是。例如：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">2</span>];    <span class="comment">//编译错误</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">double</span>));    <span class="comment">//编译无错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>new 调用名为 operator new 的标注库函数分配足够空间并调用相关对象的构造函数；<br>delete 对指针所指对象运行适当析构函数，然后通过调用名为 operator delete 的标准库函数释放该对象所用内存。<br>malloc&#x2F;free 没有相关调用</p>
</li>
<li><p>new 是封装了 malloc，直接free不会报错，但这只是释放内存，并不会析构对象。</p>
</li>
</ul>
<hr>
<h2 id="9、new和delete是如何实现的"><a href="#9、new和delete是如何实现的" class="headerlink" title="9、new和delete是如何实现的"></a>9、new和delete是如何实现的</h2><ul>
<li>new的实现过程：<br>首先调用名为operator new的标准库函数，分配足够大的空间为类型化的内存，以保存指定类型的一个对象；<br>接下来运行该类型的一个构造函数，用指定初始化构造对象；<br>最后返回指向新分配并构造后的对象的指针；</li>
<li>delete的实现过程：<br>对指针指向的对象运行适当的析构函数；<br>然后通过调用名为operator delete的标准库函数释放该对象所用内存。</li>
</ul>
<blockquote>
<p>小总结：new 和 delete 顺序是反过来的：分配内存-&gt;构造函数-&gt;提供指针-&gt;析构函数-&gt;释放内存</p>
</blockquote>
<hr>
<h2 id="10、malloc-和-new-的区别？"><a href="#10、malloc-和-new-的区别？" class="headerlink" title="10、malloc 和 new 的区别？"></a>10、malloc 和 new 的区别？</h2><ul>
<li><p>malloc&#x2F;free 是标准库函数，支持覆盖；new&#x2F;delete是运算符，不重载；</p>
</li>
<li><p>malloc&#x2F;free 仅仅分配&#x2F;回收内存空间，不具备调用构造函数和析构函数的功能。用malloc分配空间存储类的对象存在风险；<br>new&#x2F;delete 除了分配回收功能外，还会调用构造和析构函数</p>
</li>
<li><p>malloc&#x2F;free 返回的是 void 类型指针（必须进行类型转换），new&#x2F;delete返回的是具体类型指针。</p>
</li>
</ul>
<hr>
<h2 id="11、既然有了malloc-x2F-free，c-中为什么还需要new-x2F-delete？"><a href="#11、既然有了malloc-x2F-free，c-中为什么还需要new-x2F-delete？" class="headerlink" title="11、既然有了malloc&#x2F;free，c++中为什么还需要new&#x2F;delete？"></a>11、既然有了malloc&#x2F;free，c++中为什么还需要new&#x2F;delete？</h2><ul>
<li><p>malloc&#x2F;free 和 new&#x2F;delete都是用来申请内存和回收内存的。</p>
</li>
<li><p>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。<br>而malloc&#x2F;free是库函数，是已经编译的代码，所以不能吧构造和析构函数的功能强加给malloc&#x2F;free，所以new&#x2F;delete是必不可少的。</p>
</li>
</ul>
<hr>
<h2 id="12、被free回收的内存是立即返还给操作系统吗？"><a href="#12、被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="12、被free回收的内存是立即返还给操作系统吗？"></a>12、被free回收的内存是立即返还给操作系统吗？</h2><p>不是，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。<br>这样避免了频繁的系统调用，从而占用过多的系统资源。<br>同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<hr>
<h2 id="13、宏定义和函数有何区别？"><a href="#13、宏定义和函数有何区别？" class="headerlink" title="13、宏定义和函数有何区别？"></a>13、宏定义和函数有何区别？</h2><ul>
<li><p>宏在<code>编译时</code>完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；<br>函数调用在运行时需要跳转到具体调用函数。</p>
</li>
<li><p>宏定义属于在结构中插入代码，没有返回值；<br>函数调用具有返回值.</p>
</li>
<li><p>宏定义参数没有类型，不进行类型检查；<br>函数参数具有类型，需要检查类型。</p>
</li>
<li><p>宏定义不用在最后加分号。</p>
</li>
</ul>
<hr>
<h2 id="14、宏定义和typedef的区别？"><a href="#14、宏定义和typedef的区别？" class="headerlink" title="14、宏定义和typedef的区别？"></a>14、宏定义和typedef的区别？</h2><ul>
<li><p>宏主要用于定义常量及书写复杂的内容；<br>typedef主要用于定义类型别名。</p>
</li>
<li><p>宏替换发生在编译阶段之前，属于文本插入替换；<br>typedef是编译的一部分。</p>
</li>
<li><p>宏定义不检查类型；<br>typedef会检查数据类型。【因此typedef安全】</p>
</li>
<li><p>宏不是语句，不需要在最后加分号；<br>typedef是语句，要加分号标识结束。</p>
</li>
<li><p>注意对指针的操作，typedef char* p_char 和 #define p_char char* 差别巨大【例如同时定义多个变量】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* p_char;</span><br><span class="line">p_char a, b;  <span class="comment">// 两个指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> p_char chr*</span></span><br><span class="line">p_char a, b;  <span class="comment">// 一个指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="15、变量声明和定义区别？"><a href="#15、变量声明和定义区别？" class="headerlink" title="15、变量声明和定义区别？"></a>15、变量声明和定义区别？</h2><ul>
<li><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；<br>定义要在定义的地方为其分配存储空间。</p>
</li>
<li><p>相同变量可以在多处声明（外部变量 extern），但只能在一处定义。</p>
<blockquote>
<p>用extern声明外部变量<br>全局变量（外部变量）是在函数的外部定义的，其作用域为从变量的定义处开始，到本程序文件的末尾。<br>在此作用域内，全局变量可以为本文件中的各个函数所引用。<br>编译时将全局变量分配在静态存储区。<br>如果用extern声明全局变量，即扩展全局变量的作用域。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="16、stelen和sizeof的区别？"><a href="#16、stelen和sizeof的区别？" class="headerlink" title="16、stelen和sizeof的区别？"></a>16、stelen和sizeof的区别？</h2><ul>
<li><p>sizeof是运算符，不是函数，结果在编译时得到而非运行中获得；<br>strlen是字符处理的库函数</p>
</li>
<li><p>sizeof参数可以是任何数据的类型或数据（sizeof参数不退化）；<br>strlen的参数只能是字符指针且末尾是’\0’的字符串。</p>
</li>
<li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。【例如获得的是指针的大小，不是数组的大小】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sizeof</span>(str);  <span class="comment">// 取的是指针str的长度，是8【64位编译环境】</span></span><br><span class="line">  <span class="built_in">strlen</span>(str);  <span class="comment">// 取的是这个字符串的长度，不包括结尾的 \0。大小是4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>补充：一个指针占多少字节？<br>上例中，sizeof(str)的值为8，是在64位编译环境下的，指针的占用大小为8字节；<br>在32位环境下，指针占用大小为4字节。<br>一个指针占内存的大小跟编译环境有关，而与机器位数无关。</p>
</blockquote>
<hr>
<h2 id="17、常量指针和指针常量的区别？"><a href="#17、常量指针和指针常量的区别？" class="headerlink" title="17、常量指针和指针常量的区别？"></a>17、常量指针和指针常量的区别？</h2><ul>
<li><p>指针常量是一个指针，读成常量的指针<code>pointer to const</code>，指向一个只读变量，也就是后面所指明的 int const 和 const int，都是一个常量<br>可以写作 int const *p 或 const int *p。【这个 * 修饰的是变量p，const修饰int】</p>
</li>
<li><p>常量指针<code>const pointer</code>是一个不能改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（存放在指针中的地址）就不能再改变了<br>即不能中途改变指向，如int *const p。【这个 * 修饰的是int类型，const修饰指针】</p>
</li>
</ul>
<blockquote>
<p>小补充：volatile 可以允许用指针修改 const</p>
</blockquote>
<hr>
<h2 id="18、a和-amp-a有什么区别？"><a href="#18、a和-amp-a有什么区别？" class="headerlink" title="18、a和&amp;a有什么区别？"></a>18、a和&amp;a有什么区别？</h2><p>假设数组 int a[10]; int(*p)[10] &#x3D; &amp;a;<br>其中：</p>
<ul>
<li><p>a是数组名，是数组首元素地址，+1表示地址加上一个int类型的大小<br>如果a的值是0x00000001，加1操作后变为0x00000005；*(a+1) &#x3D; a[1]</p>
</li>
<li><p>&amp;a是数组的指针，其类型为 int(*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数据的偏移（10个int型变量）<br>值为数组a尾元素后一个元素的地址</p>
</li>
<li><p>若(int *)p，此时输出 *p 时，其值为a[0]的值，因为被转为 int * 类型，解引用时按照int类型大小来读取。</p>
</li>
</ul>
<hr>
<h2 id="19、C-和Python区别"><a href="#19、C-和Python区别" class="headerlink" title="19、C++和Python区别"></a>19、C++和Python区别</h2><p>包括但不限于：</p>
<ul>
<li><p>Python是一种脚本语言，是解释性语言；<br>C++是编译语言，是需要编译后在特定平台运行的。<br>Python可以很方便的跨平台，但效率没有C++搞。</p>
</li>
<li><p>Python使用缩进来区分不同代码块；<br>C++使用花括号来区分。</p>
</li>
<li><p>C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等。</p>
</li>
<li><p>Python的库函数比C++多，调用起来更方便。</p>
</li>
</ul>
<hr>
<h2 id="20、C-和C语言的区别"><a href="#20、C-和C语言的区别" class="headerlink" title="20、C++和C语言的区别"></a>20、C++和C语言的区别</h2><ul>
<li><p>C++中new&#x2F;delete是对内存分配的运算符，取代了C中的malloc&#x2F;free（库函数）</p>
</li>
<li><p>标准C++中的<code>字符串</code>取代了<br>标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）</p>
</li>
<li><p>C++中用来做控制台输入输出的<code>iostream</code>库取代了<br>标准C中的<code>stdio</code>函数库。</p>
</li>
<li><p>C++中的try&#x2F;catch&#x2F;throw异常处理机制取代了<br>标准C中的setjmp()&#x2F;longjmp()函数。</p>
</li>
<li><p>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来【函数重载】<br>在C语言中不允许。</p>
</li>
<li><p>C++语言中，允许变量定义语句在程序的任何地方，只要是在使用它之前就可以；<br>C语言中，必须要在函数的开头部分。【C和C++都不允许重复定义变量】</p>
</li>
<li><p>C++中，除了值和指针之外，新增了引用。引用型变量相当于别名。</p>
</li>
<li><p>C++相对于C增加了一些关键字，bool&#x2F;using&#x2F;dynamic_cast&#x2F;namespace等。</p>
</li>
</ul>
<hr>
<h2 id="21、C-与Java的区别"><a href="#21、C-与Java的区别" class="headerlink" title="21、C++与Java的区别"></a>21、C++与Java的区别</h2><ul>
<li><p><b>语言特性</b></p>
<ul>
<li><p>Java语言给开发人员提供了更为简洁的语法；<br>完全面对对象，由于JVM可以安装到任何操作系统上，所以说可移植性强。</p>
</li>
<li><p>Java语言中没有指针的概念，引入了真正的数组。<br>不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组。<br>同时将容易造成麻烦的指针从语言中去掉，<br>这有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。</p>
</li>
<li><p>C++也可以在其他操作系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行）<br>例如可能【Windows下大端存储，Unix下小端存储】<br>Java一般生成字节码，在JVM运行得到结果</p>
</li>
<li><p>Java用接口（Interface）技术取代C++程序中的抽象类。<br>接口与抽象类有相同的功能，但是省却了在实现和维护上的复杂性</p>
</li>
</ul>
</li>
<li><p><b>垃圾回收</b></p>
<ul>
<li>C++用析构函数回收垃圾，写C&#x2F;C++程序时一定要注意内存的申请和释放。</li>
<li>Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题。</li>
</ul>
</li>
<li><p><b>应用场景</b></p>
<ul>
<li><p>Java 在桌面程序上不如 C++ 实用，C++可以直接编译成exe文件，指针是C++的优势，可以直接对内存的操作，但同时具有危险性。<br>（操作内存十分危险，一旦指针位置出现错误，或者误删内存单元的重要数据，后果不堪设想）</p>
</li>
<li><p>Java在Web应用上具有C++无可比拟的优势，具有丰富多样的框架。</p>
</li>
<li><p>对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="22、C-中struct和class的区别"><a href="#22、C-中struct和class的区别" class="headerlink" title="22、C++中struct和class的区别"></a>22、C++中struct和class的区别</h2><ul>
<li><p><b>相同点</b></p>
<ul>
<li>两者都拥有成员函数、公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
</li>
<li><p><b>不同点</b></p>
<ul>
<li>两者中如果不对成员不指定公私有，struct默认是公有的，class默认是私有的。</li>
<li>class默认是private继承，struct默认是public继承</li>
</ul>
</li>
</ul>
<blockquote>
<p>C++和C的struct的区别</p>
<ul>
<li><p>C语言中：struct是用户自定义数据类型（UDT）；<br>C++中struct是抽象数据类型（ADT），支持成员函数的定义（C++中的struct能继承，能实现多态）</p>
</li>
<li><p>C++中struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p>
</li>
<li><p>struct作为类的一种特例是用来自定义数据结构的。<br>一个结构标记声明后，在C中必须在结构标记前加上struct才能做结构类型名（除了typedef struct class{};）【Struct Node】<br>C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外，结构体struct在C++中被当做类的一种特例。</p>
</li>
</ul>
</blockquote>
<hr>
<h2 id="23、define宏定义和const的区别"><a href="#23、define宏定义和const的区别" class="headerlink" title="23、define宏定义和const的区别"></a>23、define宏定义和const的区别</h2><ul>
<li><p><b>编译阶段</b><br>define是在编译的<code>预处理</code>阶段起作用【预处理，主要做其中的文本处理】<br>const是在编译、运行的时候起作用</p>
</li>
<li><p><b>安全性</b><br>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含全部内容<br>const常量有数据类型，编译器可以对其进行类型安全检查。</p>
</li>
<li><p><b>内存占用</b></p>
<ul>
<li><p>define只是将宏名称进行替换，在内存中会产生多份相同的备份。<br>const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放出常量表。</p>
</li>
<li><p>宏定义的数据没有分配内存空间，只是插入替换掉；<br>const定义的变量只是值不能改变，但要分配内存空间。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="24、C-中const和static的作用"><a href="#24、C-中const和static的作用" class="headerlink" title="24、C++中const和static的作用"></a>24、C++中const和static的作用</h2><ol>
<li><b>static</b></li>
</ol>
<ul>
<li><p>不考虑类的情况</p>
<ul>
<li><p>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块使用。</p>
</li>
<li><p>默认初始化为0。包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区。</p>
</li>
<li><p>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用。</p>
</li>
</ul>
</li>
<li><p>考虑类的情况</p>
<ul>
<li><p>static成员变量：只与类管理，不与类的对象关联。<br>定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标识为static；<br>可以被非static成员函数任意访问</p>
</li>
<li><p>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<br>不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问。</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><b>const</b></li>
</ol>
<ul>
<li><p>不考虑类的情况</p>
<ul>
<li><p>const 常量在定义时必须初始化，之后无法更改</p>
</li>
<li><p>const形参可以接收const和非const类型的实参，例如：void fun(const int&amp; i){}【实参可以是const也可以不是】</p>
</li>
</ul>
</li>
<li><p>考虑类的情况</p>
<ul>
<li>const成员变量：不能在类定义的外部初始化，只能通过构造函数<code>初始化列表</code>进行初始化，并且必须有构造函数；<br>不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li>
<li>const成员函数：const对象不可以调用非const成员函数；<br>非const对象都可以调用；<br>不可以改变非mutable数据的值</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充：mutable声明的变量可以在const成员函数中被修改</p>
</blockquote>
<hr>
<h2 id="25、C-的顶层const和底层const"><a href="#25、C-的顶层const和底层const" class="headerlink" title="25、C++的顶层const和底层const"></a>25、C++的顶层const和底层const</h2><p><b>概念区分</b></p>
<ul>
<li>顶层const：指的是const修饰的变量本身是一个常量，无法修改，值得是指针，就是 星号* 的右边</li>
<li>底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 星号* 的左边<br><b>例子</b><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="type">int</span> *<span class="type">const</span> b1 = &amp;a;   <span class="comment">// 顶层const，b1本身是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a; <span class="comment">// 底层const,b2本身可变，所指的对象是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>;  <span class="comment">// 顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a; <span class="comment">//前一个为底层，后一个是顶层，b4不可变。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;  <span class="comment">// 用于声明引用变量，都是底层const</span></span><br></pre></td></tr></table></figure>
<b>区分作用</b></li>
<li>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</li>
<li>使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *a;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> a;</span><br></pre></td></tr></table></figure></li>
<li>int const a 和 const int a均表示定义常量类型a。</li>
<li>const int *a、int const <em>a，其中a为指向int型变量的指针，const在</em>左侧，表示a指向不可变常量，（const (*a) ），对引用加const</li>
<li>int *const a，依旧是指针类型，表示a为指向整形数据的常指针。看成（const(a)，对指针const）</li>
</ul>
<hr>
<h2 id="26、数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#26、数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="26、数组名和指针（这里为指向数组首元素的指针）区别？"></a>26、数组名和指针（这里为指向数组首元素的指针）区别？</h2><ul>
<li><p>二者均可通过增减偏移量来访问数组中的元素</p>
</li>
<li><p>数组名不是真正意义上的指针，可以理解为<code>常指针</code>，所以数组名没有自增，自减等操作。</p>
</li>
<li><p><b>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作。</b><br>但sizeof运算符不能再得到原数组的大小了</p>
</li>
</ul>
<hr>
<h2 id="27、final和override关键字"><a href="#27、final和override关键字" class="headerlink" title="27、final和override关键字"></a>27、final和override关键字</h2><p><b>override</b><br>当在父类中使用了虚函数的时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用override，将foo()写成f00()时，编译器并不会报错，因为他不知道你想要重写虚函数。<br>因此多了一个f00()函数。<br>因此 —— override关键字：指定了子类的这个虚函数是重写父类的，如果名字打错编译是不会通过的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，编译器认为你这个是一个新的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f00</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// Error，加了override后，这个函数一定是继承自A的，若没有则报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><b>final</b><br>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字。<br>final关键字被继承或重写，编译器会报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> : A&#123;  <span class="comment">// final表明B是不可被继承的</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">//Error，A中的foo已经final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: B&#123; <span class="comment">// Error，B已经是final</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="28、拷贝初始化和直接初始化"><a href="#28、拷贝初始化和直接初始化" class="headerlink" title="28、拷贝初始化和直接初始化"></a>28、拷贝初始化和直接初始化</h2><ul>
<li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：<ol>
<li>直接初始化直接调用与实参匹配的构造函数；</li>
<li>拷贝初始化总是调用拷贝构造函数。<br>拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将哪个临时对象拷贝到正在创建的对象。<br>举例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>;   <span class="comment">// 语句1：直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;              <span class="comment">// 语句2：直接初始化，str1是已经存在的对象，直接调用拷贝构造函数进行初始化</span></span><br><span class="line">string str3 = <span class="string">&quot;I am a string&quot;</span>;  <span class="comment">// 语句3：拷贝初始化，先为后者创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span></span><br><span class="line">string str4 = str1;             <span class="comment">// 语句4：拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><b>为了提高效率，允许编译器跳过创建临时对象这一步</b>，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（1和3等价）<br>但两种情况要辨别，如果不考虑编译器的话，本质上是不同的。<ul>
<li>当拷贝构造函数为 private 时：语句3和4在编译时会产生错误</li>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错。</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充 explicit：修饰构造函数时，即可避免构造函数隐式类型转换</p>
</blockquote>
<hr>
<h2 id="29、初始化和赋值的区别"><a href="#29、初始化和赋值的区别" class="headerlink" title="29、初始化和赋值的区别"></a>29、初始化和赋值的区别</h2><ul>
<li>对于简单类型来说，初始化和赋值没什么区别</li>
<li>对于类和复杂数据类型来说，可以举例如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> num1, num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>):<span class="built_in">num1</span>(a), <span class="built_in">num2</span>(b)&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A &amp;a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  A&amp; <span class="keyword">operator</span> = (<span class="type">const</span> A &amp;a)&#123;</span><br><span class="line">    num1 = a.num1 + <span class="number">1</span>;</span><br><span class="line">    num2 = a.num2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  A a1 = a; <span class="comment">// 拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">  A b;</span><br><span class="line">  b = a;  <span class="comment">//赋值操作，对象a中，num1 = 1， num2 = 2；对象b中，num1 = 2, num2 = 2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="30、extern”C”的用法"><a href="#30、extern”C”的用法" class="headerlink" title="30、extern”C”的用法"></a>30、extern”C”的用法</h2><p>为了能够正确的在C++代码中调用C语言的代码：<br>在程序中加上extern”C”后，相当于告诉这个编译器这部分代码是C写的，要用C语言编译，而不是CPP；</p>
<p>使用extern”C”的情形：</p>
<ol>
<li>C++代码中调用C语言代码</li>
<li>在C++中的头文件中使用</li>
<li>在多人协同开发时，可能有人擅长C语言，有人CPP</li>
</ol>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#idndef __MY_HANDLE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_HANDLE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">result_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">my_handle_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">my_handle_t</span> <span class="title">create_handle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">result_t</span> <span class="title">operate_on_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上：<br><b>在C语言的头文件中，对其外部函数只能指定位extern类型</b><br><b>C语言中不支持extern”C”声明，在.c文件中包含了extern”C”时会出现编译语法错误。</b><br>所以，extern”C”全部都放在与 CPP 程序相关文件或头文件中。</p>
<p>总结：</p>
<ol>
<li><p>C++ 调用 C 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// xx.c</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xx.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C调用C++函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xx.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="31、野指针和悬空指针"><a href="#31、野指针和悬空指针" class="headerlink" title="31、野指针和悬空指针"></a>31、野指针和悬空指针</h2><p>都是指向无效内存区域（这里的无效指的是“不安全不可控”）的指针，访问行为将会导致未定义行为。</p>
<ul>
<li><p>野指针：没有被初始化过的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> *p; <span class="comment">// 未初始化</span></span><br><span class="line">  std::cout &lt;&lt; *p &lt;&lt; std::endl;   <span class="comment">//未初始化就能被使用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，为了防止出错，对于指针初始化时都是赋值为<code>nullptr</code>，这样在使用编译器就会直接报错，产生非法内存访问。</p>
</li>
<li><p>悬空指针：指针最初指向的内存已经被释放了的一种指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">  p = p2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> p2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。<br>需要设置：<code>p = p2 = nullptr</code>。否则，继续使用会导致编译器直接报错。【因此避免悬空指针比较麻烦】<br>C++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。</p>
</li>
</ul>
<blockquote>
<p>小总结：<br><b>产生原因及解决办法</b><br>野指针：指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。<br>悬空指针：指针free或delete后没有及时置空 &#x3D;&gt; 释放操作后立即置空。</p>
</blockquote>
<hr>
<h2 id="32、C和C-的类型安全"><a href="#32、C和C-的类型安全" class="headerlink" title="32、C和C++的类型安全"></a>32、C和C++的类型安全</h2><p><b>什么是类型安全？</b><br>类型安全很大程度上可以等价为内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。<br>“类型安全”常被用来形容编程语言，其根据在于该编程语言是否提供保障类型安全的机制；<br>“类型安全”也被用来形容某个程序，判别的标准在于该程序是否隐含类型错误。</p>
<p>类型安全的编程语言和程序之间没有必然联系。<br>看程序员的操作水平，相对安全的Language也可以写出不安全的程序，但没有绝对类型安全语言。</p>
<ol>
<li>C的类型安全：<br>C 只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换为另一种结构体的指针时，编译器会报告错误，除非显式类型转换。<br>然而，C中相当操作是不安全的，如下:<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>C不安全例子1</span></div>
    <div class="xContent"><div class="inner">
        <p>printf格式输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;整型输出：%d\n&quot;</span>, <span class="number">10</span>); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;浮点输出：%f\n&quot;</span>, <span class="number">10</span>); <span class="comment">// 0.0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，使用%d控制整型数字的输出，没有问题，但是改为%f时，输出错误【参考IEEE的浮点格式】<br>如果改成%s，运行直接报segmentation fault错误</p>
 
    </div></div>
    </div></li>
</ol>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>C不安全例子2</span></div>
    <div class="xContent"><div class="inner">
        <p>malloc函数的返回值</p>
<p>malloc 是 C 中进行内存分配的函数，它的返回类型是void<em>即空类型指针，常常有：<br>char</em> pStr &#x3D; (char*) malloc(100 * sizeof(char));<br>这里明显做了显式类型转换。</p>
<p>类型匹配尚且没有问题，但是一旦出现int* pInt &#x3D; (int*) malloc(100 * sizeof(char))就很可能出现一些问题，<br>这样的转换C并不会提示错误。</p>
 
    </div></div>
    </div>

<ol start="2">
<li>C++的类型安全<br>如果C++使用得当，它将远比C更有类型安全性。<br>相比于C语言，C++提供了一些新的机制保障类型安全：</li>
</ol>
<ul>
<li><p>操作符new返回的指针类型严格与对象匹配，而不是void*</p>
</li>
<li><p>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的</p>
</li>
<li><p>引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换</p>
</li>
<li><p>一些#define 宏可以被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</p>
</li>
<li><p>C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast设计更多具体的类型检查</p>
</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>使用void*进行类型转换</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="type">void</span> *pInt = &amp;i;</span><br><span class="line">  <span class="type">double</span> d = (*(<span class="type">double</span>*)pInt);</span><br><span class="line">  cout &lt;&lt; d &lt;&lt; endl;  <span class="comment">// 1.78416e-307</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>不同类型指针之间转换</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> : <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">Child1</span>(<span class="type">int</span> e):<span class="built_in">i</span>(e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> : <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">double</span> d;</span><br><span class="line">  <span class="built_in">Child2</span>(<span class="type">double</span> e):<span class="built_in">d</span>(e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Child1 <span class="title">c1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  <span class="function">Child2 <span class="title">c2</span><span class="params">(<span class="number">4.1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  Parent* pp;</span><br><span class="line">  Child1* pc1;</span><br><span class="line"></span><br><span class="line">  pp = &amp;c1;</span><br><span class="line">  pc1 = (Child1*) pp; <span class="comment">// 类型向下转换，强制转换，由于类型仍为Child1*，不造成错误</span></span><br><span class="line">  cout &lt;&lt; pc1-&gt;i &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  pp = &amp;c2;  </span><br><span class="line">  pc1 = (Child1*) pp; <span class="comment">// 强制转换，且类型发生变化，将造成错误</span></span><br><span class="line">  cout &lt;&lt; pc1-&gt;i &lt;&lt; endl; <span class="comment">// 1717986918</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<p>上述两个例子之所以引起类型不安全问题，是因为使用不得当。<br>例子1：只用了空类型指针void*；<br>例子2：在两个指针类型之间进行强制转换。</p>
<p>若想保证程序的类型安全性，应尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。</p>
<h2 id="33、C-中的重载、重写（覆盖）和隐藏的区别"><a href="#33、C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="33、C++中的重载、重写（覆盖）和隐藏的区别"></a>33、C++中的重载、重写（覆盖）和隐藏的区别</h2><ol>
<li><p>重载（Overload）<br>  重载是指在同一范围定义中的同名函数存在重载关系。<br>  特点：函数名相同、参数类型和数目不同。<br>  注意：仅仅依靠返回值区分不同的函数是不可取的。<br>  重载和成员函数是否是虚函数无关。</p>
  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>重载例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
</li>
<li><p>重写（覆盖）（Override）<br>  重写指的是在派生类中覆盖基类中的同名函数。<br>  重写就是重写函数体，<b>要求基类函数必须是虚函数</b>并且：</p>
<ul>
<li><p>与基类的虚函数有相同的参数个数</p>
</li>
<li><p>与基类的虚函数有相同的参数类型</p>
</li>
<li><p>与基类的虚函数有相同的返回值类型</p>
</li>
</ul>
</li>
</ol>
  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>重写例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;   <span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;   <span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span></span>&#123;&#125; <span class="comment">// 重写一般要加override来保证是重写父类的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【64位下虚函数表是8B】</p>
 
    </div></div>
    </div>

<p>  重载和重写的区别：<br>    * 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系<br>    * 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求<br>    * 重写关系中，调用方法根据对象类型决定；<br>      重载根据调用时实参表与形参表的对应关系来选择函数体。</p>
<ol start="3">
<li>隐藏（hide)<br>  隐藏指的是有些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</li>
</ol>
<ul>
<li><p>两个函数参数相同，但是基类函数不是虚函数。<b>和重写的区别在于基类函数是否是虚函数。</b><br>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A 中的 fun 函数&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B 中的 fun 函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">fun</span>(<span class="number">2</span>);   <span class="comment">// 调用B中的fun函数</span></span><br><span class="line">  b.A::<span class="built_in">fun</span>(<span class="number">2</span>);  <span class="comment">// 调用A中fun函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。<br>和重载的区别在于两个函数不在同一个类中，例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A 中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B 中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">// 报错，调用的是B中的fun函数，参数类型不对</span></span><br><span class="line">  b.A::<span class="built_in">fun</span>(<span class="number">2</span>);  <span class="comment">//调用A中的fun函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>补充</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is A fun&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is A add&quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;  <span class="comment">// 重写</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is B fun&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;  <span class="comment">// 隐藏，由于参数不同</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is B add&quot;</span> &lt;&lt; a + a &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span>* b)</span></span>&#123; <span class="comment">// 隐藏，重载</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is B add2&quot;</span> &lt;&lt; a + a &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过::调用到基类被覆盖的虚函数;</span></span><br><span class="line">  <span class="comment">// 基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。</span></span><br><span class="line"></span><br><span class="line">  A *p = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">  p-&gt;<span class="built_in">fun</span>(<span class="number">1</span>);  <span class="comment">// This is B fun 1</span></span><br><span class="line">  p-&gt;A::<span class="built_in">fun</span>(<span class="number">1</span>); <span class="comment">// This is A fun 1</span></span><br><span class="line">  p-&gt;<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// This is A add 3</span></span><br><span class="line">  <span class="comment">// p-&gt;add(1);   // Error，基类指针识别的是基类被隐藏函数，类型不匹配</span></span><br><span class="line">  <span class="comment">// p-&gt;B::add(1);  // Error，错误，无法识别子类add函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<h2 id="34、C-有哪几种构造函数"><a href="#34、C-有哪几种构造函数" class="headerlink" title="34、C++有哪几种构造函数"></a>34、C++有哪几种构造函数</h2><p>C++中的构造函数可以分为4类：</p>
<ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数和<code>参数列表</code>）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数</li>
<li>转换构造函数<br>例子：<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>构造函数分类</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Student</span>()&#123;   <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Student</span>(<span class="type">int</span> a, <span class="type">int</span> n): <span class="built_in">age</span>(a), <span class="built_in">num</span>(n)&#123;&#125; <span class="comment">// 初始化构造函数，有参数和参数列表</span></span><br><span class="line">  <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s)&#123;  <span class="comment">// 拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Student</span>(<span class="type">int</span> r)&#123; <span class="comment">// 转换构造函数，形参是其他类型变量，且只有一个形参</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Student s1;           <span class="comment">// 使用默认构造函数</span></span><br><span class="line">  <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>, <span class="number">1001</span>)</span></span>; <span class="comment">// 使用初始化构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;        <span class="comment">// 使用转换构造函数</span></span><br><span class="line">  <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;       <span class="comment">// 使用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s1 age: %d, num: %d\n&quot;</span>, s1.age, s1.num);  <span class="comment">// s1 age : 20, num : 1000</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s2 age: %d, num: %d\n&quot;</span>, s2.age, s2.num);  <span class="comment">// s2 age : 18, num : 1001</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s3 age: %d, num: %d\n&quot;</span>, s3.age, s3.num);  <span class="comment">// s3 age : 10, num : 1002</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s4 age: %d, num: %d\n&quot;</span>, s4.age, s4.num);  <span class="comment">// s4 age : 10, num : 1002</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></li>
<li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li>
<li>复制构造函数用于复制本类的对象</li>
<li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li>
</ul>
<hr>
<h2 id="35、浅拷贝和深拷贝的区别"><a href="#35、浅拷贝和深拷贝的区别" class="headerlink" title="35、浅拷贝和深拷贝的区别"></a>35、浅拷贝和深拷贝的区别</h2><ul>
<li><b>浅拷贝</b><br>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址<br>如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误</li>
<li><b>深拷贝</b><br>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放了内存也不会影响到深拷贝的值。<br>在自己实现拷贝赋值的时候，如果有指针变量的话还是要自己实现深拷贝的。</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>浅拷贝和深拷贝</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Student</span>()&#123;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Student</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~Student&quot;</span> &lt;&lt; &amp;name &lt;&lt; endl;  <span class="comment">// 指针的地址</span></span><br><span class="line">    <span class="keyword">delete</span> name;</span><br><span class="line">    name = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s)&#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 浅拷贝：对象的name和传入对象的name指向相同的地址</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;name = s.name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝，创建出一块新的内存空间给当前对象的name</span></span><br><span class="line">    <span class="comment">// name = new char(20);</span></span><br><span class="line">    <span class="comment">// memcpy(name, s.name, strlen(s.name));</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy Student&quot;</span> &lt;&lt; endl；</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123; <span class="comment">// 让s1和s2变成局部对象，方便测试</span></span><br><span class="line">      Student s1;</span><br><span class="line">      <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">// 复制对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝执行结果：</span></span><br><span class="line"><span class="comment">// Student</span></span><br><span class="line"><span class="comment">// copy Student</span></span><br><span class="line"><span class="comment">// ~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">// ~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">// *** Error in ......  由于内存两次delete</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝执行结果：</span></span><br><span class="line"><span class="comment">// Student</span></span><br><span class="line"><span class="comment">// copy Student</span></span><br><span class="line"><span class="comment">// ~Student 0x7fffebca9fb0</span></span><br><span class="line"><span class="comment">// ~Student 0x7fffebca9fc0</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>



<p>从执行结果可以看出：<br>浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，<br>深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>
<hr>
<h2 id="36、内联函数和宏定义的区别"><a href="#36、内联函数和宏定义的区别" class="headerlink" title="36、内联函数和宏定义的区别"></a>36、内联函数和宏定义的区别</h2><ul>
<li><p>在使用时，宏只做了简单字符串替换（编译前）。<br>内联函数可以进行参数类型检查（编译时），且具有返回值。</p>
</li>
<li><p>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率；<br>而且进行参数类型检查，具有返回值，可以实现重载</p>
</li>
<li><p>宏定义时要注意书写（参数要括起来），否则容易出现歧义，内联函数不会出现歧义</p>
</li>
<li><p>内联函数有类型检测、语法判断等，宏定义没有</p>
</li>
</ul>
<blockquote>
<p>内联函数适用场景：</p>
<ul>
<li><p>适用宏定义的地方都可以使用内联函数</p>
</li>
<li><p>作为类成员接口来读写类的私有成员或者保护成员可以提高效率</p>
</li>
</ul>
</blockquote>
<h2 id="37、public-x2F-protected-x2F-private访问和public-x2F-protected-x2F-private继承权限的区别"><a href="#37、public-x2F-protected-x2F-private访问和public-x2F-protected-x2F-private继承权限的区别" class="headerlink" title="37、public&#x2F;protected&#x2F;private访问和public&#x2F;protected&#x2F;private继承权限的区别"></a>37、public&#x2F;protected&#x2F;private访问和public&#x2F;protected&#x2F;private继承权限的区别</h2><ul>
<li><p>public 的变量和函数在类的内部和外部都可以使用</p>
</li>
<li><p>protected 的变量和函数只能在类的内部和其派生类中访问【protected是针对继承而言的】</p>
</li>
<li><p>private 修饰的元素只能在类内访问</p>
</li>
</ul>
<ol>
<li>访问权限<br>派生类可以继承基类中除了构造&#x2F;析构、赋值运算符重载函数之外的成员<br>但这些成员的访问属性在派生过程中也是可以调整的，访问权限如下：<br>【注意外部访问不是真正的外部访问，而是在<b>通过派生类的对象对基类成员的访问</b>】</li>
</ol>
<img src="/2022/03/02/cpp/PrivateProtectedPublic.png" class="" title="继承和访问权限对照表">

<p>派生类<b>对基类成员</b>的访问形象有如下两种：</p>
<ul>
<li>内部访问：由派生类中新增的成员函数对继承来的成员的访问</li>
<li><b>外部访问</b>：在派生类外部，通过派生类对象对继承来的成员的访问</li>
</ul>
<ol start="2">
<li>继承权限</li>
</ol>
<ul>
<li><p><b>public继承</b><br>公有继承的特点是：<br>  基类的<code>公有成员</code>和<code>保护成员</code>作为派生类的成员时，都<b>保持原有的状态</b><br>  基类的<code>私有成员</code>仍然是私有的，不能被这个派生类的子类所访问</p>
</li>
<li><p><b>protected继承</b><br>保护继承的特点是：<br>  基类的<code>公有成员</code>和<code>保护成员</code>都成为派生类的<b>保护成员</b>，并且只能被它的派生类成员函数或友元函数访问。<br>  基类的<code>私有成员</code>仍然是私有的，访问规则如下：</p>
<img src="/2022/03/02/cpp/ProtectedInherit.png" class="" title="保护继承">
</li>
<li><p><b>private继承</b><br>私有继承的特点是：<br>  基类的<code>公有成员</code>和<code>保护成员</code>都成为派生类的私有成员，并不被它的派生类的子类所访问，<br>  基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表：</p>
<img src="/2022/03/02/cpp/PrivateInherit.png" class="" title="私有继承"></li>
</ul>
<p>总结：</p>
<ol>
<li><p>访问权限</p>
<table>
<thead>
<tr>
<th align="left">访问权限</th>
<th align="left">外部</th>
<th align="left">派生类</th>
<th align="left">内部</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">×</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">private</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">√</td>
</tr>
</tbody></table>
</li>
<li><p>继承权限</p>
</li>
<li><p>派生类继承自基类的成员权限有四种状态：public、protected、private、不可见</p>
</li>
<li><p>派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限</p>
</li>
<li><p>派生类对基类成员的访问权限是取以上两点中的更小的访问范围（除了private继承方式遇到private成员是不可见）<br>例如：</p>
<ul>
<li>public 继承 + private 成员 &#x3D;&gt; private</li>
<li>private 继承 + protected 成员 &#x3D;&gt; private</li>
<li>private 继承 + private 成员 &#x3D;&gt; 不可见</li>
</ul>
</li>
</ol>
<h2 id="38、如何用代码判断大小端存储"><a href="#38、如何用代码判断大小端存储" class="headerlink" title="38、如何用代码判断大小端存储"></a>38、如何用代码判断大小端存储</h2><p>  大端存储：字数据的高字节存储在低地址中<br>  小端存储：字数据的低字节存储在低地址中</p>
<p>  例如：32bit数字0x12345678</p>
<ul>
<li><p>小端模式中的存储方式为：</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">0x4000</th>
<th align="left">0x4001</th>
<th align="left">0x4002</th>
<th align="left">0x4003</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存放内容</td>
<td align="left">0x78</td>
<td align="left">0x56</td>
<td align="left">0x34</td>
<td align="left">0x12</td>
</tr>
</tbody></table>
</li>
<li><p>大端模式中的存储方式为：</p>
<table>
<thead>
<tr>
<th align="left">内存地址</th>
<th align="left">0x4000</th>
<th align="left">0x4001</th>
<th align="left">0x4002</th>
<th align="left">0x4003</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存放内容</td>
<td align="left">0x12</td>
<td align="left">0x34</td>
<td align="left">0x56</td>
<td align="left">0x78</td>
</tr>
</tbody></table>
</li>
</ul>
<p>大端模式更贴近于人类的阅读习惯<br>小端模式更有利于计算机读取数据</p>
<p>如何在代码中判断大小端存储？</p>
<ol>
<li><p>判断大小端存储 —— 强制类型转换</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>强制类型转换</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0x1234</span>; <span class="comment">// 由于int和char的长度不同，借助int型转char类型，只会留下低地址部分</span></span><br><span class="line">  <span class="type">char</span> c = (<span class="type">char</span>) a;</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="number">0x12</span>) cout &lt;&lt; <span class="string">&quot;Big end&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="number">0x34</span>) cout &lt;&lt; <span class="string">&quot;Little end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
</li>
<li><p>判断大小端存储 —— 使用union联合体</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>使用union联合体</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">endian</span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  endian value;</span><br><span class="line">  value.a = <span class="number">0x1234</span>;</span><br><span class="line">  <span class="comment">// a 和 ch共用4字节的内存空间</span></span><br><span class="line">  <span class="keyword">if</span>(value.ch == <span class="number">0x12</span>)  cout &lt;&lt; <span class="string">&quot;Big endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">if</span>(value.ch == <span class="number">0x34</span>)  cout &lt;&lt; <span class="string">&quot;Little endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></li>
</ol>
<h2 id="39、volatile、mutable和explicit关键字的用法"><a href="#39、volatile、mutable和explicit关键字的用法" class="headerlink" title="39、volatile、mutable和explicit关键字的用法"></a>39、volatile、mutable和explicit关键字的用法</h2><ol>
<li>volatile<br>volatile 关键字是一种类型修饰符，<b>用它声明的类型变量表示可以被某些编译器位置的因素更改</b><br>例如：操作系统、硬件或者其他线程等。<br>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li>
</ol>
<p>当要求使用volatile声明的变量的值的时候，<b>系统总是重新从它所在的内存读取数据</b><br>即使它前面的指令刚刚从该处读取过数据。</p>
<p><b>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。<br>多线程中被几个任务共享的变量需要定义为volatile类型。</b></p>
<blockquote>
<p>注意：使用volatile定义常量的话，使用指针可以修改常量值。</p>
</blockquote>
<ul>
<li>volatile指针<br>volatile 指针和 const修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念。<ul>
<li><p>修饰由指针指向的对象、数据是const或volatile的：</p>
<blockquote>
<p>const char* cpch;<br>volatile char* vpch;</p>
</blockquote>
</li>
<li><p>指针自身的值 —— 一个代表地址的整数变量，是const或volatile的</p>
<blockquote>
<p>char* const pchc;<br>char* volatile pchv;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li><p>可以把一个非volatile int赋给volatile int，但是不能把非volatile<b>对象</b>赋给一个volatile对象</p>
</li>
<li><p>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰</p>
</li>
<li><p>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。<br>此外，volatile和const一样会从类传递到它的成员。</p>
</li>
</ul>
<p><b>多线程下的volatile</b><br>  有些变量是用volatile关键字声明的。<br>  当两个线程都要用到某一个变量且该变量的值会被改变时，应该使用volatile声明。<br>  <b>该关键字的作用是防止优化编译器将变量从内存装入CPU寄存器中</b>。<br>  如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，导致程序错误执行。<br>  volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用寄存器中现有的值。</p>
<ol start="2">
<li><p>mutable（可变的，易变的）<br>  和constant是反义词。<br>  C++中，mutable也是为了突破const的限制而设置的。<br>  被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。<br>  如果在类的成员函数不会不会改变对象的状态，则成员函数一般会声明为const。<br>  有些时候，<b>我们要在const函数里修改一些和状态无关的数据成员，则该函数就应该被mutable修饰，并且放在函数后面关键字位置。</b></p>
  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>样例</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> m_B;    <span class="comment">// 特殊对象，在常函数中也可以修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> <span class="type">const</span></span>&#123;   <span class="comment">// 在函数中不可以修改this指针指向的值，this变成指向常量的指针</span></span><br><span class="line">    m_A = <span class="number">10</span>; <span class="comment">// 错误，不可修改，this指向常量</span></span><br><span class="line">    m_B = <span class="number">20</span>; <span class="comment">// 正确，mutable修饰</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="type">int</span> m_A;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> m_B;  <span class="comment">// 特殊变量，在常函数中值也可以修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">const</span> Animal aa;</span><br><span class="line">  aa.m_A = <span class="number">10</span>;  <span class="comment">// 错误</span></span><br><span class="line">  aa.m_B = <span class="number">200</span>; <span class="comment">// 正确，由mutable 修饰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
</li>
<li><p>explicit<br>explicit 关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换。<br>只能<b>以显式的方式类型转换</b>，例如：</p>
</li>
</ol>
<ul>
<li>explicit 关键字只能用于类内部的<code>构造函数</code>声明上</li>
<li>explicit 关键字作用于单个参数的构造函数</li>
<li>被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
<hr>
<h2 id="40、什么情况下会调用拷贝构造函数"><a href="#40、什么情况下会调用拷贝构造函数" class="headerlink" title="40、什么情况下会调用拷贝构造函数"></a>40、什么情况下会调用拷贝构造函数</h2><ul>
<li>用类的一个实例化对象去初始化另一个对象的时候</li>
<li>函数的参数是类的对象时（非引用传递）</li>
<li>函数的返回值是函数体内局部对象的类的对象时，此时虽然发生（Named return Value 优化）NRV优化。<br>由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数。</li>
</ul>
<blockquote>
<p>其中：第三种情况在Linux g++下不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</p>
<p>总结：NRV优化情况下，Linux g++环境不管是返回值还是返回引用都不会发生拷贝构造函数。<br>     Windows VS2019在值返回情况下发生拷贝构造函数，引用返回方式则不会发生拷贝构造函数。</p>
</blockquote>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>VS2019下进行实验</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Copy constructor is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useClassA</span><span class="params">(A a)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getClassA</span><span class="params">()</span></span>&#123;  <span class="comment">// 此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span></span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">getClassA2</span><span class="params">()</span></span>&#123;  <span class="comment">// VS2019，编译器NRV优化，不调用拷贝构造函数</span></span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a1, a3, a4;</span><br><span class="line">  A a2 = a1;  <span class="comment">// 调用拷贝构造函数，用一个实例对象去初始化另一个对象</span></span><br><span class="line">  <span class="built_in">useClassA</span>(a1);  <span class="comment">// 调用拷贝构造函数，函数的参数是实例的对象</span></span><br><span class="line">  a3 = <span class="built_in">getClassA</span>(); <span class="comment">// 发生NRV优化，但是值返回，依然会有拷贝构造函数的调用，返回值是局部变量的情况下</span></span><br><span class="line">  a4 = <span class="built_in">getClassA2</span>();  <span class="comment">// 发生NRV优化，且引用返回自身，不会调用拷贝构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<blockquote>
<ol>
<li>一个实例对象去初始化另一个实例对象，调用拷贝构造函数</li>
<li>调用函数时，先根据传入实参产生临时对象，用拷贝构造函数初始化该临时对象，与形参对应</li>
<li>执行return，产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量再析构临时对象。</li>
</ol>
</blockquote>
<hr>
<h2 id="41、C-有几种类型new"><a href="#41、C-有几种类型new" class="headerlink" title="41、C++有几种类型new"></a>41、C++有几种类型new</h2><p>有 plain new&#x2F;nothrow new以及placement new</p>
<ol>
<li>plain new<br>  普通的new，即常用的new，定义如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span>  <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  因此 plain new 在空间分配失败的情况下，抛出异常std::bad_alloc而非nullptr，因此不能通过判断nullptr来判断是否分配成功<br>  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;ex)&#123;</span><br><span class="line">    cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;    <span class="comment">// bad allocation</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></p>
<ol start="2">
<li><p>nothrow new<br>  nothrow new 在空间分配失败的情况下不抛出异常，而是返回nullptr，定义如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothorw_t</span>&amp;)</span>  <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
</li>
<li><p>placement new<br>这种new允许在一块<b>已经分配成功的内存上</b>重新构造对象或对象数组。<br>placement new 不用担心内存分配失败，因为根本不分配内存，所做的唯一事情就是调用对象的构造函数。定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, <span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用placement new注意：</p>
<ul>
<li>placement new 的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或其数组</li>
<li>placement new 构造起来的对象数组，要显式地调用他们的析构函数来销毁（析构函数并不释放内存）<br>不能使用delete，因为placement new 构造起来的对象或数组大小并不一定等于原来分配的内存大小。<br>使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ADT</span>()&#123;</span><br><span class="line">    i = <span class="number">10</span>, j = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ADT construct i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">ADT</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow)  <span class="type">char</span>[<span class="keyword">sizeof</span> ADT + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ADT *q = <span class="built_in">new</span>(p) ADT;  <span class="comment">// placement new 只要p所指对象空间足够ADT创建即可</span></span><br><span class="line">  <span class="comment">// delete q —— 错误，不能在此处调用delete q;</span></span><br><span class="line">  q-&gt;ADT::~<span class="built_in">ADT</span>(); <span class="comment">// 显式调用析构函数</span></span><br><span class="line">  <span class="keyword">delete</span>[] p;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// ADT construct i = 10, j = 100</span></span><br><span class="line"><span class="comment">// ADT destruct</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<hr>
<h2 id="42、C-的异常处理方法"><a href="#42、C-的异常处理方法" class="headerlink" title="42、C++的异常处理方法"></a>42、C++的异常处理方法</h2><hr>
<h2 id="43、static的用法和作用？"><a href="#43、static的用法和作用？" class="headerlink" title="43、static的用法和作用？"></a>43、static的用法和作用？</h2><ol>
<li><p>隐藏（static函数，static变量均可）<br>  当同时编译多个文件时，所有未加static前缀的全局变量和函数都有全局可见性</p>
</li>
<li><p>保持变量内容持久（static变量的记忆功能和全局生存期）<br>  存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一一次初始化。<br>  静态存储区：全局变量和static变量【static控制变量可见范围，总之还是隐藏】</p>
</li>
<li><p>默认初始化为0（static变量）<br>  静态数据区的两种变量都有这样的特性</p>
</li>
<li><p>C++中类成员声明 static</p>
</li>
<li><p>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值。</p>
</li>
<li><p>模块内static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问。</p>
</li>
<li><p>在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内；</p>
</li>
<li><p>在类中的static成员变量属于整个类所拥有，对类的虽有对象只有一份拷贝。</p>
</li>
<li><p>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p>
</li>
<li><p>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化。</p>
</li>
<li><p>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。</p>
</li>
<li><p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，因此加上virtual没有任何实际意义<br>同时，virtual虚函数是要通过this指针调用虚函数表：this-&gt;vptr-&gt;ctable-&gt;virtual function</p>
</li>
</ol>
<hr>
<h2 id="44、指针和const的用法"><a href="#44、指针和const的用法" class="headerlink" title="44、指针和const的用法"></a>44、指针和const的用法</h2><ol>
<li><p>当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。</p>
</li>
<li><p>int *const p2中const修饰 p2 的值【 <em>修饰int】，所以理解为 p2 的值不可改变，即 p2 只能指向固定的一个变量地址，<br>可以通过</em>p2读写这个变量的值。<br>顶层指针表示指针本身是一个常量。</p>
</li>
<li><p>int const *p1或者const int *p1两种情况中const修饰 *p1，所以理解为 <em>p1的值不可以改变，<br>即不可以给</em>p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。</p>
<p>底层指针表示指针所指向的变量是一个常量。</p>
</li>
</ol>
<hr>
<h2 id="45、形参和实参的区别？"><a href="#45、形参和实参的区别？" class="headerlink" title="45、形参和实参的区别？"></a>45、形参和实参的区别？</h2><ol>
<li><p>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。<br>因此，形参只有在函数内部有效，函数调用结束返回主调函数后不能使用该形参变量。</p>
</li>
<li><p>实参可以是常量、变量、表达式、函数等，无论实参是那种类型的变量，在进行函数调用时，都必须具有确定的值，以便把这些值传送给形参。<br>因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</p>
</li>
<li><p>实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”错误</p>
</li>
<li><p>函数调用中发生的数据传送是单向的 —— 只能把实参的值送给形参，不能把形参的值反向传给实参。<br>在函数调用过程中，形参值发生改变，形参中的值不会变化。</p>
</li>
<li><p>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置。<br>形参将实参的内容复制一份，在该函数运行结束时形参被释放，实参内容不会改变。</p>
</li>
</ol>
<hr>
<h2 id="46、值传递、指针传递、引用传递的区别和效率"><a href="#46、值传递、指针传递、引用传递的区别和效率" class="headerlink" title="46、值传递、指针传递、引用传递的区别和效率"></a>46、值传递、指针传递、引用传递的区别和效率</h2><ol>
<li><p>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或大结构体对象，将耗费一定的时间和空间（拷贝构造）。</p>
</li>
<li><p>指针传递：同样有一个形参想函数所属的栈拷贝数据的过程。但拷贝的数据固定是一个n字节的地址（传值，不过传地址值）。</p>
</li>
<li><p>引用传递：同样有上述数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名（传地址）。</p>
</li>
<li><p>效率上讲，指针传递和引用传递比值传递效率高。一般主张<code>引用传递</code>，代码逻辑上更加紧凑、清晰。</p>
</li>
</ol>
<hr>
<h2 id="47、静态变量什么时候初始化"><a href="#47、静态变量什么时候初始化" class="headerlink" title="47、静态变量什么时候初始化"></a>47、静态变量什么时候初始化</h2><ol>
<li><p>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p>
</li>
<li><p>静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序直线，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化结点也有不同。</p>
</li>
<li><p>在C中，初始化发生在代码执行之前，编译阶段<b>分配好内存之后，就会进行初始化</b>，所以我们看到在C语言中<code>无法使用变量</code>对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被回收。</p>
</li>
<li><p>在C++中，初始化时在执行相关代码才会进行初始化，主要是C++引入对象后，要进行初始化不许执行相应构造&#x2F;析构函数，在其中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以C++中<code>可以使用变量</code>对静态局部变量进行初始化的。</p>
</li>
</ol>
<hr>
<h2 id="48、const关键字的作用有哪些？"><a href="#48、const关键字的作用有哪些？" class="headerlink" title="48、const关键字的作用有哪些？"></a>48、const关键字的作用有哪些？</h2><ol>
<li><p>阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对其进行初始化，因为以后没机会改变他了（实际上有）</p>
</li>
<li><p>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定位const</p>
</li>
<li><p>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值</p>
</li>
<li><p>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数。</p>
</li>
<li><p>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”</p>
</li>
<li><p>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员。</p>
</li>
<li><p>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不能访问const对象的任意数据成员。</p>
</li>
<li><p>一个没有明确声明为const的成员函数被看做是<code>将要修改对象中数据成员</code>的函数,<br>而且编译器不允许它为一个const对象所调用，因此const对象只能调用const成员函数。</p>
</li>
<li><p>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型</p>
</li>
<li><p>const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化。</p>
</li>
<li><p>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进参数的，函数内只能改变临时变量，但无法改变实参。<br>这个时候无论加不加const都不会对实参产生任何影响。<br>但是在引用或者指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量<br>这个时候const才是实实在在保护了实参所指向的变量。<br>因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以只有引用传递和指针传递可以用是否加const来重载。<br>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p>
</li>
</ol>
<hr>
<h2 id="49、什么是类的继承？"><a href="#49、什么是类的继承？" class="headerlink" title="49、什么是类的继承？"></a>49、什么是类的继承？</h2><ol>
<li><p>类与类之间的关系<br>  has-A 包含关系，用以描述一个类由多个部件类构成，实现has-A 关系用类的<code>成员属性</code>表示，即一个类的成员属性是另一个已经定义好的类<br>  use-A 使用关系，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现<br>  is-A  继承关系，关系具有传递性；</p>
</li>
<li><p>继承的相关概念<br>  所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或派生类<br>  被继承的类称为父类或基类</p>
</li>
<li><p>继承的特点<br>  子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用</p>
</li>
<li><p>继承中的访问控制<br>  public、protected、private</p>
</li>
<li><p>继承中的构造和析构函数</p>
</li>
<li><p>继承中的兼容性原则</p>
</li>
</ol>
<hr>
<h2 id="50、从汇编层去解释一下引用"><a href="#50、从汇编层去解释一下引用" class="headerlink" title="50、从汇编层去解释一下引用"></a>50、从汇编层去解释一下引用</h2><div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>汇编层解释引用</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>:      <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="number">00401048</span>  mov     dword ptr [ebp<span class="number">-4</span>],<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:     <span class="type">int</span> &amp;b = x;</span><br><span class="line"><span class="number">0040104F</span>   lea     eax,[ebp<span class="number">-4</span>]</span><br><span class="line"><span class="number">00401052</span>  mov     dword ptr [ebp<span class="number">-8</span>],eax</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<p>x 的地址是 ebp-4，b 的地址是ebp-8，因为栈内的变量内存是<code>从高往低</code>进行分配的，所以 b 的地址比 x 的低。<br>lea eax, [ebp-4 ] 这条语句将 x 的地址 ebp-4 放入eax寄存器<br>mov dword ptr [ebp-8 ], eax 这条语句将eax的值放入 b 的地址</p>
<p>ebp-8中上面两条汇编的作用：将x的地址存入变量b中，这与将某个变量的地址存入指针变量是一样的</p>
<blockquote>
<p>总结：引用是通过指针来实现的</p>
</blockquote>
<hr>
<h2 id="51、深拷贝和浅拷贝？-——-参考条目35"><a href="#51、深拷贝和浅拷贝？-——-参考条目35" class="headerlink" title="51、深拷贝和浅拷贝？ —— 参考条目35"></a>51、深拷贝和浅拷贝？ —— 参考条目35</h2><hr>
<h2 id="52、new和malloc区别？-——-参考条目10"><a href="#52、new和malloc区别？-——-参考条目10" class="headerlink" title="52、new和malloc区别？ —— 参考条目10"></a>52、new和malloc区别？ —— 参考条目10</h2><blockquote>
<p>补充：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）<br>      然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。<br>      delete先调用析构函数，然后调用operator delete函数释放内存，（通常底层使用free实现）<br>      即 分配内存 —— 构造函数 —— 析构函数 —— 释放内存</p>
<p>malloc&#x2F;free是库函数，只能动态地申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
</blockquote>
<hr>
<h2 id="53、delete-p、delete-p、allocator都有什么作用？"><a href="#53、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="53、delete p、delete []p、allocator都有什么作用？"></a>53、delete p、delete []p、allocator都有什么作用？</h2><ol>
<li><p>动态数组管理 new 一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数</p>
</li>
<li><p>new 动态数组返回的并不是数据类型，而是一个元素类型的指针</p>
</li>
<li><p>delete[] 时，数组中的元组按照逆序的顺序进行销毁</p>
</li>
<li><p>new 在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样delete也是降对象析构和内存释放组合在一起</p>
</li>
<li><p>allocator将申请内存和对象构造函数分开来，allocator申请一部分内存，不进行初始化对象，只有需要时才进行初始化操作。</p>
</li>
</ol>
<hr>
<h2 id="54、new和delete的实现原理，delete是如何知道释放内存大小的？"><a href="#54、new和delete的实现原理，delete是如何知道释放内存大小的？" class="headerlink" title="54、new和delete的实现原理，delete是如何知道释放内存大小的？"></a>54、new和delete的实现原理，delete是如何知道释放内存大小的？</h2><ol>
<li><p>new简单类型直接调用operator new分配内存；<br>new复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</p>
</li>
<li><p>new[]简单类型计算好大小后调用operator new；<br>new[]复杂结构，先调用operator new[] 分配内存，然后在p的前4个字节输入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小</p>
<ol>
<li><p>new 表达式调用一个名为operator new(operator new[]) 函数，分配一块足够大的、原始的、未命名的内存空间；</p>
</li>
<li><p>编译器运行相应的构造函数以构造这些对象，并为其传入初始值；</p>
</li>
<li><p>对象被分配了空间并构造完成，返回一个指向该对象的指针。</p>
</li>
</ol>
</li>
<li><p>delete 简单数据类型默认只是调用 free函数；<br>delete 复杂数据类型先调用析构函数在调用 operator delete</p>
</li>
<li><p>针对简单类型，delete 和 delete[] 等同。<br>假设指针p指向new[]分配的内存，因为要4字节存储数组大小，实际分配的内存地址为 [p-4 ]，系统记录的也是这个地址。<br>delete[] 实际释放的是p-4指向的内存，<b>delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃</b></p>
</li>
<li><p>需要在new[] 一个对象数组时，需要保存数组的维度，C++的做法是在分配数组空间时多分配了4个字节的大小，专门保存数组的大小<br>在delete[] 时就可以取出这个保存的数，就知道需要调用析构函数多少次了。</p>
</li>
</ol>
<hr>
<h2 id="55、malloc申请的存储空间能用delete释放吗？"><a href="#55、malloc申请的存储空间能用delete释放吗？" class="headerlink" title="55、malloc申请的存储空间能用delete释放吗？"></a>55、malloc申请的存储空间能用delete释放吗？</h2><p>不能</p>
<p>malloc&#x2F;free主要是为了兼容C，new&#x2F;delete是完全可以取代malloc&#x2F;free的</p>
<ul>
<li><p>malloc&#x2F;free的操作对象都是必须明确大小的，而且不能用在动态类上。<br>new和delete会自动进行类型检查和大小</p>
</li>
<li><p>malloc&#x2F;free不能执行构造函数和析构函数，所以动态对象不能用该方法创建&#x2F;销毁</p>
</li>
</ul>
<p>理论上说使用malloc申请的内存是可以通过delete释放的。<br>不过一般不这样写，而且不能保证每个运行程序都正常。</p>
<hr>
<h2 id="56、malloc和free的实现原理？"><a href="#56、malloc和free的实现原理？" class="headerlink" title="56、malloc和free的实现原理？"></a>56、malloc和free的实现原理？</h2><ol>
<li><p>在标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk&#x2F;mmap&#x2F;munmap这些系统调用实现的</p>
</li>
<li><p><code>brk</code>是将数据段(.data)的最高地址指针_edata往高地址推，<br><code>mmap</code>是在进程的虚拟地址空间中(堆和栈中间，成为文件映射区域的地方)找一块空闲的虚拟内存。<br>这两种方式都是分配虚拟内存，没有分配物理内存。<br>在一次访问已分配的虚拟地址空间的时候，发生<code>缺页中断</code>，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p>
</li>
<li><p>malloc小于128k的内存，使用<code>brk</code>分配内存，将_edata往高地址推；<br>malloc大于128k的内存，使用<code>mmap</code>分配内存，在堆和栈之间找一块空闲内存分配；<br>brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。<br>当最高地址空间的空闲内存超过128k（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。<br>在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p>
</li>
<li><p>malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。<br>操作系统有一个记录空闲内存地址的链表。<br>当操作系统收到程序的申请时，就会遍历该链表，然后寻找第一个空间大于所申请空间的堆结点，然后将该节点从空闲结点链表中删除，并将该节点的空间分配给程序</p>
</li>
</ol>
<hr>
<h2 id="57、malloc、realloc、calloc的区别"><a href="#57、malloc、realloc、calloc的区别" class="headerlink" title="57、malloc、realloc、calloc的区别"></a>57、malloc、realloc、calloc的区别</h2><ol>
<li><p>malloc函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">20</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">//申请20个int类型的空间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>calloc函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>省去了人为空间计算，malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
</li>
<li><p>realloc函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
</li>
</ol>
<hr>
<h2 id="58、类成员初始化方式？构造函数执行顺序？为什么用成员初始化列表快一些？"><a href="#58、类成员初始化方式？构造函数执行顺序？为什么用成员初始化列表快一些？" class="headerlink" title="58、类成员初始化方式？构造函数执行顺序？为什么用成员初始化列表快一些？"></a>58、类成员初始化方式？构造函数执行顺序？为什么用成员初始化列表快一些？</h2><ol>
<li><p>赋值初始化，通过在函数体内进行赋值初始化<br>初始化列表，在冒号后使用初始化列表进行初始化。</p>
<p>两种方式主要区别：</p>
<ul>
<li><p>对于在函数体中初始化，是在所有数据成员<code>被分配内存空间后</code>进行的。</p>
</li>
<li><p>初始化列表是给数据成员分配内存空间时就进行初始化，<br>就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式（此表达式必须是括号赋值表达式）<br>则分配内存空间后在进入函数体之前给数据成员赋值，也就是初始化这个数据成员时，函数体还未执行</p>
</li>
</ul>
</li>
<li><p>一个派生类构造函数的执行顺序如下：</p>
</li>
<li><p>虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）【菱形继承的大基类】</p>
</li>
<li><p>基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）</p>
</li>
<li><p>类类型的成员对象的构造函数（按照初始化顺序）</p>
</li>
<li><p>派生类自己的构造函数</p>
</li>
<li><p>方法一是在构造函数当中做赋值的操作<br>方法二是做纯粹的初始化的操作。<br>众所周知：C++的赋值操作是会产生临时对象的，临时对象的出现会降低程序的效率</p>
</li>
</ol>
<hr>
<h2 id="59、有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#59、有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="59、有哪些情况必须用到成员列表初始化？作用是什么？"></a>59、有哪些情况必须用到成员列表初始化？作用是什么？</h2><ol>
<li><p>必须使用成员初始化的四种情况</p>
</li>
<li><p>当初始化一个引用成员时；</p>
</li>
<li><p>当初始化一个常量成员时；</p>
</li>
<li><p>当调用一个基类的构造函数，而它有一组参数时；</p>
</li>
<li><p>当调用一个成员类的构造函数，而它拥有一组参数时；</p>
</li>
<li><p>成员初始化列表做了什么？</p>
</li>
<li><p>编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p>
</li>
<li><p>list中的项目顺序是由<code>类中的成员声明顺序决定</code>的，不是由初始化列表的顺序决定的。</p>
</li>
</ol>
<hr>
<h2 id="60、C-中新增了string，它与C语言中的char-有什么区别吗？如何实现的？"><a href="#60、C-中新增了string，它与C语言中的char-有什么区别吗？如何实现的？" class="headerlink" title="60、C++中新增了string，它与C语言中的char *有什么区别吗？如何实现的？"></a>60、C++中新增了string，它与C语言中的char *有什么区别吗？如何实现的？</h2><p>  string 继承自 basic_string，其实是对char *进行了封装，封装的string包含了char *数组，容量，长度等等属性。</p>
<h2 id="string-可以进行自动扩展，在每次扩展的时候另外申请一块原空间大小2倍的空间，然后将源字符串拷贝过去，并加上新增内容。"><a href="#string-可以进行自动扩展，在每次扩展的时候另外申请一块原空间大小2倍的空间，然后将源字符串拷贝过去，并加上新增内容。" class="headerlink" title="  string 可以进行自动扩展，在每次扩展的时候另外申请一块原空间大小2倍的空间，然后将源字符串拷贝过去，并加上新增内容。"></a>  string 可以进行自动扩展，在每次扩展的时候另外申请一块原空间大小2倍的空间，然后将源字符串拷贝过去，并加上新增内容。</h2><h2 id="61、什么是内存泄漏、如何检测和避免"><a href="#61、什么是内存泄漏、如何检测和避免" class="headerlink" title="61、什么是内存泄漏、如何检测和避免"></a>61、什么是内存泄漏、如何检测和避免</h2><ul>
<li><p>内存泄漏<br>一般常说的内存泄漏是指<b>堆内存的泄漏</b><br>堆内存是程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期间决定）内存块，使用后必须显式释放的内存。<br>应用程序一般使用malloc&#x2F;realloc&#x2F;new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free&#x2F;delete释放该内存块<br>否则，这块内存就不能被再使用，则称之为该内存泄漏</p>
</li>
<li><p>避免内存泄漏的几种方式</p>
<ol>
<li><p>计数法： 使用new和malloc时，该数+1，delete&#x2F;free时，该数-1，程序执行完打印这个计数，如果不为0则存在内存泄漏</p>
</li>
<li><p>一定要将基类的析构函数声明为<b>虚函数</b></p>
</li>
<li><p>对象数组的释放一定要用 delete []</p>
</li>
<li><p>有new就有delete，有malloc就有free，保证他们成对出现</p>
</li>
</ol>
</li>
<li><p>检测工具</p>
<ul>
<li><p>Linux下可以使用<b>Valgrind工具</b></p>
</li>
<li><p>Windows下可以使用<b>CRT库</b></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="62、对象复用的了解、零拷贝的了解"><a href="#62、对象复用的了解、零拷贝的了解" class="headerlink" title="62、对象复用的了解、零拷贝的了解"></a>62、对象复用的了解、零拷贝的了解</h2><div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>对象复用和零拷贝</span></div>
    <div class="xContent"><div class="inner">
        <ul>
<li><p>对象复用<br>对象复用本质就是一种设计模式：Flyweight享元模式<br>通过将对象存储到<code>“对象池”</code>中实现对对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p>
</li>
<li><p>零拷贝<br>零拷贝就是一种避免CPU将数据从一块存储拷贝到另一块存储的技术<br>零拷贝技术可以减少数据拷贝和共享总线操作的次数<br>在C++中，vector的一个成员函数<b>emplace_back()</b>很好地体现了零拷贝技术（和push_back()一样可以将一个元素插入容器尾部）<br>区别在于：push_back()需要调用拷贝构造函数和转移构造函数；emplace_back()插入的元素原地构造，不需要拷贝和转移</p>
<div class="xControl">
  <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>零拷贝</span></div>
  <div class="xContent"><div class="inner">
      <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="comment">// 初始化构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(string p_name, <span class="type">int</span> p_age):<span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">age</span>(p_age)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I have been constructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other):<span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I have been copy consturcted&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转移构造函数【使用右值引用】</span></span><br><span class="line">  <span class="built_in">Person</span>(Person&amp;&amp; other):<span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am being moved&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  vector&lt;Person&gt; e;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  e.<span class="built_in">emplace_back</span>(<span class="string">&quot;Jane&quot;</span>, <span class="number">23</span>); <span class="comment">// 不用构造类对象</span></span><br><span class="line"></span><br><span class="line">  vector&lt;Person&gt; p;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;Mike&quot;</span>, <span class="number">36</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// emplace_back:</span></span><br><span class="line"><span class="comment">// I have been constructed</span></span><br><span class="line"><span class="comment">// push_back:</span></span><br><span class="line"><span class="comment">// I have been constructed;</span></span><br><span class="line"><span class="comment">// I am bing moved</span></span><br></pre></td></tr></table></figure> 
  </div></div>
  </div></li>
</ul>
 
    </div></div>
    </div>

<h2 id="63、介绍面向对象的三大特性，并举例说明"><a href="#63、介绍面向对象的三大特性，并举例说明" class="headerlink" title="63、介绍面向对象的三大特性，并举例说明"></a>63、介绍面向对象的三大特性，并举例说明</h2><p>三大特性：封装、继承、多态</p>
<ol>
<li>封装<br>  数据和代码捆绑在一起，避免外界干扰和不确定性访问。</li>
</ol>
<p>  封装，也就是<b>把客观事物封装成抽象的类</b>，并且类可以吧自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br>  例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p>
<ol start="2">
<li>继承<br>  <b>让某种类型对象获得另一个类型对象的属性和方法</b><br>  它可以实现现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展<br>  常见的继承有三种方式：<ol>
<li><p>实现继承：指使用基类的属性和方法而无需额外编码</p>
</li>
<li><p>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</p>
</li>
<li><p>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++不常用）</p>
</li>
</ol>
</li>
</ol>
<p>  例如：车定义为抽象类，可以派生出轿车、卡车等有自己的属性和方法，但有一些共同点可以在车类中共同编码</p>
<ol start="3">
<li>多态<br>  同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为<br>  <b>（重载实现编译时多态，虚函数实现运行时多态）</b></li>
</ol>
<p>  多态性是允许你将父对象设置成为和一个或更多他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同方式运作。<br>  总之：<b>允许将子类类型的指针赋值给父类类型的指针</b></p>
<p>  实现多态的方式有两种：覆盖（override），重载（overload）</p>
<ul>
<li><p>覆盖：是指子类重新定义父类的虚函数的做法</p>
</li>
<li><p>重载：是指允许存在多个同名函数，而这些函数又属于重载关系。</p>
</li>
</ul>
<hr>
<h2 id="64、成员初始化列表的概念，为什么用它会快一点-——-参考条目58"><a href="#64、成员初始化列表的概念，为什么用它会快一点-——-参考条目58" class="headerlink" title="64、成员初始化列表的概念，为什么用它会快一点 —— 参考条目58"></a>64、成员初始化列表的概念，为什么用它会快一点 —— 参考条目58</h2><p>如果在函数体内进行赋值，相当于一次默认构造+一次赋值，初始化列表中只一次赋值操作<br>【如果成员中含有类的话，那初始化列表是快一些，省去了构造函数时间】</p>
<hr>
<h2 id="65、C-的四种强制转换reinterpret-cast-x2F-const-cast-x2F-static-cast-x2F-dynamic-cast"><a href="#65、C-的四种强制转换reinterpret-cast-x2F-const-cast-x2F-static-cast-x2F-dynamic-cast" class="headerlink" title="65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast"></a>65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast</h2><ol>
<li>reinterpret_cast<br>  reinterpret_cast&lt; type_id&gt; (expression)</li>
</ol>
<p>  type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。<br>  它可以用于类型之间的强制转换</p>
<ol start="2">
<li>const_cast<br>  const_cast&lt; type_id&gt;(expression)<br>  该运算符用来修改类型的const或volatile属性。<br>  除了const或volatile修饰以外，type-id和expression的类型是一样的<br>  具体用法如下：</li>
</ol>
<ul>
<li><p>常量指针被转化为非常量的指针，并且仍然指向原来的对象</p>
</li>
<li><p>常量引用被转换为非常量的引用，并且仍然指向原来的对象</p>
</li>
<li><p>const_cast一般用于修改底指针。如const char *p形式</p>
</li>
</ul>
<ol start="3">
<li>static_cast<br>  static_cast&lt; type_id&gt;(expression)<br>  该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。<br>  主要以下几种用法:<ul>
<li><p>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。</p>
<ul>
<li><p>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的【父类是子类的子集】</p>
</li>
<li><p>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</p>
</li>
</ul>
</li>
<li><p>用于基本数据类型之间的转换，如把int转换为char，把int转换为enum。这种安全性也要开发人员来保证。</p>
</li>
<li><p>把空指针转换成目标类型的空指针</p>
</li>
<li><p>把任何类型的表达式转换成void类型</p>
</li>
</ul>
</li>
</ol>
<p>  注意：static_cast不能转换掉expression的const&#x2F;volatile或者__unaligned属性。</p>
<ol start="4">
<li>dynamic_cast<br>  dynamic_cast&lt; type_id&gt;(expression)<br>  有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全（和static_cast相反？）<br>  该运算符把expression转换成type_id类型的对象，type_id必须是类的指针、类的引用或者void*</li>
</ol>
<p>  如果type_id是类指针类型，那么expression也必须是一个指针<br>  如果type_id是一个引用，那么expression也必须是一个引用</p>
<p>  dynamic_cast 运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。<br>  如果下行转换是安全的（也就是说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回<code>适当转型过的指针</code>。<br>  如果下行转换不安全，这个运算符会传回<code>空指针</code>（也就是说，基类指针或者引用没有指向一个派生类对象）</p>
<p>  dynamic_cast 主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</p>
<p>  在类层次间进行上行转换时，dynamic_cast和static_cast效果是一样的</p>
<p>  在进行下行转换时，dynamic_cast具有类型检查功能，比static_cast更安全【下行转换不安全时直接nullptr】</p>
  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>():<span class="built_in">b</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>():<span class="built_in">d</span>(<span class="number">2</span>)&#123;&#125;</span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">97</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reinterpret_cast</span></span><br><span class="line">  <span class="type">int</span> *p = &amp;n;</span><br><span class="line">  <span class="comment">// 以下两者效果相同</span></span><br><span class="line">  <span class="type">char</span> *c = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt; (p);</span><br><span class="line">  <span class="type">char</span> *c2 = (<span class="type">char</span> *)(p);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;reinterpret_cast输出：&quot;</span>&lt;&lt; *c2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const_cast</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> *p2 = &amp;n;</span><br><span class="line">  <span class="type">int</span> *p3 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p2);</span><br><span class="line">  *p3 = <span class="number">100</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;const_cast输出：&quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static_cast</span></span><br><span class="line">  Base* b1 = <span class="keyword">new</span> Son;   <span class="comment">// 派生类</span></span><br><span class="line">  Base* b2 = <span class="keyword">new</span> Base;  <span class="comment">// 基类</span></span><br><span class="line"></span><br><span class="line">  Son* s1 = <span class="built_in">static_cast</span>&lt;Son*&gt;(b1);  <span class="comment">// 同类型转换</span></span><br><span class="line">  Son* s2 = <span class="built_in">static_cast</span>&lt;Son*&gt;(b2);  <span class="comment">// 下行转换，不安全</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;static_cast输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s1-&gt;d &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s2-&gt;d &lt;&lt; endl;  <span class="comment">// 由于是下行转换，原先父对象没有d成员，因此返回垃圾值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// dynamic_cast</span></span><br><span class="line">  Son* s3 = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b1); <span class="comment">// 同类型转换</span></span><br><span class="line">  Son* s4 = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b2); <span class="comment">// 下行转换，安全</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;dynamic_cast输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s3-&gt;d &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">if</span>(s4 == <span class="literal">nullptr</span>) cout &lt;&lt; <span class="string">&quot;s4指针为nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span>  cout &lt;&lt; s4-&gt;d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// reinterpret_cast输出：a</span></span><br><span class="line"><span class="comment">// const_cast输出：100</span></span><br><span class="line"><span class="comment">// static_cast输出：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// -33686019</span></span><br><span class="line"><span class="comment">// dynamic_cast输出：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// s4指针为nullptr</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<blockquote>
<p>总结：下行转换时，dynamic_cast是安全的，如果下行转换不安全的话会返回<code>空指针</code>，这样在进行操作时可以预先判断<br>使用static_cast下行转换时存在不安全情况也可以转换成功，但是直接使用该对象可能会产生错误</p>
<p>同时，reinterpret_cast不能丢掉原数据类型的const，同时，无论参数是什么，只要type-id是合法类型就可转换</p>
</blockquote>
<hr>
<h2 id="66、C-函数调用的压栈过程"><a href="#66、C-函数调用的压栈过程" class="headerlink" title="66、C++函数调用的压栈过程"></a>66、C++函数调用的压栈过程</h2><ol>
<li>以例子进行讲解<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子讲解压栈过程</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> var1 = param1;</span><br><span class="line">  <span class="type">int</span> var2 = param2;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;var1 = %d, var2 = %d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2)); <span class="comment">//如果将printf转换为cout，则输出结果正好相反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// var1 = 1, var2 = 2</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
当函数从入口函数main函数开始执行时，编译器会将操作系统运行状态、main函数返回地址、main参数、main()内定义变量依次进行压栈；</li>
</ol>
<p>当main()开始调用func()时，编译器此时会将main()的运行状态压栈<br>再将func()函数的返回地址，func()函数参数从右到左，func()定义变量依次压栈；</p>
<p>当func()调用f()的时候，编译器此时会将func()函数的运行状态压栈<br>再将返回地址、f()函数的参数从右到左，f()定义变量依次压栈；</p>
<p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串<br>将栈中的变量依次弹出，最后主函数返回。</p>
<ol start="2">
<li><p>文字化表述<br>函数的调用过程：</p>
</li>
<li><p>从栈空间分配存储空间</p>
</li>
<li><p>从实参的存储空间复制值到形参栈空间</p>
</li>
<li><p>进行运算</p>
</li>
</ol>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但内存空间依然存在，不能也不会被销毁。</p>
<h2 id="当函数有多个返回值时，不能用普通return方式实现，需要通过传回地址的形式进行，即地址-x2F-指针传递。"><a href="#当函数有多个返回值时，不能用普通return方式实现，需要通过传回地址的形式进行，即地址-x2F-指针传递。" class="headerlink" title="当函数有多个返回值时，不能用普通return方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。"></a>当函数有多个返回值时，不能用普通return方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</h2><h2 id="67、写C-代码时有一类错误是coredump，常见，如何调试？"><a href="#67、写C-代码时有一类错误是coredump，常见，如何调试？" class="headerlink" title="67、写C++代码时有一类错误是coredump，常见，如何调试？"></a>67、写C++代码时有一类错误是coredump，常见，如何调试？</h2><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定条件下生成的一个叫做core的文件，<br>这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等。<br>对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<ul>
<li>使用gdb命令对core文件进行调试</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault并产生core文件</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br></pre></td></tr></table></figure>
<p>编辑器内键入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, i); <span class="comment">// 应该是&amp;i;</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coredumpTest</span><br></pre></td></tr></table></figure>
<p>使用gdb调试coredump</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<hr>
<h2 id="68、移动构造函数"><a href="#68、移动构造函数" class="headerlink" title="68、移动构造函数"></a>68、移动构造函数</h2><ol>
<li><p>用对象a初始化对象b，a不再使用，但a的空间依然存在<br>既然拷贝构造函数是使用a内容复制给b，为什么不直接用a的空间？<br>这样甚至可以避免新空间的分配，降低了构造成本。</p>
</li>
<li><p>拷贝构造函数中，对于指针，一定要深拷贝<br>移动构造函数中，对于指针，可以使用浅拷贝。</p>
<p>若使用浅拷贝，第一个对象释放指针时，将其置为nullptr，可以避免悬空指针</p>
</li>
<li><p>移动构造函数参数和拷贝构造函数参数不同：<br>拷贝构造函数的参数是一个<code>左值引用</code>，移动构造函数的参数是一个<code>右值引用</code><br>即：移动构造函数参数是一个右值或者将亡值引用。<br>即：只用一个右值，或者将亡值初始化另一个对象的时候才调用移动构造函数<br>std::move()的作用是将左值变成一个右值</p>
</li>
</ol>
<blockquote>
<p>补充，一般函数返回值都是右值，如果返回左值需要返回一个引用</p>
</blockquote>
<hr>
<h2 id="69、C-中将临时变量做返回值的处理过程"><a href="#69、C-中将临时变量做返回值的处理过程" class="headerlink" title="69、C++中将临时变量做返回值的处理过程"></a>69、C++中将临时变量做返回值的处理过程</h2><p>首先：临时变量在函数调用过程中是被压到程序进程栈中的，函数退出时，临时变量出栈，即临时变量被销毁，<br>      其占用内存空间没有清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说没有意义</p>
<p>C中规定：16bit程序中，返回值保存在ax寄存器中<br>        32bit程序中，返回值保存在eax寄存器中<br>        64bit程序中，高32bit保存在edx中，低32bit保存在eax中</p>
<p>即：函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系<br>    退出函数时时，临时变量可能被销毁，但返回值放到寄存器中，与临时变量生命周期没有关系</p>
<h2 id="如果需要返回值，一般使用赋值语句即可"><a href="#如果需要返回值，一般使用赋值语句即可" class="headerlink" title="如果需要返回值，一般使用赋值语句即可"></a>如果需要返回值，一般使用赋值语句即可</h2><h2 id="70、如何获得结构成员相对于结构开头的字节偏移量"><a href="#70、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="70、如何获得结构成员相对于结构开头的字节偏移量"></a>70、如何获得结构成员相对于结构开头的字节偏移量</h2><p>使用&lt; stddef.h&gt;头文件中的offsetof宏</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然可以使用 #pragma pack(4)指定4字节对齐方式</p>
 
    </div></div>
    </div>
<hr>
<h2 id="71、静态类型和动态类型，静态绑定和动态绑定"><a href="#71、静态类型和动态类型，静态绑定和动态绑定" class="headerlink" title="71、静态类型和动态类型，静态绑定和动态绑定"></a>71、静态类型和动态类型，静态绑定和动态绑定</h2><ul>
<li><p>静态类型：对象在声明时采用的类型，在编译器即已经确定</p>
</li>
<li><p>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的</p>
</li>
<li><p>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</p>
</li>
<li><p>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</p>
</li>
</ul>
<p>由以上定义看出，非虚函数一般是静态绑定，而虚函数都是动态绑定（如此可以实现多态性）</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/*virtual*/</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  C* pc = <span class="keyword">new</span> <span class="built_in">C</span>();  <span class="comment">// pc的静态类型是它声明的类型C*，动态类型也是C*</span></span><br><span class="line">  B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();  <span class="comment">// pb的静态类型和动态类型都是B*</span></span><br><span class="line">  A* pa = pc;       <span class="comment">// pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*</span></span><br><span class="line">  pa = pb;          <span class="comment">// pa的动态类型可以更改，现在它的动态类型是B*，静态类型依然是声明的A*</span></span><br><span class="line">  C *pnull = <span class="literal">nullptr</span>; <span class="comment">// pnull的静态类型是它声明的类型C*，没有动态类型，因为指向了nullptr</span></span><br><span class="line"></span><br><span class="line">  pa-&gt;<span class="built_in">func</span>();       <span class="comment">// A::func() pa的静态类型永远都是A*，不管指向的是哪个子类，都是直接调用A::func()</span></span><br><span class="line">  pc-&gt;<span class="built_in">func</span>();       <span class="comment">// C::func() pc的动静态类型都是C*，因此调用C::func()</span></span><br><span class="line">  pnumm-&gt;<span class="built_in">func</span>();    <span class="comment">// C::func() 编译期确定了，和指针是否为空无关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将A类中的virtual注释去掉，则结果是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;<span class="built_in">func</span>();   <span class="comment">// B::func()  因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();   <span class="comment">// C::func()  pc的动静态类型都是C*，因此先在C中查找</span></span><br><span class="line">pnumm-&gt;<span class="built_in">func</span>();<span class="comment">// 空指针异常，因为func是virtual虚函数，因此对func的调用只能在运行期才能确定</span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<p>在上面的例子中：</p>
<ul>
<li><p>如果基类A中的func不是virtual函数，那么不论pa&#x2F;pb&#x2F;pc指向哪个子类指针，对func的调用都是在定义pa&#x2F;pb&#x2F;pc时的静态类型决定【编译期】</p>
</li>
<li><p>同样空指针也能直接调用no-virtual函数而不报错【一定要做空指针检查】，因此静态绑定不能实现多态；</p>
</li>
<li><p>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是有性能损失的，但能实现多态特性。</p>
<blockquote>
<p>注意，上述代码是针对指针分析的，对引用的情况也同样适用</p>
</blockquote>
</li>
</ul>
<p>静态绑定和动态绑定的区别：</p>
<ul>
<li><p>静态绑定发生在<code>编译期</code>，动态绑定发生在<code>运行期</code>；</p>
</li>
<li><p>对象的动态类型可以更改，静态类型无法更改；</p>
</li>
<li><p>要想实现多态，必须使用动态绑定；</p>
</li>
<li><p>在继承体系中只有虚函数使用的是动态绑定，其他的全都是静态绑定；</p>
</li>
</ul>
<blockquote>
<p>建议：<br>  不要重新定义继承而来的<code>非虚函数</code>，这样导致函数调用由对象声明时的静态类型确定了，而与对象本身脱离了关系，没有多态，从而有隐患<br>  在动态绑定也即在virtual函数中，要注意默认参数的使用。<br>  当缺省参数和virtual函数一起使用时一定要谨慎，不然出了问题很难排查。</p>
</blockquote>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>缺省参数</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;E::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>: <span class="keyword">public</span> E&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;F::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  F* pf = <span class="keyword">new</span> <span class="built_in">F</span>();</span><br><span class="line">  E* pe = pf;</span><br><span class="line">  pf-&gt;<span class="built_in">func</span>(); <span class="comment">// F::func() 1  正常</span></span><br><span class="line">  pe-&gt;<span class="built_in">func</span>(); <span class="comment">// F::func() 0  调用了子类的函数，但是使用了基类的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">test2</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<hr>
<h2 id="72、引用是否能实现动态绑定，为什么可以实现？"><a href="#72、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="72、引用是否能实现动态绑定，为什么可以实现？"></a>72、引用是否能实现动态绑定，为什么可以实现？</h2><p>可以<br>引用在创建时必须初始化，在访问虚函数时，编译器会根据其绑定的对象类型要调用哪个函数，注意只能调用虚函数。</p>
<h2 id="即：虚函数才有动态绑定，采用虚函数情况下，使用的是动态绑定对象的虚函数"><a href="#即：虚函数才有动态绑定，采用虚函数情况下，使用的是动态绑定对象的虚函数" class="headerlink" title="即：虚函数才有动态绑定，采用虚函数情况下，使用的是动态绑定对象的虚函数"></a>即：虚函数才有动态绑定，采用虚函数情况下，使用的是动态绑定对象的虚函数</h2><h2 id="73、全局变量和局部变量有什么区别"><a href="#73、全局变量和局部变量有什么区别" class="headerlink" title="73、全局变量和局部变量有什么区别"></a>73、全局变量和局部变量有什么区别</h2><ol>
<li><p>声明周期不同：<br>全局变量随主程序创建而创建，随主程序销毁而销毁；<br>局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在</p>
</li>
<li><p>使用方式不同：<br>通过声明后全局变量在程序的各个部分都可以用到；<br>局部变量分配在堆栈区，只能在局部使用。</p>
</li>
</ol>
<p>操作系统和编译器通过内存分配的位置可以区分二者<br>全局数据分配在全局数据段并且在程序开始运行时被加载<br>局部变量则分配在堆栈里</p>
<hr>
<h2 id="74、指针加减计算要注意什么？"><a href="#74、指针加减计算要注意什么？" class="headerlink" title="74、指针加减计算要注意什么？"></a>74、指针加减计算要注意什么？</h2><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及指针加减运算需要十分小心。<br>操作不当会导致指向未知区域，从而内存风险</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> *a, *b, *c;</span><br><span class="line">  a = (<span class="type">int</span> *)<span class="number">0x500</span>;</span><br><span class="line">  b = (<span class="type">int</span> *)<span class="number">0x520</span>;</span><br><span class="line">  c = b - a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">  a += <span class="number">0x020</span>;</span><br><span class="line">  c = b - a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);  <span class="comment">// -24</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>

<p>首先变量a和b都是以16进制的形式初始化，将它们转换成十进制分别是1280和1312<br>则差值为32，即a和b所指地址之间间隔32位<br>但是由于int类型占4位，所以c的值为32&#x2F;4 &#x3D; 8【int类型4位】</p>
<p>a自增16进制0x20后，其实际地址为1280+2*16 *4 &#x3D; 1408（因为一个int是4位，要乘4）<br>则他们的差值变成了1312-1280&#x3D;-96，即-96&#x2F;4 &#x3D; -24</p>
<p>遇到指针的计算，<br><b>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成十进制计算，计算结果要除以类型长度</b></p>
<hr>
<h2 id="75、如何判断两个浮点数相等？"><a href="#75、如何判断两个浮点数相等？" class="headerlink" title="75、如何判断两个浮点数相等？"></a>75、如何判断两个浮点数相等？</h2><h2 id="要误差小于某个特定的值，不能直接用-x3D-x3D"><a href="#要误差小于某个特定的值，不能直接用-x3D-x3D" class="headerlink" title="要误差小于某个特定的值，不能直接用&#x3D;&#x3D;"></a>要误差小于某个特定的值，不能直接用&#x3D;&#x3D;</h2><h2 id="76、方法调用的原理（栈、汇编）"><a href="#76、方法调用的原理（栈、汇编）" class="headerlink" title="76、方法调用的原理（栈、汇编）"></a>76、方法调用的原理（栈、汇编）</h2><ol>
<li><p>机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储，为单个过程分配的那部分叫做帧栈；<br>帧栈可以认为是程序栈的一段，有两个端点，一个标识起始地址，一个标识结束地址<br>两个指针结束地址指针esp，开始地址指针ebp；</p>
</li>
<li><p>有一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回过程；<br>每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。<br>由于栈帧是向着地址递减的方向延伸，因此如果我们将栈指针减去一定的值，相当于分配了一定空间的内存。<br>如果加上一定的值，相当于压缩栈帧长度，即内存释放。</p>
</li>
<li><p>过程实现</p>
</li>
<li><p>备份原来栈指针，调整当前栈帧指针到栈指针位置；</p>
</li>
<li><p>建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存</p>
</li>
<li><p>使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p>
</li>
<li><p>恢复被调用者寄存器当中的值，这一过程其实是栈帧中将备份的值再恢复到寄存器，不过这些值可能已经不在栈顶</p>
</li>
<li><p>释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理</p>
</li>
<li><p>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域有回到了原始的位置。</p>
</li>
<li><p>弹出返回地址，跳出当前过程，继续执行调用者代码。</p>
</li>
<li><p>过程调用和返回指令</p>
</li>
<li><p>call指令</p>
</li>
<li><p>leave指令</p>
</li>
<li><p>ret指令</p>
</li>
</ol>
<hr>
<h2 id="77、C-中的指针参与传递和引用参数传递有什么区别？底层原理"><a href="#77、C-中的指针参与传递和引用参数传递有什么区别？底层原理" class="headerlink" title="77、C++中的指针参与传递和引用参数传递有什么区别？底层原理"></a>77、C++中的指针参与传递和引用参数传递有什么区别？底层原理</h2><ol>
<li><p>指针参数传递本质上是值传递，传递的是一个地址值。<br>  值传递是一个副本，只是对局部变量进行操作，不会改变原变量的值</p>
</li>
<li><p>引用传递过程中，被调函数的形参也作为局部变量在栈中开辟内存，但存放的是主调函数放进来的实参变量的地址。<br>  被调函数对形参（本体）的任何操作都被处理为间接寻址，即还是要修改到实参变量。</p>
</li>
<li><p>引用传递和指针传递是不同的<br>  对引用传递的修改，间接寻址，修改到原实参的值<br>  对指针传递参数本身的修改，只是改变这个地址的值（除非该地址指向的区域）</p>
</li>
<li><p>编译角度上来说，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名和变量对应的地址<br>  指针变量在符号表上对应的地址值为指针变量的地址值 —— 指针的指针，因此可以修改指针<br>  引用在符号表上对应的地址值为引用对象的地址值 —— 引用对象的地址值，因此不可以修改这个条目【因为符号表不能修改】<br>  符号表生成后就不可以修改，因此指针可以改变指向对象（指针变量中值可以改），引用对象不能修改。</p>
</li>
</ol>
<hr>
<h2 id="78、类如何实现只能静态分配和只能动态分配"><a href="#78、类如何实现只能静态分配和只能动态分配" class="headerlink" title="78、类如何实现只能静态分配和只能动态分配"></a>78、类如何实现只能静态分配和只能动态分配</h2><ol>
<li><p>静态分配：把new和delete运算符重载为private属性<br>动态分配：把构造、析构函数设为protected属性，再用子类动态创建</p>
</li>
<li><p>建立类的对象有两种方式：</p>
</li>
<li><p>静态建立：静态建立一个类对象，就是由编译器为对象在占空间中分配内存</p>
</li>
<li><p>动态建立：A *p &#x3D; new A(); 动态建立一个类对象，就是用new运算符为对象在堆空间中分配内存<br>步骤：第一，执行operator new()函数，在堆中搜索一块内存并分配；第二，调用类构造函数构造对象</p>
</li>
<li><p>使用new运算符，对象才会被建立在堆上<br>只要限制new运算符就可以实现类对象只能建立在栈上，即将new运算符设置为私有</p>
</li>
</ol>
<hr>
<h2 id="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#79、如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>79、如果想将某个类用作基类，为什么该类必须定义而非声明？</h2><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么<br>所以必须定义而非声明。</p>
<hr>
<h2 id="80、继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#80、继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="80、继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>80、继承机制中对象之间如何转换？指针和引用之间如何转换？</h2><ol>
<li><p>向上类型转换<br>  将派生类指针或引用转换为基类的指针或引用被称为向上类型转换<br>  向上类型转换会自动进行，而且向上类型转换是安全的</p>
</li>
<li><p>向下类型转换<br>  将基类指针或引用转换为派生类指针或引用被称为向下类型转换<br>  向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类<br>  向下类型转换必须加动态类型识别技术RTTI，用dynamic_cast向下类型转换</p>
</li>
</ol>
<hr>
<h2 id="81、C-中的组合，和继承相比缺点？"><a href="#81、C-中的组合，和继承相比缺点？" class="headerlink" title="81、C++中的组合，和继承相比缺点？"></a>81、C++中的组合，和继承相比缺点？</h2><ol>
<li>继承<br>  继承是 is A 的关系，Student 继承 Person，即Student is a Person。</li>
</ol>
<ul>
<li><p>继承的优点：<br>  是子类可以重写父类的方法来方便地实现对父类扩展</p>
</li>
<li><p>继承的缺点：</p>
<ol>
<li><p>父类的内部细节对子类是可见的</p>
</li>
<li><p>子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为</p>
</li>
<li><p>如果对父类的方法做了修改的话（如增加了一个参数），则子类的方法必须做出相应的修改。<br>所以子类和父类是一种高耦合，违背了OOP</p>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>组合<br>  组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</li>
</ol>
<ul>
<li><p>组合的优点：</p>
<ol>
<li><p>当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象不可见</p>
</li>
<li><p>当前对象和包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</p>
</li>
<li><p>当前对象可以在运行时动态的绑定所包含的对象，可以通过set方法可以给所包含对象赋值</p>
</li>
</ol>
</li>
<li><p>组合的缺点：</p>
<ol>
<li><p>容易产生过多的对象</p>
</li>
<li><p>为了能组合多个对象，必须仔细对接口进行定义</p>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="82、函数指针"><a href="#82、函数指针" class="headerlink" title="82、函数指针"></a>82、函数指针</h2><ol>
<li>什么是函数指针？<br>  函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的<br>  <b>函数的名称则不是其类型的一部分</b></li>
</ol>
<p>  一个具体函数的名字，如果后面不跟调用符号（括号），则该名字就是函数的指针（大部分情况下是如此，但不严格）</p>
<ol start="2">
<li><p>函数指针的声明方法。</p>
</li>
<li><p>int (*pf)(const int&amp;, const int&amp;);<br>pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&amp; 参数的函数。</p>
</li>
<li><p>int <em>pf(const int&amp;, const int&amp;);<br>声明了一个函数pf，返回类型为int</em>，带有两个const int&amp;参数。</p>
</li>
<li><p>为什么有函数指针<br>函数与数据项相似，函数也有地址。【参考汇编 call 指令】<br>希望同一个函数通过使用相同的形参在不同的时间产生不同的效果。</p>
</li>
<li><p>一个函数名就是一个指针，它指向函数的代码。<br>一个函数地址是该函数的进入点，也就是调用函数的地址。<br>函数的调用可以通过函数名，也可以通过指向函数的指针来调用。<br>函数指针还允许将函数作为变元传给其他的函数。</p>
</li>
<li><p>两种方法赋值：<br>指针名 &#x3D; 函数名;<br>指针名 &#x3D; &amp;函数名;</p>
</li>
</ol>
<hr>
<h2 id="83、内存对齐及原因。"><a href="#83、内存对齐及原因。" class="headerlink" title="83、内存对齐及原因。"></a>83、内存对齐及原因。</h2><ol>
<li><p>内存对齐</p>
</li>
<li><p>分配内存的顺序是按照声明的顺序。</p>
</li>
<li><p>每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍则空出内存，直到偏移量是整数倍</p>
</li>
<li><p>最后整个结构体的大小必须是里面变量类型最大值的整数倍。</p>
</li>
<li><p>添加#pragma pack(n)后：</p>
</li>
<li><p>偏移量要是n和当前变量大小中较小值的整数倍</p>
</li>
<li><p>整体大小要是n和最大变量大小中较小值的整数倍</p>
</li>
<li><p>n值必须为1,2,4,8……，为其他值时要按照默认的分配规则。</p>
</li>
</ol>
<hr>
<h2 id="84、结构体变量比较是否相等"><a href="#84、结构体变量比较是否相等" class="headerlink" title="84、结构体变量比较是否相等"></a>84、结构体变量比较是否相等</h2><ol>
<li><p>重载 “&#x3D;&#x3D;” 操作符</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>重载</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> foo&amp; rhs)&#123;  <span class="comment">// 操作符重载</span></span><br><span class="line">    <span class="built_in">return</span> (a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
</li>
<li><p>元素的话一个个比</p>
</li>
<li><p>指针直接比较，如果保存的是同一个实例地址，则(p1 &#x3D;&#x3D; p2)为真。</p>
</li>
</ol>
<hr>
<h2 id="85、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#85、函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="85、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>85、函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h2><ol>
<li><p>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中，<br>即：从右往左依次把被调函数所需要的参数压入栈。</p>
</li>
<li><p>调用者函数使用call指令调用被调函数，并把call指令的下一条指令的地址当成返回地址压入栈中（压栈操作隐含在call中）</p>
</li>
<li><p>在被调函数中，被调函数会先保存调用者函数的栈底地址（push ebp），然后再保存调用者函数的栈顶地址【上个函数返回地址，当前函数返回地址】<br>即：当前被调函数的栈底地址（mov ebp, esp）</p>
</li>
<li><p>在被调函数中，从ebp的位置处开始存放被调函数的局部变量和临时变量，并且这些变量的地址按照定义时的顺序依次减小<br>即：这些变量的地址是按照栈的延伸方向排列的，先定义的变量先入栈，后定义的变量后入栈。</p>
</li>
</ol>
<hr>
<h2 id="86、define、const、typedef、inline的使用方法？他们之间的区别？"><a href="#86、define、const、typedef、inline的使用方法？他们之间的区别？" class="headerlink" title="86、define、const、typedef、inline的使用方法？他们之间的区别？"></a>86、define、const、typedef、inline的使用方法？他们之间的区别？</h2><ol>
<li><p>const和#define的区别</p>
</li>
<li><p>const定义的常量是变量带类型<br>#define定义的是常数不带类型</p>
</li>
<li><p>const在编译、链接过程中起作用<br>#define只在预处理阶段起作用，简单的文本替换</p>
</li>
<li><p>const有数据类型，是要进行类型检查，可以避免一些低级错误<br>#define只是简单的字符串替换没有类型检查</p>
</li>
<li><p>const占用数据段空间<br>#define占用代码段空间</p>
</li>
<li><p>const不能冲定义<br>#define可以通过undef取消某个符号的定义，进行重定义</p>
</li>
<li><p>#define独特功能，比如可以用来防止文件重复引用</p>
</li>
<li><p>#define和别名typedef的区别</p>
</li>
<li><p>执行时间不同：<br>#define是宏定义，发生在预处理阶段，不进行类型检查<br>typedef在编译阶段有效，有类型检查的功能</p>
</li>
<li><p>功能差异：<br>#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等<br>typedef用来定义类型的别名，定义与平台无关的数据类型，与struct结合使用等</p>
</li>
<li><p>作用域不同：<br>#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用<br>typedef有自己的作用域。</p>
</li>
<li><p>define和inline的区别</p>
</li>
<li><p>#define是关键字<br>inline是函数</p>
</li>
<li><p>宏定义在预处理阶段进行文本替换<br>inline函数在编译阶段进行替换</p>
</li>
<li><p>宏定义没有类型检查<br>inline函数有类型检查</p>
</li>
</ol>
<hr>
<h2 id="87、printf的实现原理"><a href="#87、printf的实现原理" class="headerlink" title="87、printf的实现原理"></a>87、printf的实现原理</h2><p>C&#x2F;C++中对函数参数的扫描是从后向前的</p>
<p>压栈传参，栈是从高地址向低地址生长的，控制生长的是堆栈指针，最后压入的参数总能被函数找到，因为就在堆栈指针上方。</p>
<p>printf第一个被找到的参数就是字符指针，就是被双引号括起来的一部分，函数通过判断字符串里的参数的个数来判断参数的个数即数据类型<br>从而算出堆栈指针的偏移量</p>
<hr>
<h2 id="88、为什么模板类一般都是放在一个h文件中"><a href="#88、为什么模板类一般都是放在一个h文件中" class="headerlink" title="88、为什么模板类一般都是放在一个h文件中"></a>88、为什么模板类一般都是放在一个h文件中</h2><ol>
<li><p>模板定义很特殊<br>由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。<br>在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</p>
<p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
</li>
<li><p>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在<br>也不会去查找（当遇到未决符号时会寄希望于连接器）。<br>这种模式在没有模板的情况下运行良好，但模板仅在需要的时候才实例化出来。</p>
<p>所以编译器只看到模板声明，不能实例化该模板，只创建一个有外部连接的符号并期待连接器能将符号地址决议出来。</p>
<p>当实现该模板的.cpp文件中没有用到模板的实例时，编译器不去优化，因此整个工程.obj找不到一行模板实例的二进制代码，连接器也做不到。</p>
</li>
</ol>
<hr>
<h2 id="89、C-中类成员的访问权限和继承权限问题-——-参见条目37"><a href="#89、C-中类成员的访问权限和继承权限问题-——-参见条目37" class="headerlink" title="89、C++中类成员的访问权限和继承权限问题 —— 参见条目37"></a>89、C++中类成员的访问权限和继承权限问题 —— 参见条目37</h2><hr>
<h2 id="90、cout-和-printf-有什么区别？"><a href="#90、cout-和-printf-有什么区别？" class="headerlink" title="90、cout 和 printf 有什么区别？"></a>90、cout 和 printf 有什么区别？</h2><p>cout &lt;&lt; 是一个函数，cout &lt;&lt; 后可以跟不同的类型是因为cout &lt;&lt; 已存在针对各种数据类型的重载，所以会自动识别数据类型<br>输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p>
<p>cout 是有缓冲输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;abc &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;abc \n&quot;</span>; cout &lt;&lt; flush;  <span class="comment">// 这两个菜一样</span></span><br></pre></td></tr></table></figure>

<h2 id="flush立即强迫缓冲输出，printf是无缓冲输出，有输出时立即输出。"><a href="#flush立即强迫缓冲输出，printf是无缓冲输出，有输出时立即输出。" class="headerlink" title="flush立即强迫缓冲输出，printf是无缓冲输出，有输出时立即输出。"></a>flush立即强迫缓冲输出，printf是无缓冲输出，有输出时立即输出。</h2><h2 id="91、重载运算符"><a href="#91、重载运算符" class="headerlink" title="91、重载运算符"></a>91、重载运算符</h2><ol>
<li><p>只能重载已有的运算符，无权发明新的运算符；<br>对于重载运算符，优先级和结合律与内置类型一致才可以；<br>不能改变操作符运算数个数。</p>
</li>
<li><p>两种重载方式：</p>
<ol>
<li>成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数</li>
<li>下标运算符、箭头运算符，必须是成员运算符</li>
</ol>
</li>
<li><p>引入运算符重载，是为了实现类的多态性。</p>
</li>
<li><p>当重载的运算符是成员函数时，this绑定到左侧运算符对象。<br>成员运算符函数的参数数量比运算符的对象的数量少一个<br>至少含有一个类类型的参数</p>
</li>
<li><p>从参数个数推断到底定义的是哪种运算符<br>当运算符既是一元运算符又是二元运算符（+,-,*,&amp;）</p>
</li>
<li><p>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</p>
</li>
<li><p>箭头运算符必须是类的成员，解引用通常也是类的成员<br>重载的箭头运算符必须返回类的指针</p>
</li>
</ol>
<hr>
<h2 id="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#92、当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>92、当程序中有函数重载时，函数的匹配原则和顺序是什么？</h2><ol>
<li><p>名字查找</p>
</li>
<li><p>确定候选函数</p>
</li>
<li><p>寻找最佳匹配</p>
</li>
</ol>
<hr>
<h2 id="93、定义和声明的区别-——-参见条目15"><a href="#93、定义和声明的区别-——-参见条目15" class="headerlink" title="93、定义和声明的区别 —— 参见条目15"></a>93、定义和声明的区别 —— 参见条目15</h2><h2 id="有变量、函数的声明和定义"><a href="#有变量、函数的声明和定义" class="headerlink" title="有变量、函数的声明和定义"></a>有变量、函数的声明和定义</h2><h2 id="94、全局变量和static变量的区别"><a href="#94、全局变量和static变量的区别" class="headerlink" title="94、全局变量和static变量的区别"></a>94、全局变量和static变量的区别</h2><ol>
<li>全局变量（外部变量）的说明之前再冠以static就构成了静态全局变量<br>  全局变量本身就是静态存储方式、静态全局变量也是静态存储方式。<br>  上述两种在存储方式上并无不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，<code>非静态全局变量在各源文件有效</code>。</li>
</ol>
<p>  静态全局变量限定了其作用域，即<code>只在定义该变量的源文件内有效</code>，在同一源程序的其他源文件中不能使用它。</p>
<p>  静态全局变量的作用限于一个源文件内有效，在同一源程序的其他源文件中不能使用它<br>  由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数共用，因此可以避免在其他源文件内引起错误</p>
<p>  static全局变量域普通的全局变量的区别是：static全局变量只初始化一次，防止在其他文件单元被引用。</p>
<ol start="2">
<li>static函数和普通函数区别？<br>  static函数与普通的函数作用域不同，只在本文件中。<br>  只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</li>
</ol>
<p>  对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。</p>
<p>  static函数与普通函数最主要的区别就是static函数在内存中只有一份<br>  普通函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p>
<hr>
<h2 id="95、静态成员与普通成员的区别？"><a href="#95、静态成员与普通成员的区别？" class="headerlink" title="95、静态成员与普通成员的区别？"></a>95、静态成员与普通成员的区别？</h2><ol>
<li><p>生命周期<br>  静态成员变量从类被加载开始到类被卸载，一直存在<br>  普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束</p>
</li>
<li><p>共享方式<br>  静态成员变量是全类共享<br>  普通成员变量是每个对象单独想用的</p>
</li>
<li><p>定义位置<br>  静态成员变量存储在静态全局区<br>  普通成员变量存储在栈或堆中</p>
</li>
<li><p>初始化位置<br>  静态成员变量在类外初始化<br>  普通成员变量在类中初始化</p>
</li>
<li><p>默认实参<br>  静态成员变量作为默认实参</p>
</li>
</ol>
<hr>
<h2 id="96、ifdef和endif代表什么？"><a href="#96、ifdef和endif代表什么？" class="headerlink" title="96、ifdef和endif代表什么？"></a>96、ifdef和endif代表什么？</h2><ol>
<li><p>一般情况下，源程序中所有行都参与编译，但有时希望对其中一部分内容只在满足一定条件才可编译，即<code>条件编译</code><br>有时当满足某条件时对一组语句进行编译，而当条件不满足则编译另一组语句。</p>
</li>
<li><p>条件编译命令最常见的形式：</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其作用：当标识符已经被定义过（一般是用#define命令定义），则对程序段1进行编译，否则编译程序段2<br>其中#else部分也可以没有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span></span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
</li>
<li><p>在一个大的软件工程里，可能会有多个文件同时包含一个头文件，当这些头文件编译链接成一个可执行文件上时，会出现大量<code>重定义</code>错误<br>头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件冲定义。</p>
</li>
</ol>
<hr>
<h2 id="97、隐式转换，如何消除隐式转换"><a href="#97、隐式转换，如何消除隐式转换" class="headerlink" title="97、隐式转换，如何消除隐式转换"></a>97、隐式转换，如何消除隐式转换</h2><ol>
<li><p>C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。<br>所谓<code>隐式转换</code>，是指不需要用户干预，编译器私下进行的类型转换行为。<br>很多时候用户可能不知道进行了哪些转换。</p>
</li>
<li><p>C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。<br>通过隐式转换，可以直接将一个子类的对象使用父类的类型进行返回。<br>例如：数值和布尔类型、整数和浮点类型的转换。<br>某些方面来说，隐式类型转换带来了不小便捷，C++是一门强类型语言，类型的检查是非常严格的。</p>
</li>
<li><p>基本数据类型<br>基本数据类型的转换以<b>取值范围作为转换基础（保证精度不丢失）</b>。<br>隐式转换发生在从小到大的转换中<br>例如：char-&gt;int、int-&gt;long。<br>自定义对象中，<b>子类对象可以隐式转换为父类对象</b>。</p>
</li>
<li><p>C++中提供了explicit关键字，在构造函数声明时加上explicit关键字，能禁止隐式转换</p>
</li>
<li><p>如果构造函数只接受一个参数，则实际上定义了转换为此类型的隐式转换机制。<br>可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效<br>需要多个实参的构造函数不能执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
</li>
</ol>
<hr>
<h2 id="98、C-如何处理多个异常的？"><a href="#98、C-如何处理多个异常的？" class="headerlink" title="98、C++如何处理多个异常的？"></a>98、C++如何处理多个异常的？</h2><ol>
<li>C++中的异常情况：</li>
</ol>
<ul>
<li>语法错误（编译错误）<br>如：变量未定义、括号不匹配、关键字拼写错误等在编译时就能发现的错误，可被编译器及时发现，而且也可及时知道出错的位置及原因，方便改正。</li>
<li>运行时错误<br>如：数组下标越界、系统内存不足等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃<br>【解决这种错误可以使用异常处理机制】</li>
</ul>
<ol start="2">
<li>C++异常处理机制：<br>  异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理，而是抛出异常，让函数的调用者直接或间接地处理这个问题。<br>  C++的异常处理机制由3个模块组成：<br> try（检查）、throw（抛出）、catch（捕获）<br> 抛出异常的语句格式为：throw表达式;<br> 如果try块中程序段发现了异常则抛出异常。  <div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>异常处理机制</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 可能抛出异常的语句;（检查）try</span></span><br><span class="line">  可能抛出异常的语句; （检查）</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(类型名[形参名])&#123;  <span class="comment">// 捕获特定类型的异常</span></span><br><span class="line">  <span class="comment">// 处理1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(类型名[形参名])&#123;  <span class="comment">//捕获特定类型的异常</span></span><br><span class="line">  <span class="comment">// 处理2;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)&#123; <span class="comment">// 捕获所有类型的异常</span></span><br><span class="line">  <span class="comment">// 处理;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></li>
</ol>
<hr>
<h2 id="99、如何在不使用额外空间的情况下，交换两个数？"><a href="#99、如何在不使用额外空间的情况下，交换两个数？" class="headerlink" title="99、如何在不使用额外空间的情况下，交换两个数？"></a>99、如何在不使用额外空间的情况下，交换两个数？</h2><ol>
<li><p>算术<br>x &#x3D; x + y;<br>y &#x3D; x - y;<br>x &#x3D; x - y;</p>
</li>
<li><p>异或<br>x &#x3D; x ^ y;  &#x2F;&#x2F; 只能对int, char<br>y &#x3D; x ^ y;<br>x &#x3D; x ^ y;<br>&#x2F;&#x2F; x ^&#x3D; y ^&#x3D; x;</p>
</li>
</ol>
<hr>
<h2 id="100、strcpy和memcpy的区别？"><a href="#100、strcpy和memcpy的区别？" class="headerlink" title="100、strcpy和memcpy的区别？"></a>100、strcpy和memcpy的区别？</h2><ol>
<li><p>复制的内容不同。<br> strcpy只能复制字符串<br> memcpy可以复制任意内容，例如字符数组、整形、结构体、类等。</p>
</li>
<li><p>复制的方法不同。<br> strcpy不需要指定长度，因为有’\0’结束，因此容易溢出，<br> memcpy则是根据第三个参数决定复制的长度。</p>
</li>
<li><p>用途不同。<br> 通常在复制字符串时用strcpy<br> 复制其他类型数据一般用memcpy</p>
</li>
</ol>
<hr>
<h2 id="101、程序在执行int-main-int-argc-char-argc-时的内存结构？"><a href="#101、程序在执行int-main-int-argc-char-argc-时的内存结构？" class="headerlink" title="101、程序在执行int main(int argc, char *argc[])时的内存结构？"></a>101、程序在执行int main(int argc, char *argc[])时的内存结构？</h2><p>参数的含义是程序在命令行下运行的时候，需要输入argc个参数，每个参数以char类型输入，依次存在数组里面<br>数组是argv[]，所有的参数在指针char *指向的内存中，数组中的元素个数为argc个<br>第一个参数为程序的名称。</p>
<hr>
<h2 id="102、volatile关键字的作用-——-参见条目39"><a href="#102、volatile关键字的作用-——-参见条目39" class="headerlink" title="102、volatile关键字的作用 —— 参见条目39"></a>102、volatile关键字的作用 —— 参见条目39</h2><p>volatile用处：</p>
<ol>
<li><p>中断服务程序中修改的供其他程序检测的变量要加volatile【都要从内存中取而非寄存器】</p>
</li>
<li><p>多任务环境下各任务间共享的标志应该加volatile</p>
</li>
<li><p>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义。</p>
</li>
</ol>
<hr>
<h2 id="103、如果有一个空类，它会默认添加哪些函数？"><a href="#103、如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="103、如果有一个空类，它会默认添加哪些函数？"></a>103、如果有一个空类，它会默认添加哪些函数？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Empty</span>();  <span class="comment">// 缺省构造函数</span></span><br><span class="line"><span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">~<span class="built_in">Empty</span>(); <span class="comment">// 析构函数</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;); <span class="comment">// 赋值运算符</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="104、C-中标准库是什么"><a href="#104、C-中标准库是什么" class="headerlink" title="104、C++中标准库是什么"></a>104、C++中标准库是什么</h2><ol>
<li><p>C++标准库可以分为两部分：<br> 标准函数库：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自C语言。<br> 面向对象类库：这个库是<code>类及其相关函数</code>的集合。</p>
</li>
<li><p>输入&#x2F;输出（I&#x2F;O）、字符串和字符处理、数学、时间、日期、本地化、动态分配、其他、宽字符函数。</p>
</li>
<li><p>标准的C++ I&#x2F;O类、String类、数值类、STL容器类、STL算法、STL函数对象、STL迭代器、STL分配器、本地化库、异常处理库、杂项支持库</p>
</li>
</ol>
<hr>
<h2 id="105、const-char-和-string之间的关系？"><a href="#105、const-char-和-string之间的关系？" class="headerlink" title="105、const char* 和 string之间的关系？"></a>105、const char* 和 string之间的关系？</h2><ol>
<li><p>string 是C++标准库里面其中一个，封装了对字符串的操作<br>实际操作过程我们可以用 const char*给string类初始化。</p>
</li>
<li><p>三者转换关系如下所示</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 转 const char*</span></span><br><span class="line">string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* 转 string，直接赋值即可</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c_s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string 转 char*</span></span><br><span class="line">string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">c = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(c, s.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// char* 转 string</span></span><br><span class="line"><span class="type">char</span>* c = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* 转 char*</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pc = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cpc) + <span class="number">1</span>]；</span><br><span class="line"><span class="built_in">strcpy</span>(pc, cpc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// char* 转 const char*，直接赋值即可</span></span><br><span class="line"><span class="type">char</span>* pc = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div></li>
</ol>
<hr>
<h2 id="106、什么情况用指针参数，什么时候用引用参数？"><a href="#106、什么情况用指针参数，什么时候用引用参数？" class="headerlink" title="106、什么情况用指针参数，什么时候用引用参数？"></a>106、什么情况用指针参数，什么时候用引用参数？</h2><ol>
<li><p>使用引用参数原因<br> 程序员能修改调用函数中的数据对象<br> 通过传递引用而不是整个数据对象，可以提高程序运行速度</p>
</li>
<li><p>一般的原则：对于使用引用的值而不做修改的函数：<br> 如果数据对象很小，如内置数据类型或小型结构，则<code>值传递</code><br> 如果数据对象是数组，则使用<code>指针</code>，并且指针声明为指向const的指针<br> 如果数据对象是较大的结构，则使用<code>const指针</code>或<code>引用</code>，以提高程序效率【可以节省构造所需时间和空间】<br> 如果数据对象是类对象，则使用<code>const引用</code>【传递类对象参数的标准方式是按照引用传递】</p>
</li>
<li><p>对于修改函数中数据的函数：<br> 如果数据是内置数据类型，则使用指针<br> 如果数据对象是数组，则<b>只能</b>使用指针<br> 如果数据对象是结构，则使用引用或指针<br> 如果数据对象是类对象，则使用引用</p>
</li>
</ol>
<hr>
<h2 id="107、静态绑定和动态绑定？-——-参照条目71"><a href="#107、静态绑定和动态绑定？-——-参照条目71" class="headerlink" title="107、静态绑定和动态绑定？ —— 参照条目71"></a>107、静态绑定和动态绑定？ —— 参照条目71</h2><hr>
<h2 id="108、如何设计一个计算仅单个子类的对象个数"><a href="#108、如何设计一个计算仅单个子类的对象个数" class="headerlink" title="108、如何设计一个计算仅单个子类的对象个数"></a>108、如何设计一个计算仅单个子类的对象个数</h2><ol>
<li><p>为类设计一个static静态变量count作为计数器</p>
</li>
<li><p>类定义结束后初始化count【注意是定义结束后，static类成员独立与类对象存在】</p>
</li>
<li><p>在构造函数中count+1</p>
</li>
<li><p>设计拷贝构造函数，在进行拷贝构造函数中进行count+1</p>
</li>
<li><p>设计复制构造函数，在进行复制函数中对count+1操作</p>
</li>
<li><p>在析构函数中对count进行-1</p>
</li>
</ol>
<hr>
<h2 id="109、如何快速定位错误出现的地方？"><a href="#109、如何快速定位错误出现的地方？" class="headerlink" title="109、如何快速定位错误出现的地方？"></a>109、如何快速定位错误出现的地方？</h2><ol>
<li><p>如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位</p>
</li>
<li><p>对于复杂的模板错误，最好使用生成输出窗口。<br>多数情况下触发错误的位置是最靠后的引用位置。<br>如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析。</p>
</li>
</ol>
<hr>
<h2 id="110、初始化成员列表什么时候用？调用过程-——-参照条目59"><a href="#110、初始化成员列表什么时候用？调用过程-——-参照条目59" class="headerlink" title="110、初始化成员列表什么时候用？调用过程 —— 参照条目59"></a>110、初始化成员列表什么时候用？调用过程 —— 参照条目59</h2><h2 id="引用、常量、基类、成员类，按照类中定义顺序执行"><a href="#引用、常量、基类、成员类，按照类中定义顺序执行" class="headerlink" title="引用、常量、基类、成员类，按照类中定义顺序执行"></a>引用、常量、基类、成员类，按照类中定义顺序执行</h2><h2 id="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处？"><a href="#111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处？" class="headerlink" title="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处？"></a>111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处？</h2><p>对比值传参，引用传参的好处：</p>
<ol>
<li><p>在函数内部可以对此参数进行修改</p>
</li>
<li><p>提高函数调用和运行的效率（因为没有传值和生成副本的时间和空间消耗）</p>
</li>
</ol>
<p>如果函数的实参实质就是形参，不过这个形参的作用域只在函数体内部，也即实参和形参是两个不同的东西，形参代替实参，则值传递。</p>
<p>函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。</p>
<p>即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。</p>
<p>函数一旦结束，形参声明也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>限制：</p>
<ol>
<li><p>不能返回局部变量的引用，因为函数返回以后局部变量就会被销毁。</p>
</li>
<li><p>不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），有面临其他尴尬局面<br>如：被函数返回的引用只是作为一个临时变量出现，而没有赋予一个实际的变量，则引用指向的空间（new分配）就无法释放，memory leak</p>
</li>
<li><p>可以返回类成员的引用，但最好是const。<br>因为如果其他对象可以获得该属性的非常量引用，则对该属性单纯赋值会破坏业务规则完整性。</p>
</li>
</ol>
<hr>
<h2 id="112、说一说strcpy、sprintf和memcpy这三个函数的不同之处"><a href="#112、说一说strcpy、sprintf和memcpy这三个函数的不同之处" class="headerlink" title="112、说一说strcpy、sprintf和memcpy这三个函数的不同之处"></a>112、说一说strcpy、sprintf和memcpy这三个函数的不同之处</h2><ol>
<li><p>操作对象不同</p>
</li>
<li><p>strcpy的两个操作对象均为字符串</p>
</li>
<li><p>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p>
</li>
<li><p>memcpy的两个对象就是两个任意可操作的内存地址，并不限于任何数据类型</p>
</li>
<li><p>执行效率不同<br>  memcpy 最高；strcpy 次之；sprintf 效率最低</p>
</li>
<li><p>实现功能不同</p>
</li>
<li><p>strcpy主要实现字符串变量间的拷贝</p>
</li>
<li><p>sprintf主要实现其他数据类型格式到字符串的转化</p>
</li>
<li><p>memcpy主要是内存块间的拷贝</p>
</li>
</ol>
<hr>
<h2 id="113、将引用作为函数参数好处？"><a href="#113、将引用作为函数参数好处？" class="headerlink" title="113、将引用作为函数参数好处？"></a>113、将引用作为函数参数好处？</h2><ol>
<li><p>传递引用给函数和传递指针的效果是一样的【都对实参进行修改】</p>
</li>
<li><p>使用引用传递的参数，在内存中并没有实参的副本，而是直接对实参操作【如果传递的数据较大时，用引用效率更高】</p>
</li>
<li><p>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是在被调函数中同样要给形参分配存储单元<br>且需要重复使用”*”运算符进行运算，容易导致程序错误且阅读性较差。<br>同时，指针不如引用清晰</p>
</li>
</ol>
<hr>
<h2 id="114、指针和数组的区别？"><a href="#114、指针和数组的区别？" class="headerlink" title="114、指针和数组的区别？"></a>114、指针和数组的区别？</h2><ol>
<li><p>指针在内存中是连续存放的，开辟一块连续的内存空间；<br>数组所占存储空间：sizeof(数组名);<br>数组大小：sizeof(数组名)&#x2F;sizeof(数组元素数据类型);</p>
</li>
<li><p>用运算符sizeof可以计算出数组的容量（字节数)<br>sizeof(p)，p为指针得到的是一个指针变量的字节数，而不是p所指的内存容量。</p>
</li>
<li><p>编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。<br>具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</p>
</li>
<li><p>在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。<br>也就是传递过去的是数组的首地址而不是整个数组，能提高效率。</p>
</li>
<li><p>在使用下标的时候，两者的用法相同，都是源地址加下标地址，<br>不过数组的原地址就是数组首元素的地址是固定的，指针的原地址不是固定的。</p>
</li>
</ol>
<hr>
<h2 id="115、如何组织一个类被实例化？有哪些办法？"><a href="#115、如何组织一个类被实例化？有哪些办法？" class="headerlink" title="115、如何组织一个类被实例化？有哪些办法？"></a>115、如何组织一个类被实例化？有哪些办法？</h2><ol>
<li><p>将类定义为抽象基类或将构造函数声明为private</p>
</li>
<li><p>不允许类外部创建类对象，只能在类内部创建类对象</p>
</li>
</ol>
<hr>
<h2 id="116、如何禁止程序自动生成拷贝构造函数？"><a href="#116、如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="116、如何禁止程序自动生成拷贝构造函数？"></a>116、如何禁止程序自动生成拷贝构造函数？</h2><ol>
<li><p>为了组织编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动重写这两个函数<br>某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们要将它们设置为private，防止被调用。</p>
</li>
<li><p>类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生连接错误</p>
</li>
<li><p>真对上述两种情况，我们可以定义一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private，<br>那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此派生类将阻止编译器执行相关的操作。</p>
</li>
</ol>
<hr>
<h2 id="117、Debug和release的区别？"><a href="#117、Debug和release的区别？" class="headerlink" title="117、Debug和release的区别？"></a>117、Debug和release的区别？</h2><ol>
<li><p>调试版本，包含调试信息，因此容量比release大得多，并且不能进行任何优化（优化使调试复杂化，因为源代码和生成的指令间关系更复杂），便于调试。<br>Debug模式下生成两个文件，除了.exe和.dll文件之外，还有一个.pdb文件，该文件<code>记录了代码中断点等调试信息</code>。</p>
</li>
<li><p>发布版本，不对源代码进行任何调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。<br>（调试信息可在单独的PDB文件中生成）<br>Release模式下生成一个文件.exe或.dll文件</p>
</li>
<li><p>实际上，Debug和Release并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。<br>事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或带跟踪语句的发布版本。</p>
</li>
</ol>
<hr>
<h2 id="118、main函数的返回值有什么值得考究之处？"><a href="#118、main函数的返回值有什么值得考究之处？" class="headerlink" title="118、main函数的返回值有什么值得考究之处？"></a>118、main函数的返回值有什么值得考究之处？</h2><p>  程序运行过程入口点main函数，main()函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</p>
<h2 id="main-int-args-char-argv-参数的传递。参数的处理，一般会调用getopt-函数处理，但实践中，这仅仅是一部分，不会经常用到。"><a href="#main-int-args-char-argv-参数的传递。参数的处理，一般会调用getopt-函数处理，但实践中，这仅仅是一部分，不会经常用到。" class="headerlink" title="  main(int args, char **argv)参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到。"></a>  main(int args, char **argv)参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到。</h2><h2 id="119、模板类？写一个比较大小模板类"><a href="#119、模板类？写一个比较大小模板类" class="headerlink" title="119、模板类？写一个比较大小模板类"></a>119、模板类？写一个比较大小模板类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1, <span class="keyword">typename</span> type2&gt;  <span class="comment">// 函数模板</span></span><br><span class="line"><span class="function">type1 <span class="title">Max</span><span class="params">(type1 a, type2 b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Max = &quot;</span> &lt;&lt; <span class="built_in">Max</span>(<span class="number">5.5</span>, <span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该模板有个比较隐晦的bug，即a、b只有在能进行转型的时候才能进行比较，否则a &gt; b这一步是会报错的。</p>
<h2 id="这个时候往往需要对于-gt-号进行重载，代码量-；"><a href="#这个时候往往需要对于-gt-号进行重载，代码量-；" class="headerlink" title="这个时候往往需要对于 &gt; 号进行重载，代码量++；"></a>这个时候往往需要对于 &gt; 号进行重载，代码量++；</h2><h2 id="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#120、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>120、strcpy函数和strncpy函数的区别？哪个函数更安全？</h2><ol>
<li><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strcpy</span><span class="params">(<span class="type">char</span> * strDest, <span class="type">const</span> <span class="type">char</span>* strSrc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strncpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc, <span class="type">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strcpy函数：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出（buffer Overflow）的错误情况，在编写程序的时候特别留意，或用strncpy()；<br>strncpy函数：用来复制源字符串的前n个字符，src和dest所指的内存区域不能重叠，且dest必须有足够的空间存放n个字符。</p>
</li>
<li><p>如果目标长 &gt; 指定长 &gt; 源长，则将源长全部拷贝到目标长，自动加上’\0’<br>如果指定长 &lt; 源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’；<br>如果指定长 &gt; 目标长，运行时错误。<br>【源长：源字符串；指定长：指定的n；目标长：目的字符串】</p>
</li>
</ol>
<hr>
<h2 id="121、static-cast比C语言中的转换强在哪里？"><a href="#121、static-cast比C语言中的转换强在哪里？" class="headerlink" title="121、static_cast比C语言中的转换强在哪里？"></a>121、static_cast比C语言中的转换强在哪里？</h2><ol>
<li><p>更加安全</p>
</li>
<li><p>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；<br>可以清楚地辨别代码中每个显式的强制类型转换；<br>可读性更好，能体现程序员的意图。</p>
</li>
</ol>
<hr>
<h2 id="122、成员函数里memset-this-0-sizeof-this-会发生什么？"><a href="#122、成员函数里memset-this-0-sizeof-this-会发生什么？" class="headerlink" title="122、成员函数里memset(this, 0, sizeof(*this))会发生什么？"></a>122、成员函数里memset(this, 0, sizeof(*this))会发生什么？</h2><ol>
<li><p>有时候类里面定义了很多int, char, struct等C语言里的那些类型的变量，习惯在构造函数中都初始化为0，可以使用该语句全部置为0.<br>对于这种情况可以很好的工作，但也有例外情况</p>
</li>
<li><p>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数表的调用都将出现异常</p>
</li>
<li><p>类中含有C++类型的对象：例如，类中定义了一个list的对象，<br>由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，这样做就破坏了list对象的内存</p>
</li>
</ol>
<hr>
<h2 id="123、回调函数？作用？"><a href="#123、回调函数？作用？" class="headerlink" title="123、回调函数？作用？"></a>123、回调函数？作用？</h2><ol>
<li><p>当发生某种事件时，系统或其他函数将会自动调用程序员定义的一段函数。</p>
</li>
<li><p>回调函数就相当于一个中断处理函数，由系统在符合设定的条件时自动调用。<br>为此，应当做三件事：</p>
<ol>
<li>声明</li>
<li>定义</li>
<li>设置触发条件，即在函数中把回调函数名称转化为地址作为一个参数，以便系统调用。</li>
</ol>
</li>
<li><p>回调函数就是一个通过函数指针调用的函数。<br>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们称之为回调函数。</p>
</li>
<li><p>因为可以把调用者与被调用者分开。<br>调用者不关心谁是被调用者，所有它需要知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值int）的被调用函数。</p>
</li>
</ol>
<hr>
<h2 id="124、一致性哈希"><a href="#124、一致性哈希" class="headerlink" title="124、一致性哈希"></a>124、一致性哈希</h2><p><b>一致性哈希</b></p>
<p>一致性哈希是一种哈希算法，就是<b>在移除或增加一个结点时，能使尽可能小的改变已存在key的映射关系</b>。</p>
<p>尽可能少地改变已有的映射关系，一般是沿着顺时针进行操作，回答之前可以想想，真实情况如何处理</p>
<p>一致性哈希将整个哈希值空间<b>组织成一个虚拟的圆环<b>，假设哈希的值空间为 0~2^32-1，整个哈希环如图所示</p>
<img src="/2022/03/02/cpp/hash1.png" class="">

<p>一致性哈希的基本思想就是使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中，上右图显示了4个数据object1-4在环上的分布图</p>
<p><b>结点和数据映射</b></p>
<p>假设有一批服务器，可以根据IP或者主机名作为关键字进行哈希，根据结果映射到哈希环中，3台服务器分别是nodeA-C</p>
<p>现在有一批数据Object1-4需要存在服务器上，则可以使用相同的哈希算法对数据进行哈希，其结果必然也在环上，也可以沿着顺时针方向寻找，找到一个节点（服务器）就将数据存在该结点上，这样数据和结点就产生了一对一的关联，如下图所示：</p>
<img src="/2022/03/02/cpp/hash2.png" class="">

<p><b>移除结点</b></p>
<p>如果一台服务器出现问题，如上图的nodeB，则受影响的是其逆时针方向至下一个结点之间的数据，只需将这些数据映射到它顺时针方向的第一个结点上即可。<br>如下左图：</p>
<img src="/2022/03/02/cpp/hash3.png" class="">

<p><b>添加结点</b></p>
<p>如果新增一台服务器nodeD，受影响的是其逆时针方向至下一个结点之间的数据，将这些数据映射到nodeD上即可，如上右图</p>
<p><b>虚拟结点</b></p>
<p>假设仅有两台服务器：nodeA和nodeC，nodeA映射了1条数据，nodeC映射了3条，这样数据分布是不平衡的。</p>
<p>引入虚拟结点，假设结点复制个数为2，则nodeA变成：nodeA1 和 nodeA2，nodeC变成：nodeC1 和 nodeC2，映射情况如下：</p>
<img src="/2022/03/02/cpp/hash4.png" class="">

<h2 id="这样数据分布均衡，平衡性提高"><a href="#这样数据分布均衡，平衡性提高" class="headerlink" title="这样数据分布均衡，平衡性提高"></a>这样数据分布均衡，平衡性提高</h2><h2 id="125、C-从代码到可执行程序经历了什么？"><a href="#125、C-从代码到可执行程序经历了什么？" class="headerlink" title="125、C++从代码到可执行程序经历了什么？"></a>125、C++从代码到可执行程序经历了什么？</h2><ol>
<li><p>预编译<br>  主要处理源代码文件中的以”#”开头的预编译指令。处理规则如下：</p>
<ol>
<li><p>删除所有的#define 展开所有宏定义</p>
</li>
<li><p>处理所有的条件预编译指令，如”#if”、”#endif”、”#ifdef”、”#elif”、”#else”</p>
</li>
<li><p>处理”#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中可能包含其他文件。</p>
</li>
<li><p>删除所有的注释，”&#x2F;&#x2F;“和”&#x2F;**&#x2F;“</p>
</li>
<li><p>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once是为了防止有文件被重复引用</p>
</li>
<li><p>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时显示行号</p>
</li>
</ol>
</li>
<li><p>编译<br>  把预编译之后生成的xxx.i 或 xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ol>
<li><p>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
</li>
<li><p>语法分析：语法分析对由扫描器产生的记号进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为结点的树。</p>
</li>
<li><p>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，<br>      其分析的语义是<code>静态语义</code> —— 在编译器能分清的语义，相对应的动态语义是在运行期才能确定的语义。</p>
</li>
<li><p>优化：源代码级别的一个优化过程。</p>
</li>
<li><p>目标代码生成：由代码生成器将中间代码转化成目标机器代码，生成一系列的代码序列 —— 汇编语言表示。</p>
</li>
<li><p>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
</li>
</ol>
</li>
<li><p>汇编<br>  将汇编代码转变成机器可以执行的指令（机器码文件）。<br>  汇编器的编译过程相对于编译器来说更简单，没有复杂的语法和语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，<br>  汇编过程由汇编器完成。经汇编之后，产生目标文件（与可执行文件格式几乎一样）xxx.o（Windows下）、xxx.obj（Linux下）</p>
</li>
<li><p>链接<br>  将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接可以分为静态链接和动态链接：</p>
<ol>
<li>静态链接<br>   函数和数据被编译进一个二进制文件。<br>   在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制只写函数和数据并把它们和应用程序的其他模块组合起来创建最终可执行文件。</li>
</ol>
<p>   空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，<br>            所以如果多个程序对同一个目标文件都有依赖性，会出现同一个目标文件都在内存存在多个副本</p>
<p>   更新困难：每当库函数的代码修改，这时就要重新进行编译链接形成可执行程序。</p>
<p>   运行速度快：静态链接的优点就是在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<ol start="2">
<li>动态链接<br>   动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序<br>   而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li>
</ol>
<p>   共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享一个副本。</p>
<p>   更新方便：更新时只需要替换掉原来的目标文件，而无需将所有程序重新链接一遍。<br>            当程序下一次运行时，新版本的目标文件会被自动加载到内存并链接起来，程序就完成了升级的目标。</p>
<p>   性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
</li>
</ol>
<hr>
<h2 id="126、友元函数？"><a href="#126、友元函数？" class="headerlink" title="126、友元函数？"></a>126、友元函数？</h2><p>因为编译器必须能读取到这个结构的声明以理解这个数据类型的大小、行为等方面的所有规则。</p>
<p>而谁能访问private部分在任何关系中都很重要。</p>
<blockquote>
<p>补充：友元函数不一定要在类内声明，普通友元函数可以在类外声明<br>      只有友元工厂必须用到类内声明友元函数。</p>
</blockquote>
<hr>
<h2 id="127、友元函数和友元类的基本情况"><a href="#127、友元函数和友元类的基本情况" class="headerlink" title="127、友元函数和友元类的基本情况"></a>127、友元函数和友元类的基本情况</h2><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。<br>通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。<br>友元的正确使用能提高程序的陨星效率，但友元机制本身也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<ol>
<li>友元函数</li>
</ol>
<p>友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。<br>但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>友元函数举例</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;  <span class="comment">// 该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> t, A &amp;a)</span></span>&#123; <span class="comment">// 友元函数定义，为了访问类A中的成员</span></span><br><span class="line">  a.data = x;</span><br><span class="line">  cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<ol start="2">
<li>友元类<br>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）</li>
</ol>
<p>但是另一个类里面也要相应地进行声明</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>友元类例子</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;   <span class="comment">// 友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;  <span class="comment">// 友元类定义，为了访问类A中的成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>&#123;</span><br><span class="line">    a.data = x;  </span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  C c;</span><br><span class="line"></span><br><span class="line">  c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<p>使用友元类时注意：</p>
<ol>
<li><p>友元关系不能被继承。</p>
</li>
<li><p>友元关系是单向的，不具有交互性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明</p>
</li>
<li><p>友元关系不具有传递性，若类B是类A的友元，类C是类B的友元，则类C不一定是类A的友元，要看类中是否有对应声明</p>
</li>
</ol>
<hr>
<h2 id="128、使用C语言实现C-的继承"><a href="#128、使用C语言实现C-的继承" class="headerlink" title="128、使用C语言实现C++的继承"></a>128、使用C语言实现C++的继承</h2><div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>C语言实现C++继承</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++中的继承与多态</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;   <span class="comment">// C++中的多态，使用虚函数实现</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;  <span class="comment">// C++中的继承：B类共有继承A类</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;   <span class="comment">// C++中的多态：通过虚函数实现（子类的关键字virtual可加可不加）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言模拟C++的继承与多态</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FUN)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_A</span>&#123;  <span class="comment">// 父类</span></span><br><span class="line">  FUN _fun; <span class="comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_B</span>&#123;  <span class="comment">// 子类</span></span><br><span class="line">  _A _a_;   <span class="comment">// 在子类中定义一个基类的对象即可实现对父类的继承</span></span><br><span class="line">  <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fA()&#123; <span class="comment">// 父类的同名函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;_A:_fun()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fB()&#123; <span class="comment">// 子类的同名函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;_B:_fun()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 测试C++中的继承与多态</span></span><br><span class="line"></span><br><span class="line">  A a;  <span class="comment">// 定义一个父类对象a</span></span><br><span class="line">  B b;  <span class="comment">// 定义一个子类对象b</span></span><br><span class="line"></span><br><span class="line">  A* p1 = &amp;a; <span class="comment">// 定义一个父类指针指向父类的对象</span></span><br><span class="line"></span><br><span class="line">  p1-&gt;<span class="built_in">fun</span>();  <span class="comment">// 调用父类同名函数</span></span><br><span class="line"></span><br><span class="line">  p1 = &amp;b;  <span class="comment">// 让父类指针指向子类的对象</span></span><br><span class="line"></span><br><span class="line">  p1-&gt;<span class="built_in">fun</span>();  <span class="comment">// 调用子类同名函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// C语言模拟继承与多态</span></span><br><span class="line"></span><br><span class="line">  _A _a;  <span class="comment">// 定义一个父类对象 _a;</span></span><br><span class="line">  _B _b;  <span class="comment">// 定义一个子类对象 _b;</span></span><br><span class="line"></span><br><span class="line">  _a._fun = _fA;  <span class="comment">// 父类对象调用父类的同名函数</span></span><br><span class="line">  _b._a_._fun = _fB;  <span class="comment">// 子类的对象调用子类的同名函数</span></span><br><span class="line"></span><br><span class="line">  _A* p2 = &amp;_a; <span class="comment">// 定义一个父类指针指向父类的对象</span></span><br><span class="line">  p2-&gt;_fun(); <span class="comment">// 调用父类同名函数</span></span><br><span class="line"></span><br><span class="line">  p2 = (_A*) &amp;_b; <span class="comment">// 让父类指针指向子类的对象，由于类型不匹配所以要强制类型转换</span></span><br><span class="line">  p2-&gt;_fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<hr>
<h2 id="129、动态编译和静态编译"><a href="#129、动态编译和静态编译" class="headerlink" title="129、动态编译和静态编译"></a>129、动态编译和静态编译</h2><ol>
<li><p>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不依赖动态链接库</p>
</li>
<li><p>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。<br>优点：</p>
<ol>
<li><p>缩小了执行文件本身的体积</p>
</li>
<li><p>加快了编译速度，节省系统资源。<br>缺点：</p>
</li>
<li><p>哪怕很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库</p>
</li>
<li><p>如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="130、hello-c程序的编译过程"><a href="#130、hello-c程序的编译过程" class="headerlink" title="130、hello.c程序的编译过程"></a>130、hello.c程序的编译过程</h2><div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子程序</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
    </div></div>
    </div>
<p>在Unix系统上，编译器将源文件转换为目标文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<img src="/2022/03/02/cpp/cppCompile.png" class="">

<ul>
<li><p>预处理阶段：处理以#开头的预处理命令；</p>
</li>
<li><p>编译阶段：翻译成汇编文件</p>
</li>
<li><p>汇编阶段：将汇编文件翻译成可重定位目标文件；</p>
</li>
<li><p>链接阶段：将可重定位目标文件和printf.o等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</p>
<ul>
<li><p>静态链接：<br> 静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件为输出。连接器主要完成以下两个任务：</p>
<ol>
<li><p>符号解析：每个符号对应一个函数、全局变量或一个静态变量，符号解析的目的是将每个符号引用于一个符号定义关联起来。</p>
</li>
<li><p>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得他们指向这个内存位置。</p>
</li>
</ol>
   
</li>
<li><p>目标文件：</p>
<ol>
<li><p>可执行目标文件： 可以直接在内存中执行；</p>
</li>
<li><p>可重定位目标文件：可与其他可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</p>
</li>
<li><p>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载到内存并链接；</p>
</li>
</ol>
</li>
<li><p>动态连接：<br>  静态库有以下两个问题：<br>1. 当静态库更新时那么整个程序都要重新进行链接<br><br>2. 对于printf这种标准函数库，如果每个程序都要有代码，则会极大浪费资源<br>  共享库就是为了解决静态库的这两个问题设计的，在Linux系统中通常会用.so后缀来表示，Windows系统上它们被称为DLL。<br>  共享库具有以下特点：<br>1. 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；<br><br>2. 在内存中，一个共享库的.text节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</p>
  </li>
</ul>
</li>
</ul>
<hr>
<h2 id="131、源代码-gt-预处理-gt-编译-gt-优化-gt-汇编-gt-链接-gt-可执行文件"><a href="#131、源代码-gt-预处理-gt-编译-gt-优化-gt-汇编-gt-链接-gt-可执行文件" class="headerlink" title="131、源代码 -&gt; 预处理 -&gt; 编译 -&gt; 优化 -&gt; 汇编 -&gt; 链接 -&gt; 可执行文件"></a>131、源代码 -&gt; 预处理 -&gt; 编译 -&gt; 优化 -&gt; 汇编 -&gt; 链接 -&gt; 可执行文件</h2><ol>
<li><p>预处理<br>读取C源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。<br>包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。<br>预编译程序所完成的基本上是对源程序的“替代”工作。<br>经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。<br>.i预处理后的c文件，.ii预处理后的C++文件。</p>
</li>
<li><p>编译阶段<br>编译程序所要作的工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则后，将其翻译成等价的中间代码表示或汇编代码.s文件。</p>
</li>
<li><p>汇编过程<br>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。<br>对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。<br>目标文件中所存放的也就是与源程序等效的目标的机器语言代码.o文件</p>
</li>
<li><p>链接阶段<br>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义链接起来。<br>使得所有的这些目标文件称为一个能够被操作系统装入执行的统一整体。</p>
</li>
</ol>
<hr>
<h2 id="132、经典的锁"><a href="#132、经典的锁" class="headerlink" title="132、经典的锁"></a>132、经典的锁</h2><ol>
<li>读写锁</li>
</ol>
<ul>
<li><p>多个读者可以同时进行读</p>
</li>
<li><p>写者必须互斥（只允许一个写者写，不能读者写者同时进行）</p>
</li>
<li><p>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</p>
</li>
</ul>
<ol start="2">
<li>互斥锁<br>  一次只能一个线程拥有互斥锁，其他线程只有等待</li>
</ol>
<p>  互斥锁是在抢所失败的情况下主动放弃CPU进入睡眠状态，直到锁的状态改变时再唤醒，操作系统负责线程调度<br>  为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文切换。<br>  互斥锁实际的效率还是可以让人接受的，加锁时间大概100ns左右，实际上互斥锁的一种可能实现是自旋一段时间，当自旋的时间超过阈值后将线程投入睡眠，<br>  因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。</p>
<ol start="3">
<li>条件变量<br>  互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。<br>  条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。</li>
</ol>
<p>  当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。<br>  一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。</p>
<p>  总的来说互斥锁是线程间<code>互斥机制</code>，条件变量是<code>同步机制</code>。</p>
<ol start="4">
<li>自旋锁<br>  如果进线程无法取得锁，进线程不会立即放弃CPU时间片，而是一直循环尝试获取锁，知道获取为止。<br>  如果别的线程长时间占有锁，则自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率较高。</li>
</ol>
<hr>
<h2 id="133、delete和delete-的区别？"><a href="#133、delete和delete-的区别？" class="headerlink" title="133、delete和delete[]的区别？"></a>133、delete和delete[]的区别？</h2><ul>
<li><p>delete只会调用一次析构函数</p>
</li>
<li><p>delete[]会调用数组中每个元素的析构函数</p>
</li>
</ul>
<hr>
<h2 id="134、为什么不能把所有的函数写成内联？"><a href="#134、为什么不能把所有的函数写成内联？" class="headerlink" title="134、为什么不能把所有的函数写成内联？"></a>134、为什么不能把所有的函数写成内联？</h2><p>内联函数以代码复杂为代价，省去函数调用的开销提高执行效率。</p>
<p>一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大意义；<br>另一方面，每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不适合内联函数：</p>
<ol>
<li><p>函数体内代码较长，将导致内存消耗代价</p>
</li>
<li><p>函数体内有循环，函数执行时间要比函数调用开销大</p>
</li>
</ol>
<hr>
<h2 id="135、为什么C-没有垃圾回收机制？"><a href="#135、为什么C-没有垃圾回收机制？" class="headerlink" title="135、为什么C++没有垃圾回收机制？"></a>135、为什么C++没有垃圾回收机制？</h2><p>首先，实现一个垃圾回收器会带来额外的空间和时间开销。需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲时间进行free</p>
<p>垃圾回收会使得C++不适合进行很多很底层的操作</p>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/03/02/cpp/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/03/02/cpp/";
            const title         = "「cpp」";
            const excerpt       = `C++相关知识，非原创`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-03-30</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" courseraWED" href="/2022/03/01/courseraWED/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" STL" href="/2022/03/24/STL/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/Ru.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">人间归离复归离，借一浮生逃浮生</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">一、基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1、在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98"><span class="toc-text">2、结构体内存对齐问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3、指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9C%A8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-text">4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5、堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9"><span class="toc-text">6、栈快一点还是堆快一点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">7、区别以下指针类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81new-x2F-delete-%E5%92%8C-malloc-x2F-free%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">8、new&#x2F;delete 和 malloc&#x2F;free的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">9、new和delete是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81malloc-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">10、malloc 和 new 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86malloc-x2F-free%EF%BC%8Cc-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81new-x2F-delete%EF%BC%9F"><span class="toc-text">11、既然有了malloc&#x2F;free，c++中为什么还需要new&#x2F;delete？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="toc-text">12、被free回收的内存是立即返还给操作系统吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">13、宏定义和函数有何区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">14、宏定义和typedef的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">15、变量声明和定义区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81stelen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">16、stelen和sizeof的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">17、常量指针和指针常量的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81a%E5%92%8C-amp-a%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">18、a和&amp;a有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81C-%E5%92%8CPython%E5%8C%BA%E5%88%AB"><span class="toc-text">19、C++和Python区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81C-%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">20、C++和C语言的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81C-%E4%B8%8EJava%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">21、C++与Java的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">22、C++中struct和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">23、define宏定义和const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81C-%E4%B8%ADconst%E5%92%8Cstatic%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">24、C++中const和static的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81C-%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-text">25、C++的顶层const和底层const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%BA%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">26、数组名和指针（这里为指向数组首元素的指针）区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81final%E5%92%8Coverride%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">27、final和override关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">28、拷贝初始化和直接初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">29、初始化和赋值的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E3%80%81extern%E2%80%9DC%E2%80%9D%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">30、extern”C”的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-text">31、野指针和悬空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E3%80%81C%E5%92%8CC-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">32、C和C++的类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E3%80%81C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E5%92%8C%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">33、C++中的重载、重写（覆盖）和隐藏的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E3%80%81C-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">34、C++有哪几种构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">35、浅拷贝和深拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">36、内联函数和宏定义的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37%E3%80%81public-x2F-protected-x2F-private%E8%AE%BF%E9%97%AE%E5%92%8Cpublic-x2F-protected-x2F-private%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">37、public&#x2F;protected&#x2F;private访问和public&#x2F;protected&#x2F;private继承权限的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-text">38、如何用代码判断大小端存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E3%80%81volatile%E3%80%81mutable%E5%92%8Cexplicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">39、volatile、mutable和explicit关键字的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">40、什么情况下会调用拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E3%80%81C-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8Bnew"><span class="toc-text">41、C++有几种类型new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E3%80%81C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">42、C++的异常处理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E3%80%81static%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">43、static的用法和作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">44、指针和const的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45%E3%80%81%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">45、形参和实参的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%95%88%E7%8E%87"><span class="toc-text">46、值传递、指针传递、引用传递的区别和效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">47、静态变量什么时候初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E3%80%81const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">48、const关键字的作用有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-text">49、什么是类的继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50%E3%80%81%E4%BB%8E%E6%B1%87%E7%BC%96%E5%B1%82%E5%8E%BB%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%BC%95%E7%94%A8"><span class="toc-text">50、从汇编层去解释一下引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E8%80%83%E6%9D%A1%E7%9B%AE35"><span class="toc-text">51、深拷贝和浅拷贝？ —— 参考条目35</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E3%80%81new%E5%92%8Cmalloc%E5%8C%BA%E5%88%AB%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E8%80%83%E6%9D%A1%E7%9B%AE10"><span class="toc-text">52、new和malloc区别？ —— 参考条目10</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53%E3%80%81delete-p%E3%80%81delete-p%E3%80%81allocator%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">53、delete p、delete []p、allocator都有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E7%9A%84%EF%BC%9F"><span class="toc-text">54、new和delete的实现原理，delete是如何知道释放内存大小的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55%E3%80%81malloc%E7%94%B3%E8%AF%B7%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E8%83%BD%E7%94%A8delete%E9%87%8A%E6%94%BE%E5%90%97%EF%BC%9F"><span class="toc-text">55、malloc申请的存储空间能用delete释放吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56%E3%80%81malloc%E5%92%8Cfree%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">56、malloc和free的实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57%E3%80%81malloc%E3%80%81realloc%E3%80%81calloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">57、malloc、realloc、calloc的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58%E3%80%81%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%9F"><span class="toc-text">58、类成员初始化方式？构造函数执行顺序？为什么用成员初始化列表快一些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E7%94%A8%E5%88%B0%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">59、有哪些情况必须用到成员列表初始化？作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60%E3%80%81C-%E4%B8%AD%E6%96%B0%E5%A2%9E%E4%BA%86string%EF%BC%8C%E5%AE%83%E4%B8%8EC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">60、C++中新增了string，它与C语言中的char *有什么区别吗？如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95%EF%BC%8C%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%89%A9%E5%B1%95%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%A6%E5%A4%96%E7%94%B3%E8%AF%B7%E4%B8%80%E5%9D%97%E5%8E%9F%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F2%E5%80%8D%E7%9A%84%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E6%BA%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E8%BF%87%E5%8E%BB%EF%BC%8C%E5%B9%B6%E5%8A%A0%E4%B8%8A%E6%96%B0%E5%A2%9E%E5%86%85%E5%AE%B9%E3%80%82"><span class="toc-text">  string 可以进行自动扩展，在每次扩展的时候另外申请一块原空间大小2倍的空间，然后将源字符串拷贝过去，并加上新增内容。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E3%80%81%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%92%8C%E9%81%BF%E5%85%8D"><span class="toc-text">61、什么是内存泄漏、如何检测和避免</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-text">62、对象复用的了解、零拷贝的了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E3%80%81%E4%BB%8B%E7%BB%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">63、介绍面向对象的三大特性，并举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E3%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%AE%83%E4%BC%9A%E5%BF%AB%E4%B8%80%E7%82%B9-%E2%80%94%E2%80%94-%E5%8F%82%E8%80%83%E6%9D%A1%E7%9B%AE58"><span class="toc-text">64、成员初始化列表的概念，为什么用它会快一点 —— 参考条目58</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E3%80%81C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2reinterpret-cast-x2F-const-cast-x2F-static-cast-x2F-dynamic-cast"><span class="toc-text">65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast&#x2F;dynamic_cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66%E3%80%81C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B"><span class="toc-text">66、C++函数调用的压栈过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%87%BD%E6%95%B0%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%94%A8%E6%99%AE%E9%80%9Areturn%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87%E4%BC%A0%E5%9B%9E%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%9B%E8%A1%8C%EF%BC%8C%E5%8D%B3%E5%9C%B0%E5%9D%80-x2F-%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%82"><span class="toc-text">当函数有多个返回值时，不能用普通return方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67%E3%80%81%E5%86%99C-%E4%BB%A3%E7%A0%81%E6%97%B6%E6%9C%89%E4%B8%80%E7%B1%BB%E9%94%99%E8%AF%AF%E6%98%AFcoredump%EF%BC%8C%E5%B8%B8%E8%A7%81%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%EF%BC%9F"><span class="toc-text">67、写C++代码时有一类错误是coredump，常见，如何调试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68%E3%80%81%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">68、移动构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69%E3%80%81C-%E4%B8%AD%E5%B0%86%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">69、C++中将临时变量做返回值的处理过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E5%8D%B3%E5%8F%AF"><span class="toc-text">如果需要返回值，一般使用赋值语句即可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%BB%93%E6%9E%84%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E8%8A%82%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-text">70、如何获得结构成员相对于结构开头的字节偏移量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">71、静态类型和动态类型，静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E3%80%81%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">72、引用是否能实现动态绑定，为什么可以实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B3%EF%BC%9A%E8%99%9A%E5%87%BD%E6%95%B0%E6%89%8D%E6%9C%89%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E9%87%87%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">即：虚函数才有动态绑定，采用虚函数情况下，使用的是动态绑定对象的虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">73、全局变量和局部变量有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74%E3%80%81%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">74、指针加减计算要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">75、如何判断两个浮点数相等？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E8%AF%AF%E5%B7%AE%E5%B0%8F%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E7%94%A8-x3D-x3D"><span class="toc-text">要误差小于某个特定的值，不能直接用&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E6%A0%88%E3%80%81%E6%B1%87%E7%BC%96%EF%BC%89"><span class="toc-text">76、方法调用的原理（栈、汇编）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77%E3%80%81C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E4%B8%8E%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">77、C++中的指针参与传递和引用参数传递有什么区别？底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78%E3%80%81%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">78、类如何实现只能静态分配和只能动态分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79%E3%80%81%E5%A6%82%E6%9E%9C%E6%83%B3%E5%B0%86%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BD%9C%E5%9F%BA%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E8%80%8C%E9%9D%9E%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="toc-text">79、如果想将某个类用作基类，为什么该类必须定义而非声明？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80%E3%80%81%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">80、继承机制中对象之间如何转换？指针和引用之间如何转换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81%E3%80%81C-%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%8C%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">81、C++中的组合，和继承相比缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">82、函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83%E3%80%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%8F%8A%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="toc-text">83、内存对齐及原因。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-text">84、结构体变量比较是否相等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E5%93%AA%E4%B8%AA%E5%85%88%E5%85%A5%E6%A0%88%EF%BC%9F"><span class="toc-text">85、函数调用过程栈的变化，返回值和参数变量哪个先入栈？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86%E3%80%81define%E3%80%81const%E3%80%81typedef%E3%80%81inline%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">86、define、const、typedef、inline的使用方法？他们之间的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87%E3%80%81printf%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">87、printf的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AAh%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-text">88、为什么模板类一般都是放在一个h文件中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89%E3%80%81C-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE37"><span class="toc-text">89、C++中类成员的访问权限和继承权限问题 —— 参见条目37</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90%E3%80%81cout-%E5%92%8C-printf-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">90、cout 和 printf 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flush%E7%AB%8B%E5%8D%B3%E5%BC%BA%E8%BF%AB%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8Cprintf%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%89%E8%BE%93%E5%87%BA%E6%97%B6%E7%AB%8B%E5%8D%B3%E8%BE%93%E5%87%BA%E3%80%82"><span class="toc-text">flush立即强迫缓冲输出，printf是无缓冲输出，有输出时立即输出。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91%E3%80%81%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">91、重载运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92%E3%80%81%E5%BD%93%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">92、当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93%E3%80%81%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE15"><span class="toc-text">93、定义和声明的区别 —— 参见条目15</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%8F%98%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-text">有变量、函数的声明和定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8Cstatic%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">94、全局变量和static变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">95、静态成员与普通成员的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96%E3%80%81ifdef%E5%92%8Cendif%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">96、ifdef和endif代表什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97%E3%80%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">97、隐式转换，如何消除隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98%E3%80%81C-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F"><span class="toc-text">98、C++如何处理多个异常的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="toc-text">99、如何在不使用额外空间的情况下，交换两个数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100%E3%80%81strcpy%E5%92%8Cmemcpy%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">100、strcpy和memcpy的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101%E3%80%81%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8Cint-main-int-argc-char-argc-%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">101、程序在执行int main(int argc, char *argc[])时的内存结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8-%E2%80%94%E2%80%94-%E5%8F%82%E8%A7%81%E6%9D%A1%E7%9B%AE39"><span class="toc-text">102、volatile关键字的作用 —— 参见条目39</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103%E3%80%81%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">103、如果有一个空类，它会默认添加哪些函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104%E3%80%81C-%E4%B8%AD%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">104、C++中标准库是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105%E3%80%81const-char-%E5%92%8C-string%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">105、const char* 和 string之间的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E7%94%A8%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-text">106、什么情况用指针参数，什么时候用引用参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107%E3%80%81%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F-%E2%80%94%E2%80%94-%E5%8F%82%E7%85%A7%E6%9D%A1%E7%9B%AE71"><span class="toc-text">107、静态绑定和动态绑定？ —— 参照条目71</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E4%BB%85%E5%8D%95%E4%B8%AA%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0"><span class="toc-text">108、如何设计一个计算仅单个子类的对象个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#109%E3%80%81%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-text">109、如何快速定位错误出现的地方？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B-%E2%80%94%E2%80%94-%E5%8F%82%E7%85%A7%E6%9D%A1%E7%9B%AE59"><span class="toc-text">110、初始化成员列表什么时候用？调用过程 —— 参照条目59</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%9F%BA%E7%B1%BB%E3%80%81%E6%88%90%E5%91%98%E7%B1%BB%EF%BC%8C%E6%8C%89%E7%85%A7%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-text">引用、常量、基类、成员类，按照类中定义顺序执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111%E3%80%81%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%A0%E9%80%92%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E6%88%96%E8%80%85%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4strcpy%E3%80%81sprintf%E5%92%8Cmemcpy%E8%BF%99%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">112、说一说strcpy、sprintf和memcpy这三个函数的不同之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113%E3%80%81%E5%B0%86%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">113、将引用作为函数参数好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">114、指针和数组的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="toc-text">115、如何组织一个类被实例化？有哪些办法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116%E3%80%81%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">116、如何禁止程序自动生成拷贝构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#117%E3%80%81Debug%E5%92%8Crelease%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">117、Debug和release的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118%E3%80%81main%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9C%89%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E8%80%83%E7%A9%B6%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="toc-text">118、main函数的返回值有什么值得考究之处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-int-args-char-argv-%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E3%80%82%E5%8F%82%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E4%B8%80%E8%88%AC%E4%BC%9A%E8%B0%83%E7%94%A8getopt-%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%EF%BC%8C%E4%BD%86%E5%AE%9E%E8%B7%B5%E4%B8%AD%EF%BC%8C%E8%BF%99%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E4%B8%8D%E4%BC%9A%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E3%80%82"><span class="toc-text">  main(int args, char **argv)参数的传递。参数的处理，一般会调用getopt()函数处理，但实践中，这仅仅是一部分，不会经常用到。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#119%E3%80%81%E6%A8%A1%E6%9D%BF%E7%B1%BB%EF%BC%9F%E5%86%99%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">119、模板类？写一个比较大小模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%BE%80%E5%BE%80%E9%9C%80%E8%A6%81%E5%AF%B9%E4%BA%8E-gt-%E5%8F%B7%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%87%8F-%EF%BC%9B"><span class="toc-text">这个时候往往需要对于 &gt; 号进行重载，代码量++；</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#120%E3%80%81strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">120、strcpy函数和strncpy函数的区别？哪个函数更安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121%E3%80%81static-cast%E6%AF%94C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BC%BA%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">121、static_cast比C语言中的转换强在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122%E3%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8Cmemset-this-0-sizeof-this-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">122、成员函数里memset(this, 0, sizeof(*this))会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">123、回调函数？作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-text">124、一致性哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%9D%87%E8%A1%A1%EF%BC%8C%E5%B9%B3%E8%A1%A1%E6%80%A7%E6%8F%90%E9%AB%98"><span class="toc-text">这样数据分布均衡，平衡性提高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#125%E3%80%81C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">125、C++从代码到可执行程序经历了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#126%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">126、友元函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#127%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="toc-text">127、友元函数和友元类的基本情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128%E3%80%81%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0C-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">128、使用C语言实现C++的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#129%E3%80%81%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91"><span class="toc-text">129、动态编译和静态编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#130%E3%80%81hello-c%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-text">130、hello.c程序的编译过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131%E3%80%81%E6%BA%90%E4%BB%A3%E7%A0%81-gt-%E9%A2%84%E5%A4%84%E7%90%86-gt-%E7%BC%96%E8%AF%91-gt-%E4%BC%98%E5%8C%96-gt-%E6%B1%87%E7%BC%96-gt-%E9%93%BE%E6%8E%A5-gt-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-text">131、源代码 -&gt; 预处理 -&gt; 编译 -&gt; 优化 -&gt; 汇编 -&gt; 链接 -&gt; 可执行文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132%E3%80%81%E7%BB%8F%E5%85%B8%E7%9A%84%E9%94%81"><span class="toc-text">132、经典的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#133%E3%80%81delete%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">133、delete和delete[]的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%99%E6%88%90%E5%86%85%E8%81%94%EF%BC%9F"><span class="toc-text">134、为什么不能把所有的函数写成内联？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">135、为什么C++没有垃圾回收机制？</span></a></li></ol></li></ol>
    </div>
</aside>
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 0.6em;">动态规划</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.8em;">数据库</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.6em;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.6em;">计算机网络</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/03/30/Git/"><i class="fa  fa-book"></i> Git</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/28/cppRest/"><i class="fa  fa-book"></i> cppRest</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/27/cpp11/"><i class="fa  fa-book"></i> cpp11</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/26/cppMemory/"><i class="fa  fa-book"></i> cppMemory</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/24/STL/"><i class="fa  fa-book"></i> STL</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/ReisenU"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@ReisenU"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/ReisenUx"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 月战老兵月球基地 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by ReisenU.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>




    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="7292006123"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>